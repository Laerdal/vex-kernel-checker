{
  "bomFormat": "CycloneDX",
  "metadata": {
    "component": {
      "bom-ref": "81968588-121d-4480-981f-5494ac2acf71",
      "name": "SimPad PLUS 2 System",
      "type": "operating-system",
      "version": "9.0.8-copy"
    },
    "timestamp": "2025-07-05T15:42:16Z",
    "tools": [
      {
        "name": "Dependency-Track",
        "vendor": "OWASP",
        "version": "4.13.2"
      }
    ]
  },
  "serialNumber": "urn:uuid:907ce46a-a5be-4dff-a948-ede51441eb1d",
  "specVersion": "1.5",
  "version": 1,
  "vulnerabilities": [
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "f1c46e8b-eef6-462b-be39-749c2430b657",
      "cwes": [
        617
      ],
      "description": "A vulnerability was found in Avahi, where a reachable assertion exists in avahi_dns_packet_append_record.",
      "id": "CVE-2023-38469",
      "published": "2023-11-02T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "52939ce3-1b6e-43c6-8956-cfb4e509a5db",
      "cwes": [
        617
      ],
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_escape_label() function.",
      "id": "CVE-2023-38470",
      "published": "2023-11-02T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "757e4ade-dc06-4fa4-8e51-de8807e6c0c5",
      "cwes": [
        617
      ],
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the dbus_set_host_name function.",
      "id": "CVE-2023-38471",
      "published": "2023-11-02T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "d30a6a1e-dca0-4b6b-b8f6-52759425319f",
      "cwes": [
        617
      ],
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_rdata_parse() function.",
      "id": "CVE-2023-38472",
      "published": "2023-11-02T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "4c9d00c7-79d1-478c-b3cc-355c08056cc3",
      "cwes": [
        617
      ],
      "description": "A vulnerability was found in Avahi. A reachable assertion exists in the avahi_alternative_host_name() function.",
      "id": "CVE-2023-38473",
      "published": "2023-11-02T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "bb9041a4-02ec-4518-8232-32687394a5c4",
      "cwes": [
        59
      ],
      "description": "avahi-daemon-check-dns.sh in the Debian avahi package through 0.8-4 is executed as root via /etc/network/if-up.d/avahi-daemon, and allows a local attacker to cause a denial of service or create arbitrary empty files via a symlink attack on files under /run/avahi-daemon. NOTE: this only affects the packaging for Debian GNU/Linux (used indirectly by SUSE), not the upstream Avahi product.",
      "id": "CVE-2021-26720",
      "published": "2021-02-17T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "d7ea94d1-0f78-43f6-8fed-0c6609b7c7f6",
      "cwes": [
        835
      ],
      "description": "A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.",
      "id": "CVE-2021-3468",
      "published": "2021-06-02T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "619af5bd-4516-4613-b33f-bd374a47018d",
      "description": "There had existed in one of the ISC BIND libraries a bug in a function that was used by dhcpd when operating in DHCPv6 mode. There was also a bug in dhcpd relating to the use of this function per its documentation, but the bug in the library function prevented this from causing any harm. All releases of dhcpd from ISC contain copies of this, and other, BIND libraries in combinations that have been tested prior to release and are known to not present issues like this. Some third-party packagers of ISC software have modified the dhcpd source, BIND source, or version matchup in ways that create the crash potential. Based on reports available to ISC, the crash probability is large and no analysis has been done on how, or even if, the probability can be manipulated by an attacker. Affects: Builds of dhcpd versions prior to version 4.4.1 when using BIND versions 9.11.2 or later, or BIND versions with specific bug fixes backported to them. ISC does not have access to comprehensive version lists for all repackagings of dhcpd that are vulnerable. In particular, builds from other vendors may also be affected. Operators are advised to consult their vendor documentation.",
      "id": "CVE-2019-6470",
      "published": "2019-11-01T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-11T14:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "15e0fc00-c5ee-44a3-82d7-6c4fd36d2da0",
      "cwes": [
        787
      ],
      "description": "A flaw was found in cairo's image-compositor.c in all versions prior to 1.17.4. This flaw allows an attacker who can provide a crafted input file to cairo's image-compositor (for example, by convincing a user to open a file in an application using cairo, or if an application uses cairo on untrusted input) to cause a stack buffer overflow -> out-of-bounds WRITE. The highest impact from this vulnerability is to confidentiality, integrity, as well as system availability.",
      "id": "CVE-2020-35492",
      "published": "2021-03-18T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "3fb06658-a57b-4f2f-abb8-d036fa6e0a66",
      "cwes": [
        617
      ],
      "description": "An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.",
      "id": "CVE-2019-6461",
      "published": "2019-01-16T18:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "ce9580d7-1c33-4179-b4ff-554b9be71171",
      "cwes": [
        835
      ],
      "description": "An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.",
      "id": "CVE-2019-6462",
      "published": "2019-01-16T18:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "fcb4c3b9-a4e3-4907-ba8a-981dd569a279",
      "cwes": [
        416
      ],
      "description": "cairo 1.16.0, in cairo_ft_apply_variations() in cairo-ft-font.c, would free memory using a free function incompatible with WebKit's fastMalloc, leading to an application crash with a \"free(): invalid pointer\" error.",
      "id": "CVE-2018-19876",
      "published": "2018-12-05T20:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T03:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "427de1b5-63f0-4ff0-86ee-65699cc4df9c",
      "cwes": [
        125
      ],
      "description": "c-ares is a C library for asynchronous DNS requests. `ares__read_line()` is used to parse local configuration files such as `/etc/resolv.conf`, `/etc/nsswitch.conf`, the `HOSTALIASES` file, and if using a c-ares version prior to 1.27.0, the `/etc/hosts` file. If any of these configuration files has an embedded `NULL` character as the first character in a new line, it can lead to attempting to read memory prior to the start of the given buffer which may result in a crash. This issue is fixed in c-ares 1.27.0. No known workarounds exist.",
      "id": "CVE-2024-25629",
      "published": "2024-02-23T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-05T21:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "c98310bc-b9b1-4196-a980-4105a036cf5d",
      "cwes": [
        330
      ],
      "description": "c-ares is an asynchronous resolver library. When cross-compiling c-ares and using the autotools build system, CARES_RANDOM_FILE will not be set, as seen when cross compiling aarch64 android. This will downgrade to using rand() as a fallback which could allow an attacker to take advantage of the lack of entropy by not using a CSPRNG. This issue was patched in version 1.19.1.",
      "id": "CVE-2023-31124",
      "published": "2023-05-25T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.7,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "5b9775d9-cf1a-437b-9dc8-7c0559d9cc0d",
      "cwes": [
        787
      ],
      "description": "c-ares is an asynchronous resolver library. ares_inet_net_pton() is vulnerable to a buffer underflow for certain ipv6 addresses, in particular \"0::00:00:00/2\" was found to cause an issue. C-ares only uses this function internally for configuration purposes which would require an administrator to configure such an address via ares_set_sortlist(). However, users may externally use ares_inet_net_pton() for other purposes and thus be vulnerable to more severe issues. This issue has been fixed in 1.19.1.",
      "id": "CVE-2023-31130",
      "published": "2023-05-25T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "655ec2fd-7855-4f5a-ba93-3f24610ec6ab",
      "description": "c-ares is an asynchronous resolver library. When /dev/urandom or RtlGenRandom() are unavailable, c-ares uses rand() to generate random numbers used for DNS query ids. This is not a CSPRNG, and it is also not seeded by srand() so will generate predictable output. Input from the random number generator is fed into a non-compilant RC4 implementation and may not be as strong as the original RC4 implementation. No attempt is made to look for modern OS-provided CSPRNGs like arc4random() that is widely available. This issue has been fixed in version 1.19.1.",
      "id": "CVE-2023-31147",
      "published": "2023-05-25T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "bd4691da-2221-40fb-ac10-5fd4b1081cd5",
      "description": "c-ares is an asynchronous resolver library. c-ares is vulnerable to denial of service. If a target resolver sends a query, the attacker forges a malformed UDP packet with a length of 0 and returns them to the target resolver. The target resolver erroneously interprets the 0 length as a graceful shutdown of the connection. This issue has been patched in version 1.19.1.",
      "id": "CVE-2023-32067",
      "published": "2023-05-25T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "729b1db6-ec45-4848-8293-0cbf69a7452a",
      "cwes": [
        1284
      ],
      "description": "A flaw was found in the c-ares package. The ares_set_sortlist is missing checks about the validity of the input string, which allows a possible arbitrary length stack overflow. This issue may cause a denial of service or a limited impact on confidentiality and integrity.",
      "id": "CVE-2022-4904",
      "published": "2023-03-06T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.6,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "34b4a2ce-e1e4-4121-b2e3-a6c02a3d9e2e",
      "cwes": [
        20
      ],
      "description": "chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
      "id": "CVE-2016-2781",
      "published": "2017-02-07T15:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:P/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "abc11923-6dbf-4511-99e7-c4933128e4e4",
      "cwes": [
        59
      ],
      "description": "cpio, as used in build 2007.05.10, 2010.07.28, and possibly other versions, allows remote attackers to overwrite arbitrary files via a symlink within an RPM package archive.",
      "id": "CVE-2010-4226",
      "published": "2014-02-06T17:00:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:P/A:N)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T01:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "97bb5145-b73d-4a58-90ec-88ff18d2f78e",
      "cwes": [
        319
      ],
      "description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
      "id": "CVE-2023-23914",
      "published": "2023-02-23T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.1,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-12T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "a424a9f4-035e-4961-9bf5-a4c85cd2dbe5",
      "cwes": [
        319
      ],
      "description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality to behave incorrectly when multiple URLs are requested in parallel. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. This HSTS mechanism would however surprisingly fail when multiple transfers are done in parallel as the HSTS cache file gets overwritten by the most recentlycompleted transfer. A later HTTP-only transfer to the earlier host name would then *not* get upgraded properly to HSTS.",
      "id": "CVE-2023-23915",
      "published": "2023-02-23T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "56dcb4c3-7887-4314-b982-bccea576cb0b",
      "cwes": [
        770
      ],
      "description": "An allocation of resources without limits or throttling vulnerability exists in curl <v7.88.0 based on the \"chained\" HTTP compression algorithms, meaning that a server response can be compressed multiple times and potentially with differentalgorithms. The number of acceptable \"links\" in this \"decompression chain\" wascapped, but the cap was implemented on a per-header basis allowing a maliciousserver to insert a virtually unlimited number of compression steps simply byusing many headers. The use of such a decompression chain could result in a \"malloc bomb\", making curl end up spending enormous amounts of allocated heap memory, or trying to and returning out of memory errors.",
      "id": "CVE-2023-23916",
      "published": "2023-02-23T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-12T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "cc847753-10d2-4688-a765-49334ed10b0e",
      "cwes": [
        74
      ],
      "description": "A vulnerability in input validation exists in curl <8.0 during communication using the TELNET protocol may allow an attacker to pass on maliciously crafted user name and \"telnet options\" during server negotiation. The lack of proper input scrubbing allows an attacker to send content or perform option negotiation without the application's intent. This vulnerability could be exploited if an application allows user input, thereby enabling attackers to execute arbitrary code on the system.",
      "id": "CVE-2023-27533",
      "published": "2023-03-30T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "a2ef7443-2b92-4de6-9a94-ffebb729ecc3",
      "cwes": [
        22
      ],
      "description": "A path traversal vulnerability exists in curl <8.0.0 SFTP implementation causes the tilde (~) character to be wrongly replaced when used as a prefix in the first path element, in addition to its intended use as the first element to indicate a path relative to the user's home directory. Attackers can exploit this flaw to bypass filtering or execute arbitrary code by crafting a path like /~2/foo while accessing a server with a specific user.",
      "id": "CVE-2023-27534",
      "published": "2023-03-30T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "592c1d71-e1f2-4326-b259-98eaecfa840a",
      "cwes": [
        416
      ],
      "description": "A use after free vulnerability exists in curl <v8.1.0 in the way libcurl offers a feature to verify an SSH server's public key using a SHA 256 hash. When this check fails, libcurl would free the memory for the fingerprint before it returns an error message containing the (now freed) hash. This flaw risks inserting sensitive heap-based data into the error message that might be shown to users or otherwise get leaked and revealed.",
      "id": "CVE-2023-28319",
      "published": "2023-05-26T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-15T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "3d16e9d6-0854-4be8-a0b3-ae19507ca80b",
      "cwes": [
        362,
        400
      ],
      "description": "A denial of service vulnerability exists in curl <v8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.",
      "id": "CVE-2023-28320",
      "published": "2023-05-26T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-15T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "ba9f7439-1964-485b-9d7c-c63214cb8e25",
      "cwes": [
        295
      ],
      "description": "An improper certificate validation vulnerability exists in curl <v8.1.0 in the way it supports matching of wildcard patterns when listed as \"Subject Alternative Name\" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.",
      "id": "CVE-2023-28321",
      "published": "2023-05-26T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-15T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "4aa31933-d22c-458d-86ac-a2febc601020",
      "description": "An information disclosure vulnerability exists in curl <v8.1.0 when doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously wasused to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the second transfer. The problem exists in the logic for a reused handle when it is (expected to be) changed from a PUT to a POST.",
      "id": "CVE-2023-28322",
      "published": "2023-05-26T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.7,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "b8c43c4c-b7f2-40cb-adc5-2b6613bea1b2",
      "description": "This flaw allows a malicious HTTP server to set \"super cookies\" in curl that are then passed back to more origins than what is otherwise allowed or possible. This allows a site to set cookies that then would get sent to different and unrelated sites and domains. It could do this by exploiting a mixed case flaw in curl's function that verifies a given cookie domain against the Public Suffix List (PSL). For example a cookie could be set with `domain=co.UK` when the URL used a lower case hostname `curl.co.uk`, even though `co.uk` is listed as a PSL domain.",
      "id": "CVE-2023-46218",
      "published": "2023-12-07T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-30T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "eaa8beff-ed40-4b52-9b64-ba0a506a0fae",
      "cwes": [
        306
      ],
      "description": "An improper authentication vulnerability exists in curl 7.33.0 to and including 7.82.0 which might allow reuse OAUTH2-authenticated connections without properly making sure that the connection was authenticated with the same credentials as set for this transfer. This affects SASL-enabled protocols: SMPTP(S), IMAP(S), POP3(S) and LDAP(S) (openldap only).",
      "id": "CVE-2022-22576",
      "published": "2022-05-26T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:S/C:P/I:P/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 8.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "ee00949f-1d90-4d22-aaf1-0608b317537c",
      "cwes": [
        522
      ],
      "description": "An insufficiently protected credentials vulnerability exists in curl 4.9 to and include curl 7.82.0 are affected that could allow an attacker to extract credentials when follows HTTP(S) redirects is used with authentication could leak credentials to other services that exist on different protocols or port numbers.",
      "id": "CVE-2022-27774",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 3.5,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:S/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "b9094113-bf53-4127-b237-185ac903024d",
      "description": "An information disclosure vulnerability exists in curl 7.65.0 to 7.82.0 are vulnerable that by using an IPv6 address that was in the connection pool but with a different zone id it could reuse a connection instead.",
      "id": "CVE-2022-27775",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "672e3a58-7962-479a-9cd7-579fe450741a",
      "cwes": [
        522
      ],
      "description": "A insufficiently protected credentials vulnerability in fixed in curl 7.83.0 might leak authentication or cookie header data on HTTP redirects to the same host but another port number.",
      "id": "CVE-2022-27776",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "2369b831-7796-4c4f-a8d4-93f6e2d0da94",
      "description": "libcurl wrongly allows cookies to be set for Top Level Domains (TLDs) if thehost name is provided with a trailing dot.curl can be told to receive and send cookies. curl's \"cookie engine\" can bebuilt with or without [Public Suffix List](https://publicsuffix.org/)awareness. If PSL support not provided, a more rudimentary check exists to atleast prevent cookies from being set on TLDs. This check was broken if thehost name in the URL uses a trailing dot.This can allow arbitrary sites to set cookies that then would get sent to adifferent and unrelated site or domain.",
      "id": "CVE-2022-27779",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "717e40cd-649d-4ccc-99ed-e670c90a2e02",
      "cwes": [
        918
      ],
      "description": "The curl URL parser wrongly accepts percent-encoded URL separators like '/'when decoding the host name part of a URL, making it a *different* URL usingthe wrong host name when it is later retrieved.For example, a URL like `http://example.com%2F127.0.0.1/`, would be allowed bythe parser and get transposed into `http://example.com/127.0.0.1/`. This flawcan be used to circumvent filters, checks and more.",
      "id": "CVE-2022-27780",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:P/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "1d007d89-471a-4925-995f-56b8dbfec7da",
      "cwes": [
        835
      ],
      "description": "libcurl provides the `CURLOPT_CERTINFO` option to allow applications torequest details to be returned about a server's certificate chain.Due to an erroneous function, a malicious server could make libcurl built withNSS get stuck in a never-ending busy-loop when trying to retrieve thatinformation.",
      "id": "CVE-2022-27781",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "d1a464ca-6606-497c-a1e5-d2b2343799ce",
      "cwes": [
        295
      ],
      "description": "libcurl would reuse a previously created connection even when a TLS or SSHrelated option had been changed that should have prohibited reuse.libcurl keeps previously used connections in a connection pool for subsequenttransfers to reuse if one of them matches the setup. However, several TLS andSSH settings were left out from the configuration match checks, making themmatch too easily.",
      "id": "CVE-2022-27782",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:P/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "77abbb32-0ea4-4f98-b9be-649d634ce0d5",
      "cwes": [
        319
      ],
      "description": "Using its HSTS support, curl can be instructed to use HTTPS directly insteadof using an insecure clear-text HTTP step even when HTTP is provided in theURL. This mechanism could be bypassed if the host name in the given URL used atrailing dot while not using one when it built the HSTS cache. Or the otherway around - by having the trailing dot in the HSTS cache and *not* using thetrailing dot in the URL.",
      "id": "CVE-2022-30115",
      "published": "2022-06-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:S/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "0ab184bd-28e7-4e05-9fdc-2b14ebc1ea86",
      "cwes": [
        770
      ],
      "description": "A malicious server can serve excessive amounts of `Set-Cookie:` headers in a HTTP response to curl and curl < 7.84.0 stores all of them. A sufficiently large amount of (big) cookies make subsequent HTTP requests to this, or other servers to which the cookies match, create requests that become larger than the threshold that curl uses internally to avoid sending crazy large requests (1048576 bytes) and instead returns an error.This denial state might remain for as long as the same cookies are kept, match and haven't expired. Due to cookie matching rules, a server on `foo.example.com` can set cookies that also would match for `bar.example.com`, making it it possible for a \"sister server\" to effectively cause a denial of service for a sibling site on the same second level domain using this method.",
      "id": "CVE-2022-32205",
      "published": "2022-07-07T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "afd35e05-f234-46be-863c-cacd86f88b9f",
      "cwes": [
        770
      ],
      "description": "curl < 7.84.0 supports \"chained\" HTTP compression algorithms, meaning that a serverresponse can be compressed multiple times and potentially with different algorithms. The number of acceptable \"links\" in this \"decompression chain\" was unbounded, allowing a malicious server to insert a virtually unlimited number of compression steps.The use of such a decompression chain could result in a \"malloc bomb\", makingcurl end up spending enormous amounts of allocated heap memory, or trying toand returning out of memory errors.",
      "id": "CVE-2022-32206",
      "published": "2022-07-07T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "2066e4a3-f786-4596-a766-6ae17ace1b02",
      "cwes": [
        276
      ],
      "description": "When curl < 7.84.0 saves cookies, alt-svc and hsts data to local files, it makes the operation atomic by finalizing the operation with a rename from a temporary name to the final target file name.In that rename operation, it might accidentally *widen* the permissions for the target file, leaving the updated file accessible to more users than intended.",
      "id": "CVE-2022-32207",
      "published": "2022-07-07T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "b66f073e-6b9a-4ad1-8ca5-f06473bfbdae",
      "cwes": [
        787
      ],
      "description": "When curl < 7.84.0 does FTP transfers secured by krb5, it handles message verification failures wrongly. This flaw makes it possible for a Man-In-The-Middle attack to go unnoticed and even allows it to inject data to the client.",
      "id": "CVE-2022-32208",
      "published": "2022-07-07T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "44c1d98d-a575-4e8d-93e8-86594c5b06b6",
      "cwes": [
        668
      ],
      "description": "When doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously was used to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the subsequent `POST` request. The problem exists in the logic for a reused handle when it is changed from a PUT to a POST.",
      "id": "CVE-2022-32221",
      "published": "2022-12-05T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:05:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "6168920b-a226-4c54-80de-fa081705ac80",
      "description": "When curl is used to retrieve and parse cookies from a HTTP(S) server, itaccepts cookies using control codes that when later are sent back to a HTTPserver might make the server return 400 responses. Effectively allowing a\"sister site\" to deny service to all siblings.",
      "id": "CVE-2022-35252",
      "published": "2022-09-23T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.7,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "e066fd42-6312-46b4-b8c3-a75ad3bb3930",
      "cwes": [
        415
      ],
      "description": "curl before 7.86.0 has a double free. If curl is told to use an HTTP proxy for a transfer with a non-HTTP(S) URL, it sets up the connection to the remote server by issuing a CONNECT request to the proxy, and then tunnels the rest of the protocol through. An HTTP proxy might refuse this request (HTTP proxies often only allow outgoing connections to specific port numbers, like 443 for HTTPS) and instead return a non-200 status code to the client. Due to flaws in the error/cleanup handling, this could trigger a double free in curl if one of the following schemes were used in the URL for the transfer: dict, gopher, gophers, ldap, ldaps, rtmp, rtmps, or telnet. The earliest affected version is 7.77.0.",
      "id": "CVE-2022-42915",
      "published": "2022-10-29T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "e8a98d95-1dd6-40a9-9143-93788b41548f",
      "cwes": [
        319
      ],
      "description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
      "id": "CVE-2022-42916",
      "published": "2022-10-29T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "ce584a4c-fa04-4d5f-b945-24e8ccb547ee",
      "cwes": [
        319
      ],
      "description": "A vulnerability exists in curl <7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
      "id": "CVE-2022-43551",
      "published": "2022-12-23T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "8abd1b25-e8f8-4508-a3dc-7b29156d111a",
      "cwes": [
        416
      ],
      "description": "A use after free vulnerability exists in curl <7.87.0. Curl can be asked to *tunnel* virtually all protocols it supports through an HTTP proxy. HTTP proxies can (and often do) deny such tunnel operations. When getting denied to tunnel the specific protocols SMB or TELNET, curl would use a heap-allocated struct after it had been freed, in its transfer shutdown code path.",
      "id": "CVE-2022-43552",
      "published": "2023-02-09T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "060425ce-49a3-471b-a30b-9f1b4c006cb1",
      "cwes": [
        697
      ],
      "description": "When curl is asked to use HSTS, the expiry time for a subdomain might overwrite a parent domain's cache entry, making it end sooner or later than otherwise intended. This affects curl using applications that enable HSTS and use URLs with the insecure `HTTP://` scheme and perform transfers with hosts like `x.example.com` as well as `example.com` where the first host is a subdomain of the second host. (The HSTS cache either needs to have been populated manually or there needs to have been previous HTTPS accesses done as the cache needs to have entries for the domains involved to trigger this problem.) When `x.example.com` responds with `Strict-Transport-Security:` headers, this bug can make the subdomain's expiry timeout *bleed over* and get set for the parent domain `example.com` in curl's HSTS cache. The result of a triggered bug is that HTTP accesses to `example.com` get converted to HTTPS for a different period of time than what was asked for by the origin server. If `example.com` for example stops supporting HTTPS at its expiry time, curl might then fail to access `http://example.com` until the (wrongly set) timeout expires. This bug can also expire the parent's entry *earlier*, thus making curl inadvertently switch back to insecure HTTP earlier than otherwise intended.",
      "id": "CVE-2024-9681",
      "published": "2024-11-06T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-13T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "74fbcb60-ebe5-47a4-8ee2-cebfb72621da",
      "cwes": [
        120
      ],
      "description": "When libcurl is asked to perform automatic gzip decompression of content-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` option, **using zlib 1.2.0.3 or older**, an attacker-controlled integer overflow would make libcurl perform a buffer overflow.",
      "id": "CVE-2025-0725",
      "published": "2025-02-05T10:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-27T19:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "b07eae71-d8da-45ac-9200-d11aeb0221c6",
      "description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
      "id": "CVE-2022-1304",
      "published": "2022-04-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "8455bd69-2795-4e46-b5d4-246ade69dfbc",
      "cwes": [
        125
      ],
      "description": "File before 5.43 has an stack-based buffer over-read in file_copystr in funcs.c. NOTE: \"File\" is the name of an Open Source project.",
      "id": "CVE-2022-48554",
      "published": "2023-08-22T19:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "01294fe0-587e-4edd-af53-4205582d9344",
      "cwes": [
        120
      ],
      "description": "Buffer Overflow vulnerability in function bitwriter_grow_ in flac before 1.4.0 allows remote attackers to run arbitrary code via crafted input to the encoder.",
      "id": "CVE-2020-22219",
      "published": "2023-08-22T19:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "bb87c715-4078-443e-83d4-3796e2a1be35",
      "cwes": [
        787
      ],
      "description": "FreeType commit 1e2eb65048f75c64b68708efed6ce904c31f3b2f was discovered to contain a heap buffer overflow via the function sfnt_init_face.",
      "id": "CVE-2022-27404",
      "published": "2022-04-22T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "6e9894c3-fa15-41b8-b950-064d48c09569",
      "cwes": [
        125
      ],
      "description": "FreeType commit 53dfdcd8198d2b3201a23c4bad9190519ba918db was discovered to contain a segmentation violation via the function FNT_Size_Request.",
      "id": "CVE-2022-27405",
      "published": "2022-04-22T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "b0c208f7-0eac-4c0a-99cd-82efaed193fb",
      "cwes": [
        125
      ],
      "description": "FreeType commit 22a0cccb4d9d002f33c1ba7a4b36812c7d4f46b5 was discovered to contain a segmentation violation via the function FT_Request_Size.",
      "id": "CVE-2022-27406",
      "published": "2022-04-22T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "03927c0d-255f-4a50-98a3-63e427b9b256",
      "description": "An out of bounds write exists in FreeType versions 2.13.0 and below (newer versions of FreeType are not vulnerable) when attempting to parse font subglyph structures related to TrueType GX and variable font files. The vulnerable code assigns a signed short value to an unsigned long and then adds a static value causing it to wrap around and allocate too small of a heap buffer. The code then writes up to 6 signed long integers out of bounds relative to this buffer. This may result in arbitrary code execution. This vulnerability may have been exploited in the wild.",
      "id": "CVE-2025-27363",
      "published": "2025-03-11T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T16:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "1f58db0f-4a7b-4417-b336-e5e3a5750e1e",
      "description": "**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains that target AArch64 allows an attacker to exploit an existing buffer overflow in dynamically-sized local variables in your application without this being detected. This stack-protector failure only applies to C99-style dynamically-sized local variables or those created using alloca(). The stack-protector operates as intended for statically-sized local variables. The default behavior when the stack-protector detects an overflow is to terminate your application, resulting in controlled loss of availability. An attacker who can exploit a buffer overflow without triggering the stack-protector might be able to change program flow control to cause an uncontrolled loss of availability or to go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.",
      "id": "CVE-2023-4039",
      "published": "2023-09-13T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "705c2068-6039-4b55-bd83-66d2e7fb6295",
      "description": "An issue was discovered in GNOME GLib before 2.78.5, and 2.79.x and 2.80.x before 2.80.1. When a GDBus-based client subscribes to signals from a trusted system service such as NetworkManager on a shared computer, other users of the same computer can send spoofed D-Bus signals that the GDBus-based client will wrongly interpret as having been sent by the trusted system service. This could lead to the GDBus-based client behaving incorrectly, with an application-dependent impact.",
      "id": "CVE-2024-34397",
      "published": "2024-05-07T18:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T14:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "fadfdb7f-d260-474e-834c-5a37a35298fb",
      "cwes": [
        400
      ],
      "description": "A flaw was found in GLib. GVariant deserialization fails to validate that the input conforms to the expected format, leading to denial of service.",
      "id": "CVE-2023-29499",
      "published": "2023-09-14T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "935433e7-c166-4510-81e6-71c0ec7ceab5",
      "cwes": [
        400
      ],
      "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to a slowdown issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
      "id": "CVE-2023-32611",
      "published": "2023-09-14T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "f3fd7a44-0848-4033-a1fc-95722ecd46be",
      "cwes": [
        502
      ],
      "description": "A flaw was found in glib, where the gvariant deserialization code is vulnerable to a denial of service introduced by additional input validation added to resolve CVE-2023-29499. The offset table validation may be very slow. This bug does not affect any released version of glib but does affect glib distributors who followed the guidance of glib developers to backport the initial fix for CVE-2023-29499.",
      "id": "CVE-2023-32636",
      "published": "2023-09-14T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "3c28602b-0a73-4aa2-8b4c-30ebc478679c",
      "cwes": [
        787
      ],
      "description": "A flaw was found in GLib. The GVariant deserialization code is vulnerable to a heap buffer overflow introduced by the fix for CVE-2023-32665. This bug does not affect any released version of GLib, but does affect GLib distributors who followed the guidance of GLib developers to backport the initial fix for CVE-2023-32665.",
      "id": "CVE-2023-32643",
      "published": "2023-09-14T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "6c27c800-b898-4367-981e-962370c63363",
      "cwes": [
        502
      ],
      "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
      "id": "CVE-2023-32665",
      "published": "2023-09-14T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "444272fc-b3a2-460a-9396-3d791431f480",
      "description": "gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\\0' character.",
      "id": "CVE-2024-52533",
      "published": "2024-11-11T23:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-17T01:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "96aba967-bccd-40ed-805c-9fa24e2459d4",
      "description": "nscd: Stack-based buffer overflow in netgroup cache If the Name Service Cache Daemon's (nscd) fixed size cache is exhausted by client requests then a subsequent client request for netgroup data may result in a stack-based buffer overflow. This flaw was introduced in glibc 2.15 when the cache was added to nscd. This vulnerability is only present in the nscd binary.",
      "id": "CVE-2024-33599",
      "published": "2024-05-06T20:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T14:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "5e0df1e7-e4b0-433d-b058-c46366ba360b",
      "description": "nscd: Null pointer crashes after notfound response If the Name Service Cache Daemon's (nscd) cache fails to add a not-found netgroup response to the cache, the client request can result in a null pointer dereference. This flaw was introduced in glibc 2.15 when the cache was added to nscd. This vulnerability is only present in the nscd binary.",
      "id": "CVE-2024-33600",
      "published": "2024-05-06T20:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T14:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "6af9b57b-f543-40f2-92dd-439972ee753c",
      "description": "nscd: netgroup cache may terminate daemon on memory allocation failure The Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or xrealloc and these functions may terminate the process due to a memory allocation failure resulting in a denial of service to the clients. The flaw was introduced in glibc 2.15 when the cache was added to nscd. This vulnerability is only present in the nscd binary.",
      "id": "CVE-2024-33601",
      "published": "2024-05-06T20:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T14:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "31f85f7b-bd34-4080-a3aa-7b1e5deed1e7",
      "description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings The Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory when the NSS callback does not store all strings in the provided buffer. The flaw was introduced in glibc 2.15 when the cache was added to nscd. This vulnerability is only present in the nscd binary.",
      "id": "CVE-2024-33602",
      "published": "2024-05-06T20:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T14:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "711d47e3-7fa3-40c4-b0ee-5f093e9f92ba",
      "cwes": [
        120
      ],
      "description": "A vulnerability was found in GNU C Library 2.38. It has been declared as critical. This vulnerability affects the function __monstartup of the file gmon.c of the component Call Graph Monitor. The manipulation leads to buffer overflow. It is recommended to apply a patch to fix this issue. VDB-220246 is the identifier assigned to this vulnerability. NOTE: The real existence of this vulnerability is still doubted at the moment. The inputs that induce this vulnerability are basically addresses of the running application that is built with gmon enabled. It's basically trusted input or input that needs an actual security flaw to be compromised or controlled.",
      "id": "CVE-2023-0687",
      "published": "2023-02-06T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:A/AC:H/Au:S/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "ded0250e-f10d-4a29-a95c-e8344ce000a9",
      "cwes": [
        125
      ],
      "description": "A flaw was found in glibc. When the getaddrinfo function is called with the AF_UNSPEC address family and the system is configured with no-aaaa mode via /etc/resolv.conf, a DNS response via TCP larger than 2048 bytes can potentially disclose stack contents through the function returned address data, and may cause a crash.",
      "id": "CVE-2023-4527",
      "published": "2023-09-18T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-24T17:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "52ee0d5a-196c-4adb-92bf-67e7eb44f205",
      "cwes": [
        416
      ],
      "description": "A flaw was found in glibc. In an uncommon situation, the gaih_inet function may use memory that has been freed, resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.",
      "id": "CVE-2023-4813",
      "published": "2023-09-12T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-30T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "e29b8583-b0b4-4af3-b0cd-ff273312c475",
      "cwes": [
        787
      ],
      "description": "A buffer overflow was discovered in the GNU C Library's dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.",
      "id": "CVE-2023-4911",
      "published": "2023-10-03T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-06T21:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "33927f16-6e8f-480a-8b04-e631f6f46262",
      "cwes": [
        401
      ],
      "description": "A flaw was found in the GNU C Library. A recent fix for CVE-2023-4806 introduced the potential for a memory leak, which may result in an application crash.",
      "id": "CVE-2023-5156",
      "published": "2023-09-25T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "99ba61e0-7142-4259-9fe5-4954544616ea",
      "cwes": [
        399
      ],
      "description": "The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.",
      "id": "CVE-2010-4756",
      "published": "2011-03-02T20:00:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:S/C:N/I:N/A:P)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T01:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "623e7da2-b46b-49ae-bf68-409222e73767",
      "description": "Untrusted LD_LIBRARY_PATH environment variable vulnerability in the GNU C Library version 2.27 to 2.38 allows attacker controlled loading of dynamically shared library in statically compiled setuid binaries that call dlopen (including internal dlopen calls after setlocale or calls to NSS functions such as getaddrinfo).",
      "id": "CVE-2025-4802",
      "published": "2025-05-16T20:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-17T14:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "835e5b2e-1abe-4dd8-ad90-5d39af1ec2b8",
      "cwes": [
        190
      ],
      "description": "GNU Multiple Precision Arithmetic Library (GMP) through 6.2.1 has an mpz/inp_raw.c integer overflow and resultant buffer overflow via crafted input, leading to a segmentation fault on 32-bit platforms.",
      "id": "CVE-2021-43618",
      "published": "2021-11-15T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "6abbe912-501e-4466-b727-8b56a1ddfbfc",
      "cwes": [
        203
      ],
      "description": "A vulnerability was found in GnuTLS. The response times to malformed ciphertexts in RSA-PSK ClientKeyExchange differ from the response times of ciphertexts with correct PKCS#1 v1.5 padding. This issue may allow a remote attacker to perform a timing side-channel attack in the RSA-PSK key exchange, potentially leading to the leakage of sensitive data. CVE-2024-0553 is designated as an incomplete resolution for CVE-2023-5981.",
      "id": "CVE-2024-0553",
      "published": "2024-01-16T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "2d417a45-14f5-40c1-bf2c-85b466c996ec",
      "cwes": [
        347
      ],
      "description": "A vulnerability was found in GnuTLS, where a cockpit (which uses gnuTLS) rejects a certificate chain with distributed trust. This issue occurs when validating a certificate chain with cockpit-certificate-ensure. This flaw allows an unauthenticated, remote client or attacker to initiate a denial of service attack.",
      "id": "CVE-2024-0567",
      "published": "2024-01-16T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "99a6e75e-e801-4a82-b712-b21e145a2a18",
      "cwes": [
        415
      ],
      "description": "A vulnerability found in gnutls. This security flaw happens because of a double free error occurs during verification of pkcs7 signatures in gnutls_pkcs7_verify function.",
      "id": "CVE-2022-2509",
      "published": "2022-08-01T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "09970094-cd0c-49ce-972a-25e0260406a8",
      "cwes": [
        770
      ],
      "description": "hb-ot-layout-gsubgpos.hh in HarfBuzz through 6.0.0 allows attackers to trigger O(n^2) growth via consecutive marks during the process of looking back for base glyphs when attaching marks.",
      "id": "CVE-2023-25193",
      "published": "2023-02-04T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "9d1a7a63-81ef-4fac-a75e-c8e17ed5300a",
      "cwes": [
        119
      ],
      "description": "Hunspell 1.7.0 has an invalid read operation in SuggestMgr::leftcommonsubstring in suggestmgr.cxx.",
      "id": "CVE-2019-16707",
      "published": "2019-09-23T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "5a3addd6-16f2-4a3a-b06a-24aa9030417d",
      "cwes": [
        252
      ],
      "description": "GNU inetutils before 2.5 may allow privilege escalation because of unchecked return values of set*id() family functions in ftpd, rcp, rlogin, rsh, rshd, and uucpd. This is, for example, relevant if the setuid system call fails when a process is trying to drop privileges before letting an ordinary user control the activities of the process.",
      "id": "CVE-2023-40303",
      "published": "2023-08-14T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "2e596b9d-8906-4249-af54-004dc9b668e9",
      "cwes": [
        476
      ],
      "description": "telnetd in GNU Inetutils through 2.3, MIT krb5-appl through 1.0.3, and derivative works has a NULL pointer dereference via 0xff 0xf7 or 0xff 0xf8. In a typical installation, the telnetd application would crash but the telnet service would remain available through inetd. However, if the telnetd application has many crashes within a short time interval, the telnet service would become unavailable after inetd logs a \"telnet/tcp server failing (looping), service terminated\" error. NOTE: MIT krb5-appl is not supported upstream but is shipped by a few Linux distributions. The affected code was removed from the supported MIT Kerberos 5 (aka krb5) product many years ago, at version 1.8.",
      "id": "CVE-2022-39028",
      "published": "2022-08-30T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "2f75ca5a-e79a-4d44-b323-e116b20a223a",
      "cwes": [
        476
      ],
      "description": "iniparser v4.1 is vulnerable to NULL Pointer Dereference in function iniparser_getlongint which misses check NULL for function iniparser_getstring's return.",
      "id": "CVE-2023-33461",
      "published": "2023-06-01T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "7121f52c-c889-49c8-bac6-5bf69f1b6d81",
      "cwes": [
        787
      ],
      "description": "An issue was discovered in json-c from 20200420 (post 0.14 unreleased code) through 0.15-20200726. A stack-buffer-overflow exists in the auxiliary sample program json_parse which is located in the function parseit.",
      "id": "CVE-2021-32292",
      "published": "2023-08-22T19:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T16:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "f355c6ff-f76b-4efa-aafe-2c06f2e31e02",
      "description": "less through 653 allows OS command execution via a newline character in the name of a file, because quoting is mishandled in filename.c. Exploitation typically requires use with attacker-controlled file names, such as the files extracted from an untrusted archive. Exploitation also requires the LESSOPEN environment variable, but this is set by default in many common cases.",
      "id": "CVE-2024-32487",
      "published": "2024-04-13T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-17T20:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "6d7f0ddd-98f2-4b20-8931-fd66bd829653",
      "description": "In GNU Less before 609, crafted data can result in \"less -R\" not filtering ANSI escape sequences sent to the terminal.",
      "id": "CVE-2022-46663",
      "published": "2023-02-07T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "7fefbc90-7005-473a-9058-c719fdee0642",
      "description": "close_altfile in filename.c in less before 606 omits shell_quote calls for LESSCLOSE.",
      "id": "CVE-2022-48624",
      "published": "2024-02-19T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-27T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "5105d317-bcd9-4497-bf9b-982a66bb76cc",
      "cwes": [
        787
      ],
      "description": "Libarchive Remote Code Execution Vulnerability",
      "id": "CVE-2024-26256",
      "published": "2024-04-09T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-08T16:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "c79eb2d9-9710-4237-91ca-acd9b3651e1f",
      "cwes": [
        362
      ],
      "description": "Libarchive through 3.6.2 can cause directories to have world-writable permissions. The umask() call inside archive_write_disk_posix.c changes the umask of the whole process for a very short period of time; a race condition with another thread can lead to a permanent umask 0 setting. Such a race condition could lead to implicit directory creation with permissions 0777 (without the sticky bit), which means that any low-privileged local user can delete and rename files inside those directories.",
      "id": "CVE-2023-30571",
      "published": "2023-05-29T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-14T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "d23c05f7-5faa-42b3-8fae-fc47a2a3433c",
      "cwes": [
        125
      ],
      "description": "Libarchive before 3.7.4 allows name out-of-bounds access when a ZIP archive has an empty-name file and mac-ext is enabled. This occurs in slurp_central_directory in archive_read_support_format_zip.c.",
      "id": "CVE-2024-37407",
      "published": "2024-06-08T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.1,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-29T16:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "a837497b-fd65-46bc-80e8-04e2f5b558c4",
      "cwes": [
        125
      ],
      "description": "execute_filter_audio in archive_read_support_format_rar.c in libarchive before 3.7.5 allows out-of-bounds access via a crafted archive file because src can move beyond dst.",
      "id": "CVE-2024-48957",
      "published": "2024-10-10T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-02T14:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "0ce1eb81-5c0d-4c6d-bfc2-bc4458a85759",
      "cwes": [
        125
      ],
      "description": "execute_filter_delta in archive_read_support_format_rar.c in libarchive before 3.7.5 allows out-of-bounds access via a crafted archive file because src can move beyond dst.",
      "id": "CVE-2024-48958",
      "published": "2024-10-10T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-02T14:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "34202be8-7598-43db-80d3-e6019ba7f50d",
      "cwes": [
        476
      ],
      "description": "A vulnerability was found in libarchive up to 3.7.7. It has been classified as problematic. This affects the function list of the file bsdunzip.c. The manipulation leads to null pointer dereference. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
      "id": "CVE-2025-1632",
      "published": "2025-02-24T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T15:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "e1b0365c-4410-4597-85bd-7a8fcc6d49a0",
      "description": "Null Pointer Dereference vulnerability in libarchive 3.7.6 and earlier when running program bsdtar in function header_pax_extension at rchive_read_support_format_tar.c:1844:8.",
      "id": "CVE-2024-48615",
      "published": "2025-03-28T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T14:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: We are not using rar vulnerability is in libarchive",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "7c969743-e163-46d9-b484-95eef54f58f4",
      "description": "A vulnerability has been identified in the libarchive library, specifically within the archive_read_format_rar_seek_data() function. This flaw involves an integer overflow that can ultimately lead to a double-free condition. Exploiting a double-free vulnerability can result in memory corruption, enabling an attacker to execute arbitrary code or cause a denial-of-service condition.",
      "id": "CVE-2025-5914",
      "published": "2025-06-09T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-20T14:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "7561a4ff-ff76-49d1-b573-73129e27eaab",
      "cwes": [
        401
      ],
      "description": "A vulnerability was found in the pthread_create() function in libcap. This issue may allow a malicious actor to use cause __real_pthread_create() to return an error, which can exhaust the process memory.",
      "id": "CVE-2023-2602",
      "published": "2023-06-06T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "2fcbd1ff-19f6-4b07-ab08-4fcd84aa6f0d",
      "cwes": [
        190
      ],
      "description": "A vulnerability was found in libcap. This issue occurs in the _libcap_strdup() function and can lead to an integer overflow if the input string is close to 4GiB.",
      "id": "CVE-2023-2603",
      "published": "2023-06-06T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-24T17:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "82c2fed1-995e-4606-9572-93dc3e6b9a6a",
      "cwes": [
        287
      ],
      "description": "An authentication bypass vulnerability exists in libcurl <8.0.0 in the FTP connection reuse feature that can result in wrong credentials being used during subsequent transfers. Previously created connections are kept in a connection pool for reuse if they match the current setup. However, certain FTP settings such as CURLOPT_FTP_ACCOUNT, CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPT_FTP_SSL_CCC, and CURLOPT_USE_SSL were not included in the configuration match checks, causing them to match too easily. This could lead to libcurl using the wrong credentials when performing a transfer, potentially allowing unauthorized access to sensitive information.",
      "id": "CVE-2023-27535",
      "published": "2023-03-30T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-09T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "942c95ca-b267-44c7-82f1-2dff1d0d725f",
      "cwes": [
        287
      ],
      "description": "An authentication bypass vulnerability exists libcurl <8.0.0 in the connection reuse feature which can reuse previously established connections with incorrect user permissions due to a failure to check for changes in the CURLOPT_GSSAPI_DELEGATION option. This vulnerability affects krb5/kerberos/negotiate/GSSAPI transfers and could potentially result in unauthorized access to sensitive information. The safest option is to not reuse connections if the CURLOPT_GSSAPI_DELEGATION option has been changed.",
      "id": "CVE-2023-27536",
      "published": "2023-03-30T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "d63a9faf-2623-4bb5-a52a-af6dddc65547",
      "cwes": [
        287
      ],
      "description": "An authentication bypass vulnerability exists in libcurl prior to v8.0.0 where it reuses a previously established SSH connection despite the fact that an SSH option was modified, which should have prevented reuse. libcurl maintains a pool of previously used connections to reuse them for subsequent transfers if the configurations match. However, two SSH settings were omitted from the configuration check, allowing them to match easily, potentially leading to the reuse of an inappropriate connection.",
      "id": "CVE-2023-27538",
      "published": "2023-03-30T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-09T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "03f7e790-b313-49b9-9f18-6ed2165ff8ed",
      "cwes": [
        787
      ],
      "description": "This flaw makes curl overflow a heap based buffer in the SOCKS5 proxy handshake. When curl is asked to pass along the host name to the SOCKS5 proxy to allow that to resolve the address instead of it getting done by curl itself, the maximum length that host name can be is 255 bytes. If the host name is detected to be longer, curl switches to local name resolving and instead passes on the resolved address only. Due to this bug, the local variable that means \"let the host resolve the name\" could get the wrong value during a slow SOCKS5 handshake, and contrary to the intention, copy the too long host name to the target buffer instead of copying just the resolved address there. The target buffer being a heap based buffer, and the host name coming from the URL that curl has been told to operate with.",
      "id": "CVE-2023-38545",
      "published": "2023-10-18T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "a0139add-e4fb-4461-a740-806c4b8555d4",
      "description": "This flaw allows an attacker to insert cookies at will into a running program using libcurl, if the specific series of conditions are met. libcurl performs transfers. In its API, an application creates \"easy handles\" that are the individual handles for single transfers. libcurl provides a function call that duplicates en easy handle called [curl_easy_duphandle](https://curl.se/libcurl/c/curl_easy_duphandle.html). If a transfer has cookies enabled when the handle is duplicated, the cookie-enable state is also cloned - but without cloning the actual cookies. If the source handle did not read any cookies from a specific file on disk, the cloned version of the handle would instead store the file name as `none` (using the four ASCII letters, no quotes). Subsequent use of the cloned handle that does not explicitly set a source to load cookies from would then inadvertently load cookies from a file named `none` - if such a file exists and is readable in the current directory of the program using libcurl. And if using the correct file format of course.",
      "id": "CVE-2023-38546",
      "published": "2023-10-18T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.7,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "7352077f-02e0-4458-9705-cc0766b01a79",
      "cwes": [
        125
      ],
      "description": "libcurl's ASN1 parser code has the `GTime2str()` function, used for parsing an ASN.1 Generalized Time field. If given an syntactically incorrect field, the parser might end up using -1 for the length of the *time fraction*, leading to a `strlen()` getting performed on a pointer to a heap buffer area that is not (purposely) null terminated. This flaw most likely leads to a crash, but can also lead to heap contents getting returned to the application when [CURLINFO_CERTINFO](https://curl.se/libcurl/c/CURLINFO_CERTINFO.html) is used.",
      "id": "CVE-2024-7264",
      "published": "2024-07-31T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "405b3d13-ba70-4d7c-ae09-22341fb6b459",
      "cwes": [
        776
      ],
      "description": "libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).",
      "id": "CVE-2024-28757",
      "published": "2024-03-10T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-28T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "fa709302-702c-4c80-b432-a4a1d06876d3",
      "cwes": [
        400
      ],
      "description": "libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.",
      "id": "CVE-2023-52425",
      "published": "2024-02-04T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "cb78b906-7a06-44e8-b47d-7584bd6e1c1a",
      "cwes": [
        776
      ],
      "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
      "id": "CVE-2023-52426",
      "published": "2024-02-04T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-17T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "8a5c4d57-1e1f-4500-845b-fd5cd2e6de34",
      "cwes": [
        190
      ],
      "description": "An issue was discovered in libexpat before 2.6.3. nextScaffoldPart in xmlparse.c can have an integer overflow for m_groupSize on 32-bit platforms (where UINT_MAX equals SIZE_MAX).",
      "id": "CVE-2024-45492",
      "published": "2024-08-30T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "9e339303-e0fe-4b26-862f-fe90854e09d7",
      "cwes": [
        190
      ],
      "description": "An issue was discovered in libexpat before 2.6.3. dtdCopy in xmlparse.c can have an integer overflow for nDefaultAtts on 32-bit platforms (where UINT_MAX equals SIZE_MAX).",
      "id": "CVE-2024-45491",
      "published": "2024-08-30T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:02Z"
      },
      "bom-ref": "fcbc8e3b-34ef-49b7-b623-afbccb68e2d6",
      "cwes": [
        611
      ],
      "description": "An issue was discovered in libexpat before 2.6.3. xmlparse.c does not reject a negative length for XML_ParseBuffer.",
      "id": "CVE-2024-45490",
      "published": "2024-08-30T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-14T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:05Z"
      },
      "bom-ref": "3d92f65d-dfe7-4c30-8dd4-909a4341e05e",
      "cwes": [
        617
      ],
      "description": "libsndfile through 1.2.2 has a reachable assertion, that may lead to application exit, in mpeg_l3_encode.c mpeg_l3_encoder_close.",
      "id": "CVE-2024-50613",
      "published": "2024-10-27T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-31T00:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "5d306954-caed-46bb-9e68-dcdeacf50536",
      "cwes": [
        125
      ],
      "description": "libsndfile through 1.2.2 has an ogg_vorbis.c vorbis_analysis_wrote out-of-bounds read.",
      "id": "CVE-2024-50612",
      "published": "2024-10-27T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-05T16:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "6a9967ff-580e-4814-9216-c9a77a9edb90",
      "cwes": [
        354
      ],
      "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
      "id": "CVE-2023-48795",
      "published": "2023-12-18T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-23T02:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "2b510b6c-44e0-41a4-9c87-c84adbb30828",
      "cwes": [
        74
      ],
      "description": "A flaw was found in libssh. By utilizing the ProxyCommand or ProxyJump feature, users can exploit unchecked hostname syntax on the client. This issue may allow an attacker to inject malicious code into the command of the features mentioned through the hostname parameter.",
      "id": "CVE-2023-6004",
      "published": "2024-01-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "8fda9ce4-b7c4-42b1-ba46-e20eea696f98",
      "cwes": [
        755,
        835
      ],
      "description": "In libtirpc before 1.3.3rc1, remote attackers could exhaust the file descriptors of a process that uses libtirpc because idle TCP connections are mishandled. This can, in turn, lead to an svc_run infinite loop without accepting new connections.",
      "id": "CVE-2021-46828",
      "published": "2022-07-20T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "17b55fec-f23d-4513-bdd2-a09da29960d8",
      "description": "libuv is a multi-platform support library with a focus on asynchronous I/O. The `uv_getaddrinfo` function in `src/unix/getaddrinfo.c` (and its windows counterpart `src/win/getaddrinfo.c`), truncates hostnames to 256 characters before calling `getaddrinfo`. This behavior can be exploited to create addresses like `0x00007f000001`, which are considered valid by `getaddrinfo` and could allow an attacker to craft payloads that resolve to unintended IP addresses, bypassing developer checks. The vulnerability arises due to how the `hostname_ascii` variable (with a length of 256 bytes) is handled in `uv_getaddrinfo` and subsequently in `uv__idna_toascii`. When the hostname exceeds 256 characters, it gets truncated without a terminating null byte. As a result attackers may be able to access internal APIs or for websites (similar to MySpace) that allows users to have `username.example.com` pages. Internal services that crawl or cache these user pages can be exposed to SSRF attacks if a malicious user chooses a long vulnerable username. This issue has been addressed in release version 1.48.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
      "id": "CVE-2024-24806",
      "published": "2024-02-07T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "02dcc682-9ec9-445e-a3cf-6774cc970437",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in libxml2 before 2.11.7 and 2.12.x before 2.12.5. When using the XML Reader interface with DTD validation and XInclude expansion enabled, processing crafted XML documents can lead to an xmlValidatePopElement use-after-free.",
      "id": "CVE-2024-25062",
      "published": "2024-02-04T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-09T18:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "046082c1-715c-4793-a0c9-7880a74c9934",
      "cwes": [
        476
      ],
      "description": "In libxml2 before 2.10.4, parsing of certain invalid XSD schemas can lead to a NULL pointer dereference and subsequently a segfault. This occurs in xmlSchemaFixupComplexType in xmlschemas.c.",
      "id": "CVE-2023-28484",
      "published": "2023-04-24T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-30T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "06117786-47fb-4252-b975-bc68e3da8f51",
      "cwes": [
        415
      ],
      "description": "An issue was discovered in libxml2 before 2.10.4. When hashing empty dict strings in a crafted XML document, xmlDictComputeFastKey in dict.c can produce non-deterministic values, leading to various logic and memory errors, such as a double free. This behavior occurs because there is an attempt to use the first byte of an empty string, and any value is possible (not solely the '\\0' value).",
      "id": "CVE-2023-29469",
      "published": "2023-04-24T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-04T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "0ceca1fc-303a-4861-858d-6b6a475aa1dc",
      "cwes": [
        416
      ],
      "description": "libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor's position is \"I don't think these issues are critical enough to warrant a CVE ID ... because an attacker typically can't control when memory allocations fail.\"",
      "id": "CVE-2023-45322",
      "published": "2023-10-06T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "3a2d85e5-0337-4de7-97cd-09c8c6d62c04",
      "cwes": [
        190
      ],
      "description": "An issue was discovered in libxml2 before 2.10.3. When parsing a multi-gigabyte XML document with the XML_PARSE_HUGE parser option enabled, several integer counters can overflow. This results in an attempt to access an array at a negative 2GB offset, typically leading to a segmentation fault.",
      "id": "CVE-2022-40303",
      "published": "2022-11-23T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-29T05:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "e3da2774-bd3b-42dc-aa5d-2aa313b5ff61",
      "cwes": [
        415
      ],
      "description": "An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.",
      "id": "CVE-2022-40304",
      "published": "2022-11-23T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-28T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "8add30e3-60cd-4c25-84a4-a012deb4b5bb",
      "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a NULL pointer dereference in xmlPatMatch in pattern.c.",
      "id": "CVE-2025-27113",
      "published": "2025-02-18T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T01:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "12619032-9133-432f-b2a6-d97fe64e8d46",
      "cwes": [
        252
      ],
      "description": "In libxml2 before 2.13.8 and 2.14.x before 2.14.2, out-of-bounds memory access can occur in the Python API (Python bindings) because of an incorrect return value. This occurs in xmlPythonFileRead and xmlPythonFileReadRaw because of a difference between bytes and characters.",
      "id": "CVE-2025-32414",
      "published": "2025-04-08T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T19:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "7cdb609b-49f0-44cb-9e95-cfed36b3fd19",
      "cwes": [
        125
      ],
      "description": "In libxml2 before 2.13.8 and 2.14.x before 2.14.2, xmlSchemaIDCFillNodeTables in xmlschemas.c has a heap-based buffer under-read. To exploit this, a crafted XML document must be validated against an XML schema with certain identity constraints, or a crafted XML schema must be used.",
      "id": "CVE-2025-32415",
      "published": "2025-04-17T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T18:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "afcb81ac-aa66-4677-9b46-572a2717e5ae",
      "description": "A vulnerability was found in vhost_new_msg in drivers/vhost/vhost.c in the Linux kernel, which does not properly initialize memory in messages passed between virtual guests and the host operating system in the vhost/vhost.c:vhost_new_msg() function. This issue can allow local privileged users to read some kernel memory contents when reading from the /dev/vhost-net device file.",
      "id": "CVE-2024-0340",
      "published": "2024-01-09T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-14T04:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "eca0996a-0ada-47f0-ba0b-f43efb548312",
      "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The issue is in the nft_byteorder_eval() function, where the code iterates through a loop and writes to the `dst` array. On each iteration, 8 bytes are written, but `dst` is an array of u32, so each element only has space for 4 bytes. That means every iteration overwrites part of the previous element corrupting this array of u32. This flaw allows a local user to cause a denial of service or potentially break NetFilter functionality.",
      "id": "CVE-2024-0607",
      "published": "2024-01-18T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "48a86b2b-5b70-40dc-be41-ba6c17e086e4",
      "cwes": [
        667
      ],
      "description": "A denial of service vulnerability due to a deadlock was found in sctp_auto_asconf_init in net/sctp/socket.c in the Linux kernel\u2019s SCTP subsystem. This flaw allows guests with local user privileges to trigger a deadlock and potentially crash the system.",
      "id": "CVE-2024-0639",
      "published": "2024-01-17T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "36a5311a-beb5-474c-921d-10bb17aa6ef8",
      "cwes": [
        667
      ],
      "description": "A denial of service vulnerability was found in tipc_crypto_key_revoke in net/tipc/crypto.c in the Linux kernel\u2019s TIPC subsystem. This flaw allows guests with local user privileges to trigger a deadlock and potentially crash the system.",
      "id": "CVE-2024-0641",
      "published": "2024-01-17T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "00b69a1e-448f-499d-8064-4a8a64957073",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in the __ext4_remount in fs/ext4/super.c in ext4 in the Linux kernel. This flaw allows a local user to cause an information leak problem while freeing the old quota file names before a potential failure, leading to a use-after-free.",
      "id": "CVE-2024-0775",
      "published": "2024-01-22T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:04Z"
      },
      "bom-ref": "88b77819-8303-4039-b89f-ee405ec84253",
      "cwes": [
        787
      ],
      "description": "A vulnerability was reported in the Open vSwitch sub-component in the Linux Kernel. The flaw occurs when a recursive operation of code push recursively calls into the code block. The OVS module does not validate the stack depth, pushing too many frames and causing a stack overflow. As a result, this can lead to a crash or other related issues.",
      "id": "CVE-2024-1151",
      "published": "2024-02-11T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_ARCH_HAS_RELR, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_HUGETLBFS, CONFIG_TRANSPARENT_HUGEPAGE, CONFIG_BPF, CONFIG_DEBUG_FS, CONFIG_PREEMPTION, CONFIG_MODVERSIONS, CONFIG_CROSS_MEMORY_ATTACH, CONFIG_FRAME_WARN, CONFIG_FRAME_POINTER, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_MODULES, CONFIG_ARC, CONFIG_ARCH_HAS_PTE_SPECIAL, CONFIG_OF_EARLY_FLATTREE, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_NUMA, CONFIG_LTO, CONFIG_MM, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:47:46Z"
      },
      "bom-ref": "bb28c232-30a9-4a6c-a5b3-75601e748186",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in the Linux kernel's Memory Management subsystem when a user wins two races at the same time with a fail in the mas_prev_slot function. This issue could allow a local user to crash the system.",
      "id": "CVE-2024-1312",
      "published": "2024-02-08T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "state": "not_affected"
      },
      "bom-ref": "160ad8c4-e436-4147-b77e-0d0a82449889",
      "cwes": [
        416
      ],
      "description": "Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C. This issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.",
      "id": "CVE-2024-21803",
      "published": "2024-01-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:05Z"
      },
      "bom-ref": "552a353d-ef92-484d-8045-5987a5a0c73f",
      "cwes": [
        125
      ],
      "description": "An issue was discovered in ksmbd in the Linux kernel before 6.6.10. smb2_get_data_area_len in fs/smb/server/smb2misc.c can cause an smb_strndup_from_utf16 out-of-bounds access because the relationship between Name data and CreateContexts data is mishandled.",
      "id": "CVE-2024-22705",
      "published": "2024-01-23T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-05T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "1db16a45-0549-4388-91f0-9d83fc0a5efe",
      "cwes": [
        190
      ],
      "description": "Integer Overflow or Wraparound vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (md, raid, raid5 modules) allows Forced Integer Overflow.",
      "id": "CVE-2024-23307",
      "published": "2024-01-25T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-22T18:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "HDMI not avaiable",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "0b216713-df0e-43e0-a049-24ea5199f3f5",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel through 6.7.1, there is a use-after-free in cec_queue_msg_fh, related to drivers/media/cec/core/cec-adap.c and drivers/media/cec/core/cec-api.c.",
      "id": "CVE-2024-23848",
      "published": "2024-01-23T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-30T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:05Z"
      },
      "bom-ref": "f39eb7e8-8029-4e04-8c70-8ab2c00066ea",
      "cwes": [
        193
      ],
      "description": "In rds_recv_track_latency in net/rds/af_rds.c in the Linux kernel through 6.7.1, there is an off-by-one error for an RDS_MSG_RX_DGRAM_TRACE_MAX comparison, resulting in out-of-bounds access.",
      "id": "CVE-2024-23849",
      "published": "2024-01-23T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-30T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:05Z"
      },
      "bom-ref": "b81d4f6f-810c-438b-a112-831c385f9dcd",
      "description": "In btrfs_get_root_ref in fs/btrfs/disk-io.c in the Linux kernel through 6.7.1, there can be an assertion failure and crash because a subvolume can be read out too soon after its root item is inserted upon subvolume creation.",
      "id": "CVE-2024-23850",
      "published": "2024-01-23T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:05Z"
      },
      "bom-ref": "ea7360fe-8a22-417b-b3f4-f36c9e87f648",
      "description": "copy_params in drivers/md/dm-ioctl.c in the Linux kernel through 6.7.1 can attempt to allocate more than INT_MAX bytes, and crash, because of a missing param_kernel->data_size check. This is related to ctl_ioctl.",
      "id": "CVE-2024-23851",
      "published": "2024-01-23T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_PCI, CONFIG_MQ_IOSCHED_DEADLINE, CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_USB_DWC2_DUAL_ROLE, CONFIG_BLK_DEV_MD, CONFIG_ARCH_HAS_RELR, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_SYNC, CONFIG_NET_DSA, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_ARM, CONFIG_TRACING, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_BPF, CONFIG_IOMMU_SUPPORT, CONFIG_USB_DWC3_DUAL_ROLE, CONFIG_USB, CONFIG_SYNC_FILE, CONFIG_PHYLIB, CONFIG_SMP, CONFIG_MODVERSIONS, CONFIG_FRAME_WARN, CONFIG_SYSFS, CONFIG_DM_VERITY_FEC, CONFIG_OF, CONFIG_NET_PTP_CLASSIFY, CONFIG_PCI_QUIRKS, CONFIG_POWER_SUPPLY, CONFIG_FRAME_POINTER, CONFIG_MDIO_DEVICE, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_HAS_IOMEM, CONFIG_MODULES, CONFIG_UBI, CONFIG_ARC, CONFIG_BPF_SYSCALL, CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG, CONFIG_OF_FLATTREE, CONFIG_OF_EARLY_FLATTREE, CONFIG_DRM, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_MTD, CONFIG_DMA_SHARED_BUFFER, CONFIG_KEXEC_FILE, CONFIG_COMMON_CLK, CONFIG_ARM64, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_LTO, CONFIG_HWMON, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_EFI_CAPSULE_LOADER, CONFIG_CPU_LITTLE_ENDIAN, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:48:23Z"
      },
      "bom-ref": "d494b533-2643-4c24-9ca4-5307b9b01c71",
      "cwes": [
        754
      ],
      "description": "create_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi->leb_size.",
      "id": "CVE-2024-25739",
      "published": "2024-02-12T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-14T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:47Z"
      },
      "bom-ref": "5962f0e9-e05d-4869-b378-a0690953b5e0",
      "cwes": [
        401
      ],
      "description": "A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT, because kobj->name is not released.",
      "id": "CVE-2024-25740",
      "published": "2024-02-12T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T21:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:48Z"
      },
      "bom-ref": "d7e6f8a7-ebed-4e9d-92b4-27e8f88822d6",
      "description": "printer_write in drivers/usb/gadget/function/f_printer.c in the Linux kernel through 6.7.4 does not properly call usb_ep_queue, which might allow attackers to cause a denial of service or have unspecified other impact.",
      "id": "CVE-2024-25741",
      "published": "2024-02-12T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as device uses ARM platform and issue affects x86",
        "justification": "requires_environment",
        "state": "not_affected"
      },
      "bom-ref": "995383e6-608c-4e69-82bf-263302d50195",
      "description": "In the Linux kernel before 6.6.7, an untrusted VMM can trigger int80 syscall handling at any given point. This is related to arch/x86/coco/tdx/tdx.c and arch/x86/mm/mem_encrypt_amd.c.",
      "id": "CVE-2024-25744",
      "published": "2024-02-12T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T22:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_TLS is not set in kernel configuration",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c52e20e0-268f-41f1-b2c8-552691f47967",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: tls: fix race between async notify and socket close The submitting thread (one which called recvmsg/sendmsg) may exit as soon as the async crypto handler calls complete() so any code past that point risks touching already freed data. Try to avoid the locking and extra flags altogether. Have the main thread hold an extra reference, this way we can depend solely on the atomic ref counter for synchronization. Don't futz with reiniting the completion, either, we are now tightly controlling when completion fires.",
      "id": "CVE-2024-26583",
      "published": "2024-02-21T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_TLS is not set in kernel configuration",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "277ca69a-fac0-4627-a7f2-651cc2ba0552",
      "cwes": [
        755
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: tls: handle backlogging of crypto requests Since we're setting the CRYPTO_TFM_REQ_MAY_BACKLOG flag on our requests to the crypto API, crypto_aead_{encrypt,decrypt} can return -EBUSY instead of -EINPROGRESS in valid situations. For example, when the cryptd queue for AESNI is full (easy to trigger with an artificially low cryptd.cryptd_max_cpu_qlen), requests will be enqueued to the backlog but still processed. In that case, the async callback will also be called twice: first with err == -EINPROGRESS, which it seems we can just ignore, then with err == 0. Compared to Sabrina's original patch this version uses the new tls_*crypt_async_wait() helpers and converts the EBUSY to EINPROGRESS to avoid having to modify all the error handling paths. The handling is identical.",
      "id": "CVE-2024-26584",
      "published": "2024-02-21T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_TLS is not set in kernel configuration",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "092ac470-9f47-4da9-969f-d968940d24a1",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: tls: fix race between tx work scheduling and socket close Similarly to previous commit, the submitting thread (recvmsg/sendmsg) may exit as soon as the async crypto handler calls complete(). Reorder scheduling the work before calling complete(). This seems more logical in the first place, as it's the inverse order of what the submitting thread will do.",
      "id": "CVE-2024-26585",
      "published": "2024-02-21T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:47:48Z"
      },
      "bom-ref": "e5cafc95-f894-47d9-b069-51698174b6ee",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: netdevsim: don't try to destroy PHC on VFs PHC gets initialized in nsim_init_netdevsim(), which is only called if (nsim_dev_port_is_pf()). Create a counterpart of nsim_init_netdevsim() and move the mock_phc_destroy() there. This fixes a crash trying to destroy netdevsim with VFs instantiated, as caught by running the devlink.sh test: BUG: kernel NULL pointer dereference, address: 00000000000000b8 RIP: 0010:mock_phc_destroy+0xd/0x30 Call Trace: <TASK> nsim_destroy+0x4a/0x70 [netdevsim] __nsim_dev_port_del+0x47/0x70 [netdevsim] nsim_dev_reload_destroy+0x105/0x120 [netdevsim] nsim_drv_remove+0x2f/0xb0 [netdevsim] device_release_driver_internal+0x1a1/0x210 bus_remove_device+0xd5/0x120 device_del+0x159/0x490 device_unregister+0x12/0x30 del_device_store+0x11a/0x1a0 [netdevsim] kernfs_fop_write_iter+0x130/0x1d0 vfs_write+0x30b/0x4b0 ksys_write+0x69/0xf0 do_syscall_64+0xcc/0x1e0 entry_SYSCALL_64_after_hwframe+0x6f/0x77",
      "id": "CVE-2024-26587",
      "published": "2024-02-22T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_MLXSW_CORE is not set in kernel configuration",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "43a35e0e-f2cd-42eb-a05e-996b8fc2625d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error path When calling mlxsw_sp_acl_tcam_region_destroy() from an error path after failing to attach the region to an ACL group, we hit a NULL pointer dereference upon 'region->group->tcam' [1]. Fix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam(). [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 [...] RIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0 [...] Call Trace: mlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20 mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0 mlxsw_sp_acl_rule_add+0x47/0x240 mlxsw_sp_flower_replace+0x1a9/0x1d0 tc_setup_cb_add+0xdc/0x1c0 fl_hw_replace_filter+0x146/0x1f0 fl_change+0xc17/0x1360 tc_new_tfilter+0x472/0xb90 rtnetlink_rcv_msg+0x313/0x3b0 netlink_rcv_skb+0x58/0x100 netlink_unicast+0x244/0x390 netlink_sendmsg+0x1e4/0x440 ____sys_sendmsg+0x164/0x260 ___sys_sendmsg+0x9a/0xe0 __sys_sendmsg+0x7a/0xc0 do_syscall_64+0x40/0xe0 entry_SYSCALL_64_after_hwframe+0x63/0x6b",
      "id": "CVE-2024-26595",
      "published": "2024-02-23T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:50Z"
      },
      "bom-ref": "266af97b-86cd-41d9-b62c-cdf00f099373",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/bridge: sii902x: Fix probing race issue A null pointer dereference crash has been observed rarely on TI platforms using sii9022 bridge: [ 53.271356] sii902x_get_edid+0x34/0x70 [sii902x] [ 53.276066] sii902x_bridge_get_edid+0x14/0x20 [sii902x] [ 53.281381] drm_bridge_get_edid+0x20/0x34 [drm] [ 53.286305] drm_bridge_connector_get_modes+0x8c/0xcc [drm_kms_helper] [ 53.292955] drm_helper_probe_single_connector_modes+0x190/0x538 [drm_kms_helper] [ 53.300510] drm_client_modeset_probe+0x1f0/0xbd4 [drm] [ 53.305958] __drm_fb_helper_initial_config_and_unlock+0x50/0x510 [drm_kms_helper] [ 53.313611] drm_fb_helper_initial_config+0x48/0x58 [drm_kms_helper] [ 53.320039] drm_fbdev_dma_client_hotplug+0x84/0xd4 [drm_dma_helper] [ 53.326401] drm_client_register+0x5c/0xa0 [drm] [ 53.331216] drm_fbdev_dma_setup+0xc8/0x13c [drm_dma_helper] [ 53.336881] tidss_probe+0x128/0x264 [tidss] [ 53.341174] platform_probe+0x68/0xc4 [ 53.344841] really_probe+0x188/0x3c4 [ 53.348501] __driver_probe_device+0x7c/0x16c [ 53.352854] driver_probe_device+0x3c/0x10c [ 53.357033] __device_attach_driver+0xbc/0x158 [ 53.361472] bus_for_each_drv+0x88/0xe8 [ 53.365303] __device_attach+0xa0/0x1b4 [ 53.369135] device_initial_probe+0x14/0x20 [ 53.373314] bus_probe_device+0xb0/0xb4 [ 53.377145] deferred_probe_work_func+0xcc/0x124 [ 53.381757] process_one_work+0x1f0/0x518 [ 53.385770] worker_thread+0x1e8/0x3dc [ 53.389519] kthread+0x11c/0x120 [ 53.392750] ret_from_fork+0x10/0x20 The issue here is as follows: - tidss probes, but is deferred as sii902x is still missing. - sii902x starts probing and enters sii902x_init(). - sii902x calls drm_bridge_add(). Now the sii902x bridge is ready from DRM's perspective. - sii902x calls sii902x_audio_codec_init() and platform_device_register_data() - The registration of the audio platform device causes probing of the deferred devices. - tidss probes, which eventually causes sii902x_bridge_get_edid() to be called. - sii902x_bridge_get_edid() tries to use the i2c to read the edid. However, the sii902x driver has not set up the i2c part yet, leading to the crash. Fix this by moving the drm_bridge_add() to the end of the sii902x_init(), which is also at the very end of sii902x_probe().",
      "id": "CVE-2024-26607",
      "published": "2024-02-29T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T15:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:51Z"
      },
      "bom-ref": "5234e751-719d-4055-8369-5a4661dbcc6c",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: thermal: intel: hfi: Add syscore callbacks for system-wide PM The kernel allocates a memory buffer and provides its location to the hardware, which uses it to update the HFI table. This allocation occurs during boot and remains constant throughout runtime. When resuming from hibernation, the restore kernel allocates a second memory buffer and reprograms the HFI hardware with the new location as part of a normal boot. The location of the second memory buffer may differ from the one allocated by the image kernel. When the restore kernel transfers control to the image kernel, its HFI buffer becomes invalid, potentially leading to memory corruption if the hardware writes to it (the hardware continues to use the buffer from the restore kernel). It is also possible that the hardware \"forgets\" the address of the memory buffer when resuming from \"deep\" suspend. Memory corruption may also occur in such a scenario. To prevent the described memory corruption, disable HFI when preparing to suspend or hibernate. Enable it when resuming. Add syscore callbacks to handle the package of the boot CPU (packages of non-boot CPUs are handled via CPU offline). Syscore ops always run on the boot CPU. Additionally, HFI only needs to be disabled during \"deep\" suspend and hibernation. Syscore ops only run in these cases. [ rjw: Comment adjustment, subject and changelog edits ]",
      "id": "CVE-2024-26646",
      "published": "2024-03-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: CONFIG_AMD_GPU not set, we're not using an AMD CPU on our devices.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "d2f00cc0-05db-46a8-8fb1-1fdf757faca6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()' In link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc' was dereferenced in a DC_LOGGER_INIT(dsc->ctx->logger); before the 'dsc' NULL pointer check. Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)",
      "id": "CVE-2024-26647",
      "published": "2024-03-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "014b298c-7988-421a-8712-3f2569623b5a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay() In edp_setup_replay(), 'struct dc *dc' & 'struct dmub_replay *replay' was dereferenced before the pointer 'link' & 'replay' NULL check. Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)",
      "id": "CVE-2024-26648",
      "published": "2024-03-26T18:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_DRM_AMDGPU is not set in kernel configuration",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c15740f2-744b-451b-8d92-9ac432902088",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix use-after-free bug The bug can be triggered by sending a single amdgpu_gem_userptr_ioctl to the AMDGPU DRM driver on any ASICs with an invalid address and size. The bug was reported by Joonkyo Jung <joonkyoj@yonsei.ac.kr>. For example the following code: static void Syzkaller1(int fd) { struct drm_amdgpu_gem_userptr arg; int ret; arg.addr = 0xffffffffffff0000; arg.size = 0x80000000; /*2 Gb*/ arg.flags = 0x7; ret = drmIoctl(fd, 0xc1186451/*amdgpu_gem_userptr_ioctl*/, &arg); } Due to the address and size are not valid there is a failure in amdgpu_hmm_register->mmu_interval_notifier_insert->__mmu_interval_notifier_insert-> check_shl_overflow, but we even the amdgpu_hmm_register failure we still call amdgpu_hmm_unregister into amdgpu_gem_object_free which causes access to a bad address. The following stack is below when the issue is reproduced when Kazan is enabled: [ +0.000014] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020 [ +0.000009] RIP: 0010:mmu_interval_notifier_remove+0x327/0x340 [ +0.000017] Code: ff ff 49 89 44 24 08 48 b8 00 01 00 00 00 00 ad de 4c 89 f7 49 89 47 40 48 83 c0 22 49 89 47 48 e8 ce d1 2d 01 e9 32 ff ff ff <0f> 0b e9 16 ff ff ff 4c 89 ef e8 fa 14 b3 ff e9 36 ff ff ff e8 80 [ +0.000014] RSP: 0018:ffffc90002657988 EFLAGS: 00010246 [ +0.000013] RAX: 0000000000000000 RBX: 1ffff920004caf35 RCX: ffffffff8160565b [ +0.000011] RDX: dffffc0000000000 RSI: 0000000000000004 RDI: ffff8881a9f78260 [ +0.000010] RBP: ffffc90002657a70 R08: 0000000000000001 R09: fffff520004caf25 [ +0.000010] R10: 0000000000000003 R11: ffffffff8161d1d6 R12: ffff88810e988c00 [ +0.000010] R13: ffff888126fb5a00 R14: ffff88810e988c0c R15: ffff8881a9f78260 [ +0.000011] FS: 00007ff9ec848540(0000) GS:ffff8883cc880000(0000) knlGS:0000000000000000 [ +0.000012] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ +0.000010] CR2: 000055b3f7e14328 CR3: 00000001b5770000 CR4: 0000000000350ef0 [ +0.000010] Call Trace: [ +0.000006] <TASK> [ +0.000007] ? show_regs+0x6a/0x80 [ +0.000018] ? __warn+0xa5/0x1b0 [ +0.000019] ? mmu_interval_notifier_remove+0x327/0x340 [ +0.000018] ? report_bug+0x24a/0x290 [ +0.000022] ? handle_bug+0x46/0x90 [ +0.000015] ? exc_invalid_op+0x19/0x50 [ +0.000016] ? asm_exc_invalid_op+0x1b/0x20 [ +0.000017] ? kasan_save_stack+0x26/0x50 [ +0.000017] ? mmu_interval_notifier_remove+0x23b/0x340 [ +0.000019] ? mmu_interval_notifier_remove+0x327/0x340 [ +0.000019] ? mmu_interval_notifier_remove+0x23b/0x340 [ +0.000020] ? __pfx_mmu_interval_notifier_remove+0x10/0x10 [ +0.000017] ? kasan_save_alloc_info+0x1e/0x30 [ +0.000018] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? __kasan_kmalloc+0xb1/0xc0 [ +0.000018] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? __kasan_check_read+0x11/0x20 [ +0.000020] amdgpu_hmm_unregister+0x34/0x50 [amdgpu] [ +0.004695] amdgpu_gem_object_free+0x66/0xa0 [amdgpu] [ +0.004534] ? __pfx_amdgpu_gem_object_free+0x10/0x10 [amdgpu] [ +0.004291] ? do_syscall_64+0x5f/0xe0 [ +0.000023] ? srso_return_thunk+0x5/0x5f [ +0.000017] drm_gem_object_free+0x3b/0x50 [drm] [ +0.000489] amdgpu_gem_userptr_ioctl+0x306/0x500 [amdgpu] [ +0.004295] ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu] [ +0.004270] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? __this_cpu_preempt_check+0x13/0x20 [ +0.000015] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? sysvec_apic_timer_interrupt+0x57/0xc0 [ +0.000020] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? asm_sysvec_apic_timer_interrupt+0x1b/0x20 [ +0.000022] ? drm_ioctl_kernel+0x17b/0x1f0 [drm] [ +0.000496] ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu] [ +0.004272] ? drm_ioctl_kernel+0x190/0x1f0 [drm] [ +0.000492] drm_ioctl_kernel+0x140/0x1f0 [drm] [ +0.000497] ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu] [ +0.004297] ? __pfx_drm_ioctl_kernel+0x10/0x10 [d ---truncated---",
      "id": "CVE-2024-26656",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-28T22:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6be33cc1-54f6-4cc3-86c6-4fd2e74431f6",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL test for 'timing generator' in 'dcn21_set_pipe()' In \"u32 otg_inst = pipe_ctx->stream_res.tg->inst;\" pipe_ctx->stream_res.tg could be NULL, it is relying on the caller to ensure the tg is not NULL.",
      "id": "CVE-2024-26661",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "0913f1ac-171f-4e0b-a808-dd369345e50f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix 'panel_cntl' could be null in 'dcn21_set_backlight_level()' 'panel_cntl' structure used to control the display panel could be null, dereferencing it could lead to a null pointer access. Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn21/dcn21_hwseq.c:269 dcn21_set_backlight_level() error: we previously assumed 'panel_cntl' could be null (see line 250)",
      "id": "CVE-2024-26662",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "9fa784a4-90df-4697-aee2-7338515986a6",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: flower: Fix chain template offload When a qdisc is deleted from a net device the stack instructs the underlying driver to remove its flow offload callback from the associated filter block using the 'FLOW_BLOCK_UNBIND' command. The stack then continues to replay the removal of the filters in the block for this driver by iterating over the chains in the block and invoking the 'reoffload' operation of the classifier being used. In turn, the classifier in its 'reoffload' operation prepares and emits a 'FLOW_CLS_DESTROY' command for each filter. However, the stack does not do the same for chain templates and the underlying driver never receives a 'FLOW_CLS_TMPLT_DESTROY' command when a qdisc is deleted. This results in a memory leak [1] which can be reproduced using [2]. Fix by introducing a 'tmplt_reoffload' operation and have the stack invoke it with the appropriate arguments as part of the replay. Implement the operation in the sole classifier that supports chain templates (flower) by emitting the 'FLOW_CLS_TMPLT_{CREATE,DESTROY}' command based on whether a flow offload callback is being bound to a filter block or being unbound from one. As far as I can tell, the issue happens since cited commit which reordered tcf_block_offload_unbind() before tcf_block_flush_all_chains() in __tcf_block_put(). The order cannot be reversed as the filter block is expected to be freed after flushing all the chains. [1] unreferenced object 0xffff888107e28800 (size 2048): comm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s) hex dump (first 32 bytes): b1 a6 7c 11 81 88 ff ff e0 5b b3 10 81 88 ff ff ..|......[...... 01 00 00 00 00 00 00 00 e0 aa b0 84 ff ff ff ff ................ backtrace: [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320 [<ffffffff81ab374e>] __kmalloc+0x4e/0x90 [<ffffffff832aec6d>] mlxsw_sp_acl_ruleset_get+0x34d/0x7a0 [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180 [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280 [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340 [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0 [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170 [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0 [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440 [<ffffffff83ac6270>] netlink_unicast+0x540/0x820 [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0 [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80 [<ffffffff8379d29a>] ___sys_sendmsg+0x13a/0x1e0 [<ffffffff8379d50c>] __sys_sendmsg+0x11c/0x1f0 [<ffffffff843b9ce0>] do_syscall_64+0x40/0xe0 unreferenced object 0xffff88816d2c0400 (size 1024): comm \"tc\", pid 1079, jiffies 4294958525 (age 3074.287s) hex dump (first 32 bytes): 40 00 00 00 00 00 00 00 57 f6 38 be 00 00 00 00 @.......W.8..... 10 04 2c 6d 81 88 ff ff 10 04 2c 6d 81 88 ff ff ..,m......,m.... backtrace: [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320 [<ffffffff81ab36c1>] __kmalloc_node+0x51/0x90 [<ffffffff81a8ed96>] kvmalloc_node+0xa6/0x1f0 [<ffffffff82827d03>] bucket_table_alloc.isra.0+0x83/0x460 [<ffffffff82828d2b>] rhashtable_init+0x43b/0x7c0 [<ffffffff832aed48>] mlxsw_sp_acl_ruleset_get+0x428/0x7a0 [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180 [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280 [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340 [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0 [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170 [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0 [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440 [<ffffffff83ac6270>] netlink_unicast+0x540/0x820 [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0 [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80 [2] # tc qdisc add dev swp1 clsact # tc chain add dev swp1 ingress proto ip chain 1 flower dst_ip 0.0.0.0/32 # tc qdisc del dev ---truncated---",
      "id": "CVE-2024-26669",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "2d324ab6-71c4-426d-a70e-382e6c7ed884",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()' Fixes the below: drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368) 357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev, enum amdgpu_mca_error_type type, 358 int idx, struct mca_bank_entry *entry) 359 { 360 const struct amdgpu_mca_smu_funcs *mca_funcs = adev->mca.mca_funcs; 361 int count; 362 363 switch (type) { 364 case AMDGPU_MCA_ERROR_TYPE_UE: 365 count = mca_funcs->max_ue_count; mca_funcs is dereferenced here. 366 break; 367 case AMDGPU_MCA_ERROR_TYPE_CE: 368 count = mca_funcs->max_ce_count; mca_funcs is dereferenced here. 369 break; 370 default: 371 return -EINVAL; 372 } 373 374 if (idx >= count) 375 return -EINVAL; 376 377 if (mca_funcs && mca_funcs->mca_get_mca_entry) ^^^^^^^^^ Checked too late!",
      "id": "CVE-2024-26672",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:53Z"
      },
      "bom-ref": "0f14685b-6208-426e-8393-0ecb99166c05",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: rxrpc: Fix delayed ACKs to not set the reference serial number Fix the construction of delayed ACKs to not set the reference serial number as they can't be used as an RTT reference.",
      "id": "CVE-2024-26677",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:54Z"
      },
      "bom-ref": "26571a18-3655-45e7-ad4d-820c70505132",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: atlantic: Fix DMA mapping for PTP hwts ring Function aq_ring_hwts_rx_alloc() maps extra AQ_CFG_RXDS_DEF bytes for PTP HWTS ring but then generic aq_ring_free() does not take this into account. Create and use a specific function to free HWTS ring to fix this issue. Trace: [ 215.351607] ------------[ cut here ]------------ [ 215.351612] DMA-API: atlantic 0000:4b:00.0: device driver frees DMA memory with different size [device address=0x00000000fbdd0000] [map size=34816 bytes] [unmap size=32768 bytes] [ 215.351635] WARNING: CPU: 33 PID: 10759 at kernel/dma/debug.c:988 check_unmap+0xa6f/0x2360 ... [ 215.581176] Call Trace: [ 215.583632] <TASK> [ 215.585745] ? show_trace_log_lvl+0x1c4/0x2df [ 215.590114] ? show_trace_log_lvl+0x1c4/0x2df [ 215.594497] ? debug_dma_free_coherent+0x196/0x210 [ 215.599305] ? check_unmap+0xa6f/0x2360 [ 215.603147] ? __warn+0xca/0x1d0 [ 215.606391] ? check_unmap+0xa6f/0x2360 [ 215.610237] ? report_bug+0x1ef/0x370 [ 215.613921] ? handle_bug+0x3c/0x70 [ 215.617423] ? exc_invalid_op+0x14/0x50 [ 215.621269] ? asm_exc_invalid_op+0x16/0x20 [ 215.625480] ? check_unmap+0xa6f/0x2360 [ 215.629331] ? mark_lock.part.0+0xca/0xa40 [ 215.633445] debug_dma_free_coherent+0x196/0x210 [ 215.638079] ? __pfx_debug_dma_free_coherent+0x10/0x10 [ 215.643242] ? slab_free_freelist_hook+0x11d/0x1d0 [ 215.648060] dma_free_attrs+0x6d/0x130 [ 215.651834] aq_ring_free+0x193/0x290 [atlantic] [ 215.656487] aq_ptp_ring_free+0x67/0x110 [atlantic] ... [ 216.127540] ---[ end trace 6467e5964dd2640b ]--- [ 216.132160] DMA-API: Mapped at: [ 216.132162] debug_dma_alloc_coherent+0x66/0x2f0 [ 216.132165] dma_alloc_attrs+0xf5/0x1b0 [ 216.132168] aq_ring_hwts_rx_alloc+0x150/0x1f0 [atlantic] [ 216.132193] aq_ptp_ring_alloc+0x1bb/0x540 [atlantic] [ 216.132213] aq_nic_init+0x4a1/0x760 [atlantic]",
      "id": "CVE-2024-26680",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:56Z"
      },
      "bom-ref": "d2d5edd2-ed7e-4af8-9748-05d263b725e1",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/proc: do_task_stat: use sig->stats_lock to gather the threads/children stats lock_task_sighand() can trigger a hard lockup. If NR_CPUS threads call do_task_stat() at the same time and the process has NR_THREADS, it will spin with irqs disabled O(NR_CPUS * NR_THREADS) time. Change do_task_stat() to use sig->stats_lock to gather the statistics outside of ->siglock protected section, in the likely case this code will run lockless.",
      "id": "CVE-2024-26686",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:57Z"
      },
      "bom-ref": "b59818fa-6a01-40b2-b6cb-b4621ae6328b",
      "cwes": [
        459
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: xen/events: close evtchn after mapping cleanup shutdown_pirq and startup_pirq are not taking the irq_mapping_update_lock because they can't due to lock inversion. Both are called with the irq_desc->lock being taking. The lock order, however, is first irq_mapping_update_lock and then irq_desc->lock. This opens multiple races: - shutdown_pirq can be interrupted by a function that allocates an event channel: CPU0 CPU1 shutdown_pirq { xen_evtchn_close(e) __startup_pirq { EVTCHNOP_bind_pirq -> returns just freed evtchn e set_evtchn_to_irq(e, irq) } xen_irq_info_cleanup() { set_evtchn_to_irq(e, -1) } } Assume here event channel e refers here to the same event channel number. After this race the evtchn_to_irq mapping for e is invalid (-1). - __startup_pirq races with __unbind_from_irq in a similar way. Because __startup_pirq doesn't take irq_mapping_update_lock it can grab the evtchn that __unbind_from_irq is currently freeing and cleaning up. In this case even though the event channel is allocated, its mapping can be unset in evtchn_to_irq. The fix is to first cleanup the mappings and then close the event channel. In this way, when an event channel gets allocated it's potential previous evtchn_to_irq mappings are guaranteed to be unset already. This is also the reverse order of the allocation where first the event channel is allocated and then the mappings are setup. On a 5.10 kernel prior to commit 3fcdaf3d7634 (\"xen/events: modify internal [un]bind interfaces\"), we hit a BUG like the following during probing of NVMe devices. The issue is that during nvme_setup_io_queues, pci_free_irq is called for every device which results in a call to shutdown_pirq. With many nvme devices it's therefore likely to hit this race during boot because there will be multiple calls to shutdown_pirq and startup_pirq are running potentially in parallel. ------------[ cut here ]------------ blkfront: xvda: barrier or flush: disabled; persistent grants: enabled; indirect descriptors: enabled; bounce buffer: enabled kernel BUG at drivers/xen/events/events_base.c:499! invalid opcode: 0000 [#1] SMP PTI CPU: 44 PID: 375 Comm: kworker/u257:23 Not tainted 5.10.201-191.748.amzn2.x86_64 #1 Hardware name: Xen HVM domU, BIOS 4.11.amazon 08/24/2006 Workqueue: nvme-reset-wq nvme_reset_work RIP: 0010:bind_evtchn_to_cpu+0xdf/0xf0 Code: 5d 41 5e c3 cc cc cc cc 44 89 f7 e8 2b 55 ad ff 49 89 c5 48 85 c0 0f 84 64 ff ff ff 4c 8b 68 30 41 83 fe ff 0f 85 60 ff ff ff <0f> 0b 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00 RSP: 0000:ffffc9000d533b08 EFLAGS: 00010046 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006 RDX: 0000000000000028 RSI: 00000000ffffffff RDI: 00000000ffffffff RBP: ffff888107419680 R08: 0000000000000000 R09: ffffffff82d72b00 R10: 0000000000000000 R11: 0000000000000000 R12: 00000000000001ed R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000002 FS: 0000000000000000(0000) GS:ffff88bc8b500000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 0000000002610001 CR4: 00000000001706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: ? show_trace_log_lvl+0x1c1/0x2d9 ? show_trace_log_lvl+0x1c1/0x2d9 ? set_affinity_irq+0xdc/0x1c0 ? __die_body.cold+0x8/0xd ? die+0x2b/0x50 ? do_trap+0x90/0x110 ? bind_evtchn_to_cpu+0xdf/0xf0 ? do_error_trap+0x65/0x80 ? bind_evtchn_to_cpu+0xdf/0xf0 ? exc_invalid_op+0x4e/0x70 ? bind_evtchn_to_cpu+0xdf/0xf0 ? asm_exc_invalid_op+0x12/0x20 ? bind_evtchn_to_cpu+0xdf/0x ---truncated---",
      "id": "CVE-2024-26687",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:47:59Z"
      },
      "bom-ref": "10516594-4d43-450a-83ca-f2f0b2c345a6",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: arm64: Fix circular locking dependency The rule inside kvm enforces that the vcpu->mutex is taken *inside* kvm->lock. The rule is violated by the pkvm_create_hyp_vm() which acquires the kvm->lock while already holding the vcpu->mutex lock from kvm_vcpu_ioctl(). Avoid the circular locking dependency altogether by protecting the hyp vm handle with the config_lock, much like we already do for other forms of VM-scoped data.",
      "id": "CVE-2024-26691",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-27T14:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "95dd0738-b60a-448f-80ba-96998e7bdf4f",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix array-index-out-of-bounds in dcn35_clkmgr [Why] There is a potential memory access violation while iterating through array of dcn35 clks. [How] Limit iteration per array size.",
      "id": "CVE-2024-26699",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-27T14:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "0c9be6d1-e20d-44b0-8c5f-da164c912b31",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix MST Null Ptr for RV The change try to fix below error specific to RV platform: BUG: kernel NULL pointer dereference, address: 0000000000000008 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2 Hardware name: LENOVO 20NKS01Y00/20NKS01Y00, BIOS R12ET61W(1.31 ) 07/28/2022 RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper] Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8> RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224 RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280 RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850 R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000 R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224 FS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x171/0x4e0 ? plist_add+0xbe/0x100 ? exc_page_fault+0x7c/0x180 ? asm_exc_page_fault+0x26/0x30 ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] drm_atomic_check_only+0x5c5/0xa40 drm_mode_atomic_ioctl+0x76e/0xbc0 ? _copy_to_user+0x25/0x30 ? drm_ioctl+0x296/0x4b0 ? __pfx_drm_mode_atomic_ioctl+0x10/0x10 drm_ioctl_kernel+0xcd/0x170 drm_ioctl+0x26d/0x4b0 ? __pfx_drm_mode_atomic_ioctl+0x10/0x10 amdgpu_drm_ioctl+0x4e/0x90 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] __x64_sys_ioctl+0x94/0xd0 do_syscall_64+0x60/0x90 ? do_syscall_64+0x6c/0x90 entry_SYSCALL_64_after_hwframe+0x72/0xdc RIP: 0033:0x7f4dad17f76f Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 <89> c> RSP: 002b:00007ffd9ae859f0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 000055e255a55900 RCX: 00007f4dad17f76f RDX: 00007ffd9ae85a90 RSI: 00000000c03864bc RDI: 000000000000000b RBP: 00007ffd9ae85a90 R08: 0000000000000003 R09: 0000000000000003 R10: 0000000000000000 R11: 0000000000000246 R12: 00000000c03864bc R13: 000000000000000b R14: 000055e255a7fc60 R15: 000055e255a01eb0 </TASK> Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device ccm cmac algif_hash algif_skcipher af_alg joydev mousedev bnep > typec libphy k10temp ipmi_msghandler roles i2c_scmi acpi_cpufreq mac_hid nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_mas> CR2: 0000000000000008 ---[ end trace 0000000000000000 ]--- RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper] Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8> RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224 RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280 RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850 R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000 R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224 FS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000 ---truncated---",
      "id": "CVE-2024-26700",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T20:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:00Z"
      },
      "bom-ref": "4787f1b6-09d9-41ac-8a4c-33d4cc82994e",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: parisc: Fix random data corruption from exception handler The current exception handler implementation, which assists when accessing user space memory, may exhibit random data corruption if the compiler decides to use a different register than the specified register %r29 (defined in ASM_EXCEPTIONTABLE_REG) for the error code. If the compiler choose another register, the fault handler will nevertheless store -EFAULT into %r29 and thus trash whatever this register is used for. Looking at the assembly I found that this happens sometimes in emulate_ldd(). To solve the issue, the easiest solution would be if it somehow is possible to tell the fault handler which register is used to hold the error code. Using %0 or %1 in the inline assembly is not posssible as it will show up as e.g. %r29 (with the \"%r\" prefix), which the GNU assembler can not convert to an integer. This patch takes another, better and more flexible approach: We extend the __ex_table (which is out of the execution path) by one 32-word. In this word we tell the compiler to insert the assembler instruction \"or %r0,%r0,%reg\", where %reg references the register which the compiler choosed for the error return code. In case of an access failure, the fault handler finds the __ex_table entry and can examine the opcode. The used register is encoded in the lowest 5 bits, and the fault handler can then store -EFAULT into this register. Since we extend the __ex_table to 3 words we can't use the BUILDTIME_TABLE_SORT config option any longer.",
      "id": "CVE-2024-26706",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:02Z"
      },
      "bom-ref": "05179535-554c-4c17-9896-1bd85bd2155a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: interconnect: qcom: sc8180x: Mark CO0 BCM keepalive The CO0 BCM needs to be up at all times, otherwise some hardware (like the UFS controller) loses its connection to the rest of the SoC, resulting in a hang of the platform, accompanied by a spectacular logspam. Mark it as keepalive to prevent such cases.",
      "id": "CVE-2024-26714",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:03Z"
      },
      "bom-ref": "aaa9605e-861b-4dda-9e14-c3c0c24e57ed",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: dm-crypt, dm-verity: disable tasklets Tasklets have an inherent problem with memory corruption. The function tasklet_action_common calls tasklet_trylock, then it calls the tasklet callback and then it calls tasklet_unlock. If the tasklet callback frees the structure that contains the tasklet or if it calls some code that may free it, tasklet_unlock will write into free memory. The commits 8e14f610159d and d9a02e016aaf try to fix it for dm-crypt, but it is not a sufficient fix and the data corruption can still happen [1]. There is no fix for dm-verity and dm-verity will write into free memory with every tasklet-processed bio. There will be atomic workqueues implemented in the kernel 6.9 [2]. They will have better interface and they will not suffer from the memory corruption problem. But we need something that stops the memory corruption now and that can be backported to the stable kernels. So, I'm proposing this commit that disables tasklets in both dm-crypt and dm-verity. This commit doesn't remove the tasklet support, because the tasklet code will be reused when atomic workqueues will be implemented. [1] https://lore.kernel.org/all/d390d7ee-f142-44d3-822a-87949e14608b@suse.de/T/ [2] https://lore.kernel.org/lkml/20240130091300.2968534-1-tj@kernel.org/",
      "id": "CVE-2024-26718",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:05Z"
      },
      "bom-ref": "af3c74d5-43ee-4f45-9b27-18ad304b3ba5",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nouveau: offload fence uevents work to workqueue This should break the deadlock between the fctx lock and the irq lock. This offloads the processing off the work from the irq into a workqueue.",
      "id": "CVE-2024-26719",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T16:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_FS_BTRFS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e3dc625f-d047-4c8a-bf27-f0f04eb86934",
      "cwes": [
        617
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: don't drop extent_map for free space inode on write error While running the CI for an unrelated change I hit the following panic with generic/648 on btrfs_holes_spacecache. assertion failed: block_start != EXTENT_MAP_HOLE, in fs/btrfs/extent_io.c:1385 ------------[ cut here ]------------ kernel BUG at fs/btrfs/extent_io.c:1385! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 1 PID: 2695096 Comm: fsstress Kdump: loaded Tainted: G W 6.8.0-rc2+ #1 RIP: 0010:__extent_writepage_io.constprop.0+0x4c1/0x5c0 Call Trace: <TASK> extent_write_cache_pages+0x2ac/0x8f0 extent_writepages+0x87/0x110 do_writepages+0xd5/0x1f0 filemap_fdatawrite_wbc+0x63/0x90 __filemap_fdatawrite_range+0x5c/0x80 btrfs_fdatawrite_range+0x1f/0x50 btrfs_write_out_cache+0x507/0x560 btrfs_write_dirty_block_groups+0x32a/0x420 commit_cowonly_roots+0x21b/0x290 btrfs_commit_transaction+0x813/0x1360 btrfs_sync_file+0x51a/0x640 __x64_sys_fdatasync+0x52/0x90 do_syscall_64+0x9c/0x190 entry_SYSCALL_64_after_hwframe+0x6e/0x76 This happens because we fail to write out the free space cache in one instance, come back around and attempt to write it again. However on the second pass through we go to call btrfs_get_extent() on the inode to get the extent mapping. Because this is a new block group, and with the free space inode we always search the commit root to avoid deadlocking with the tree, we find nothing and return a EXTENT_MAP_HOLE for the requested range. This happens because the first time we try to write the space cache out we hit an error, and on an error we drop the extent mapping. This is normal for normal files, but the free space cache inode is special. We always expect the extent map to be correct. Thus the second time through we end up with a bogus extent map. Since we're deprecating this feature, the most straightforward way to fix this is to simply skip dropping the extent map range for this failed range. I shortened the test by using error injection to stress the area to make it easier to reproduce. With this patch in place we no longer panic with my error injection test.",
      "id": "CVE-2024-26726",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "d76eb477-a3e5-4c9a-b0a1-d7095ddb58e1",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: act_mirred: don't override retval if we already lost the skb If we're redirecting the skb, and haven't called tcf_mirred_forward(), yet, we need to tell the core to drop the skb by setting the retcode to SHOT. If we have called tcf_mirred_forward(), however, the skb is out of our hands and returning SHOT will lead to UaF. Move the retval override to the error path which actually need it.",
      "id": "CVE-2024-26739",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:06Z"
      },
      "bom-ref": "cdba443a-2287-4743-81fa-9ef337b9d18b",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: act_mirred: use the backlog for mirred ingress The test Davide added in commit ca22da2fbd69 (\"act_mirred: use the backlog for nested calls to mirred ingress\") hangs our testing VMs every 10 or so runs, with the familiar tcp_v4_rcv -> tcp_v4_rcv deadlock reported by lockdep. The problem as previously described by Davide (see Link) is that if we reverse flow of traffic with the redirect (egress -> ingress) we may reach the same socket which generated the packet. And we may still be holding its socket lock. The common solution to such deadlocks is to put the packet in the Rx backlog, rather than run the Rx path inline. Do that for all egress -> ingress reversals, not just once we started to nest mirred calls. In the past there was a concern that the backlog indirection will lead to loss of error reporting / less accurate stats. But the current workaround does not seem to address the issue.",
      "id": "CVE-2024-26740",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:08Z"
      },
      "bom-ref": "53c97724-5693-4071-bd74-3f8269f26e19",
      "cwes": [
        459
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: md: Don't register sync_thread for reshape directly Currently, if reshape is interrupted, then reassemble the array will register sync_thread directly from pers->run(), in this case 'MD_RECOVERY_RUNNING' is set directly, however, there is no guarantee that md_do_sync() will be executed, hence stop_sync_thread() will hang because 'MD_RECOVERY_RUNNING' can't be cleared. Last patch make sure that md_do_sync() will set MD_RECOVERY_DONE, however, following hang can still be triggered by dm-raid test shell/lvconvert-raid-reshape.sh occasionally: [root@fedora ~]# cat /proc/1982/stack [<0>] stop_sync_thread+0x1ab/0x270 [md_mod] [<0>] md_frozen_sync_thread+0x5c/0xa0 [md_mod] [<0>] raid_presuspend+0x1e/0x70 [dm_raid] [<0>] dm_table_presuspend_targets+0x40/0xb0 [dm_mod] [<0>] __dm_destroy+0x2a5/0x310 [dm_mod] [<0>] dm_destroy+0x16/0x30 [dm_mod] [<0>] dev_remove+0x165/0x290 [dm_mod] [<0>] ctl_ioctl+0x4bb/0x7b0 [dm_mod] [<0>] dm_ctl_ioctl+0x11/0x20 [dm_mod] [<0>] vfs_ioctl+0x21/0x60 [<0>] __x64_sys_ioctl+0xb9/0xe0 [<0>] do_syscall_64+0xc6/0x230 [<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74 Meanwhile mddev->recovery is: MD_RECOVERY_RUNNING | MD_RECOVERY_INTR | MD_RECOVERY_RESHAPE | MD_RECOVERY_FROZEN Fix this problem by remove the code to register sync_thread directly from raid10 and raid5. And let md_check_recovery() to register sync_thread.",
      "id": "CVE-2024-26756",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:09Z"
      },
      "bom-ref": "be7a73b3-f04c-40ea-8a5b-2bf1a474b29d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: md: Don't ignore read-only array in md_check_recovery() Usually if the array is not read-write, md_check_recovery() won't register new sync_thread in the first place. And if the array is read-write and sync_thread is registered, md_set_readonly() will unregister sync_thread before setting the array read-only. md/raid follow this behavior hence there is no problem. After commit f52f5c71f3d4 (\"md: fix stopping sync thread\"), following hang can be triggered by test shell/integrity-caching.sh: 1) array is read-only. dm-raid update super block: rs_update_sbs ro = mddev->ro mddev->ro = 0 -> set array read-write md_update_sb 2) register new sync thread concurrently. 3) dm-raid set array back to read-only: rs_update_sbs mddev->ro = ro 4) stop the array: raid_dtr md_stop stop_sync_thread set_bit(MD_RECOVERY_INTR, &mddev->recovery); md_wakeup_thread_directly(mddev->sync_thread); wait_event(..., !test_bit(MD_RECOVERY_RUNNING, &mddev->recovery)) 5) sync thread done: md_do_sync set_bit(MD_RECOVERY_DONE, &mddev->recovery); md_wakeup_thread(mddev->thread); 6) daemon thread can't unregister sync thread: md_check_recovery if (!md_is_rdwr(mddev) && !test_bit(MD_RECOVERY_NEEDED, &mddev->recovery)) return; -> -> MD_RECOVERY_RUNNING can't be cleared, hence step 4 hang; The root cause is that dm-raid manipulate 'mddev->ro' by itself, however, dm-raid really should stop sync thread before setting the array read-only. Unfortunately, I need to read more code before I can refacter the handler of 'mddev->ro' in dm-raid, hence let's fix the problem the easy way for now to prevent dm-raid regression.",
      "id": "CVE-2024-26757",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-04T14:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:11Z"
      },
      "bom-ref": "f13021b6-83c7-4e1c-a731-4c86c6909c59",
      "description": "In the Linux kernel, the following vulnerability has been resolved: md: Don't ignore suspended array in md_check_recovery() mddev_suspend() never stop sync_thread, hence it doesn't make sense to ignore suspended array in md_check_recovery(), which might cause sync_thread can't be unregistered. After commit f52f5c71f3d4 (\"md: fix stopping sync thread\"), following hang can be triggered by test shell/integrity-caching.sh: 1) suspend the array: raid_postsuspend mddev_suspend 2) stop the array: raid_dtr md_stop __md_stop_writes stop_sync_thread set_bit(MD_RECOVERY_INTR, &mddev->recovery); md_wakeup_thread_directly(mddev->sync_thread); wait_event(..., !test_bit(MD_RECOVERY_RUNNING, &mddev->recovery)) 3) sync thread done: md_do_sync set_bit(MD_RECOVERY_DONE, &mddev->recovery); md_wakeup_thread(mddev->thread); 4) daemon thread can't unregister sync thread: md_check_recovery if (mddev->suspended) return; -> return directly md_read_sync_thread clear_bit(MD_RECOVERY_RUNNING, &mddev->recovery); -> MD_RECOVERY_RUNNING can't be cleared, hence step 2 hang; This problem is not just related to dm-raid, fix it by ignoring suspended array in md_check_recovery(). And follow up patches will improve dm-raid better to frozen sync thread during suspend.",
      "id": "CVE-2024-26758",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-04T14:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:12Z"
      },
      "bom-ref": "213b2e14-49ae-4931-b46d-b8eaaa1f84cc",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm/swap: fix race when skipping swapcache When skipping swapcache for SWP_SYNCHRONOUS_IO, if two or more threads swapin the same entry at the same time, they get different pages (A, B). Before one thread (T0) finishes the swapin and installs page (A) to the PTE, another thread (T1) could finish swapin of page (B), swap_free the entry, then swap out the possibly modified page reusing the same entry. It breaks the pte_same check in (T0) because PTE value is unchanged, causing ABA problem. Thread (T0) will install a stalled page (A) into the PTE and cause data corruption. One possible callstack is like this: CPU0 CPU1 ---- ---- do_swap_page() do_swap_page() with same entry <direct swapin path> <direct swapin path> <alloc page A> <alloc page B> swap_read_folio() <- read to page A swap_read_folio() <- read to page B <slow on later locks or interrupt> <finished swapin first> ... set_pte_at() swap_free() <- entry is free <write to page B, now page A stalled> <swap out page B to same swap entry> pte_same() <- Check pass, PTE seems unchanged, but page A is stalled! swap_free() <- page B content lost! set_pte_at() <- staled page A installed! And besides, for ZRAM, swap_free() allows the swap device to discard the entry content, so even if page (B) is not modified, if swap_read_folio() on CPU0 happens later than swap_free() on CPU1, it may also cause data loss. To fix this, reuse swapcache_prepare which will pin the swap entry using the cache flag, and allow only one thread to swap it in, also prevent any parallel code from putting the entry in the cache. Release the pin after PT unlocked. Racers just loop and wait since it's a rare and very short event. A schedule_timeout_uninterruptible(1) call is added to avoid repeated page faults wasting too much CPU, causing livelock or adding too much noise to perf statistics. A similar livelock issue was described in commit 029c4628b2eb (\"mm: swap: get rid of livelock in swapin readahead\") Reproducer: This race issue can be triggered easily using a well constructed reproducer and patched brd (with a delay in read path) [1]: With latest 6.8 mainline, race caused data loss can be observed easily: $ gcc -g -lpthread test-thread-swap-race.c && ./a.out Polulating 32MB of memory region... Keep swapping out... Starting round 0... Spawning 65536 workers... 32746 workers spawned, wait for done... Round 0: Error on 0x5aa00, expected 32746, got 32743, 3 data loss! Round 0: Error on 0x395200, expected 32746, got 32743, 3 data loss! Round 0: Error on 0x3fd000, expected 32746, got 32737, 9 data loss! Round 0 Failed, 15 data loss! This reproducer spawns multiple threads sharing the same memory region using a small swap device. Every two threads updates mapped pages one by one in opposite direction trying to create a race, with one dedicated thread keep swapping out the data out using madvise. The reproducer created a reproduce rate of about once every 5 minutes, so the race should be totally possible in production. After this patch, I ran the reproducer for over a few hundred rounds and no data loss observed. Performance overhead is minimal, microbenchmark swapin 10G from 32G zram: Before: 10934698 us After: 11157121 us Cached: 13155355 us (Dropping SWP_SYNCHRONOUS_IO flag) [kasong@tencent.com: v4]",
      "id": "CVE-2024-26759",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-16T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:14Z"
      },
      "bom-ref": "c5809361-74ac-4006-a3d3-40f457102c70",
      "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: Disable IRQ before init_fn() for nonboot CPUs Disable IRQ before init_fn() for nonboot CPUs when hotplug, in order to silence such warnings (and also avoid potential errors due to unexpected interrupts): WARNING: CPU: 1 PID: 0 at kernel/rcu/tree.c:4503 rcu_cpu_starting+0x214/0x280 CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.6.17+ #1198 pc 90000000048e3334 ra 90000000047bd56c tp 900000010039c000 sp 900000010039fdd0 a0 0000000000000001 a1 0000000000000006 a2 900000000802c040 a3 0000000000000000 a4 0000000000000001 a5 0000000000000004 a6 0000000000000000 a7 90000000048e3f4c t0 0000000000000001 t1 9000000005c70968 t2 0000000004000000 t3 000000000005e56e t4 00000000000002e4 t5 0000000000001000 t6 ffffffff80000000 t7 0000000000040000 t8 9000000007931638 u0 0000000000000006 s9 0000000000000004 s0 0000000000000001 s1 9000000006356ac0 s2 9000000007244000 s3 0000000000000001 s4 0000000000000001 s5 900000000636f000 s6 7fffffffffffffff s7 9000000002123940 s8 9000000001ca55f8 ra: 90000000047bd56c tlb_init+0x24c/0x528 ERA: 90000000048e3334 rcu_cpu_starting+0x214/0x280 CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE) PRMD: 00000000 (PPLV0 -PIE -PWE) EUEN: 00000000 (-FPE -SXE -ASXE -BTE) ECFG: 00071000 (LIE=12 VS=7) ESTAT: 000c0000 [BRK] (IS= ECode=12 EsubCode=0) PRID: 0014c010 (Loongson-64bit, Loongson-3A5000) CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.6.17+ #1198 Stack : 0000000000000000 9000000006375000 9000000005b61878 900000010039c000 900000010039fa30 0000000000000000 900000010039fa38 900000000619a140 9000000006456888 9000000006456880 900000010039f950 0000000000000001 0000000000000001 cb0cb028ec7e52e1 0000000002b90000 9000000100348700 0000000000000000 0000000000000001 ffffffff916d12f1 0000000000000003 0000000000040000 9000000007930370 0000000002b90000 0000000000000004 9000000006366000 900000000619a140 0000000000000000 0000000000000004 0000000000000000 0000000000000009 ffffffffffc681f2 9000000002123940 9000000001ca55f8 9000000006366000 90000000047a4828 00007ffff057ded8 00000000000000b0 0000000000000000 0000000000000000 0000000000071000 ... Call Trace: [<90000000047a4828>] show_stack+0x48/0x1a0 [<9000000005b61874>] dump_stack_lvl+0x84/0xcc [<90000000047f60ac>] __warn+0x8c/0x1e0 [<9000000005b0ab34>] report_bug+0x1b4/0x280 [<9000000005b63110>] do_bp+0x2d0/0x480 [<90000000047a2e20>] handle_bp+0x120/0x1c0 [<90000000048e3334>] rcu_cpu_starting+0x214/0x280 [<90000000047bd568>] tlb_init+0x248/0x528 [<90000000047a4c44>] per_cpu_trap_init+0x124/0x160 [<90000000047a19f4>] cpu_probe+0x494/0xa00 [<90000000047b551c>] start_secondary+0x3c/0xc0 [<9000000005b66134>] smpboot_entry+0x50/0x58",
      "id": "CVE-2024-26765",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T16:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c57cee53-0e73-4197-b564-053e13193666",
      "cwes": [
        476,
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fixed integer types and null check locations [why]: issues fixed: - comparison with wider integer type in loop condition which can cause infinite loops - pointer dereference before null check",
      "id": "CVE-2024-26767",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:15Z"
      },
      "bom-ref": "0cc56a91-632f-4682-9ecf-7d01b9d3241b",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: HID: nvidia-shield: Add missing null pointer checks to LED initialization devm_kasprintf() returns a pointer to dynamically allocated memory which can be NULL upon failure. Ensure the allocation was successful by checking the pointer validity. [jkosina@suse.com: tweak changelog a bit]",
      "id": "CVE-2024-26770",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-27T14:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:17Z"
      },
      "bom-ref": "30bd70de-ab3b-45d6-9391-78cd7622ef63",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: aoe: avoid potential deadlock at set_capacity Move set_capacity() outside of the section procected by (&d->lock). To avoid possible interrupt unsafe locking scenario: CPU0 CPU1 ---- ---- [1] lock(&bdev->bd_size_lock); local_irq_disable(); [2] lock(&d->lock); [3] lock(&bdev->bd_size_lock); <Interrupt> [4] lock(&d->lock); *** DEADLOCK *** Where [1](&bdev->bd_size_lock) hold by zram_add()->set_capacity(). [2]lock(&d->lock) hold by aoeblk_gdalloc(). And aoeblk_gdalloc() is trying to acquire [3](&bdev->bd_size_lock) at set_capacity() call. In this situation an attempt to acquire [4]lock(&d->lock) from aoecmd_cfg_rsp() will lead to deadlock. So the simplest solution is breaking lock dependency [2](&d->lock) -> [3](&bdev->bd_size_lock) by moving set_capacity() outside.",
      "id": "CVE-2024-26775",
      "published": "2024-04-03T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T17:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:17Z"
      },
      "bom-ref": "8da6d7b8-dadf-4461-9282-c55ab714cc7e",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix double free of anonymous device after snapshot creation failure When creating a snapshot we may do a double free of an anonymous device in case there's an error committing the transaction. The second free may result in freeing an anonymous device number that was allocated by some other subsystem in the kernel or another btrfs filesystem. The steps that lead to this: 1) At ioctl.c:create_snapshot() we allocate an anonymous device number and assign it to pending_snapshot->anon_dev; 2) Then we call btrfs_commit_transaction() and end up at transaction.c:create_pending_snapshot(); 3) There we call btrfs_get_new_fs_root() and pass it the anonymous device number stored in pending_snapshot->anon_dev; 4) btrfs_get_new_fs_root() frees that anonymous device number because btrfs_lookup_fs_root() returned a root - someone else did a lookup of the new root already, which could some task doing backref walking; 5) After that some error happens in the transaction commit path, and at ioctl.c:create_snapshot() we jump to the 'fail' label, and after that we free again the same anonymous device number, which in the meanwhile may have been reallocated somewhere else, because pending_snapshot->anon_dev still has the same value as in step 1. Recently syzbot ran into this and reported the following trace: ------------[ cut here ]------------ ida_free called for id=51 which is not allocated. WARNING: CPU: 1 PID: 31038 at lib/idr.c:525 ida_free+0x370/0x420 lib/idr.c:525 Modules linked in: CPU: 1 PID: 31038 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-00410-gc02197fc9076 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 RIP: 0010:ida_free+0x370/0x420 lib/idr.c:525 Code: 10 42 80 3c 28 (...) RSP: 0018:ffffc90015a67300 EFLAGS: 00010246 RAX: be5130472f5dd000 RBX: 0000000000000033 RCX: 0000000000040000 RDX: ffffc90009a7a000 RSI: 000000000003ffff RDI: 0000000000040000 RBP: ffffc90015a673f0 R08: ffffffff81577992 R09: 1ffff92002b4cdb4 R10: dffffc0000000000 R11: fffff52002b4cdb5 R12: 0000000000000246 R13: dffffc0000000000 R14: ffffffff8e256b80 R15: 0000000000000246 FS: 00007fca3f4b46c0(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f167a17b978 CR3: 000000001ed26000 CR4: 0000000000350ef0 Call Trace: <TASK> btrfs_get_root_ref+0xa48/0xaf0 fs/btrfs/disk-io.c:1346 create_pending_snapshot+0xff2/0x2bc0 fs/btrfs/transaction.c:1837 create_pending_snapshots+0x195/0x1d0 fs/btrfs/transaction.c:1931 btrfs_commit_transaction+0xf1c/0x3740 fs/btrfs/transaction.c:2404 create_snapshot+0x507/0x880 fs/btrfs/ioctl.c:848 btrfs_mksubvol+0x5d0/0x750 fs/btrfs/ioctl.c:998 btrfs_mksnapshot+0xb5/0xf0 fs/btrfs/ioctl.c:1044 __btrfs_ioctl_snap_create+0x387/0x4b0 fs/btrfs/ioctl.c:1306 btrfs_ioctl_snap_create_v2+0x1ca/0x400 fs/btrfs/ioctl.c:1393 btrfs_ioctl+0xa74/0xd40 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:871 [inline] __se_sys_ioctl+0xfe/0x170 fs/ioctl.c:857 do_syscall_64+0xfb/0x240 entry_SYSCALL_64_after_hwframe+0x6f/0x77 RIP: 0033:0x7fca3e67dda9 Code: 28 00 00 00 (...) RSP: 002b:00007fca3f4b40c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 00007fca3e7abf80 RCX: 00007fca3e67dda9 RDX: 00000000200005c0 RSI: 0000000050009417 RDI: 0000000000000003 RBP: 00007fca3e6ca47a R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 000000000000000b R14: 00007fca3e7abf80 R15: 00007fff6bf95658 </TASK> Where we get an explicit message where we attempt to free an anonymous device number that is not currently allocated. It happens in a different code path from the example below, at btrfs_get_root_ref(), so this change may not fix the case triggered by sy ---truncated---",
      "id": "CVE-2024-26792",
      "published": "2024-04-04T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-20T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:18Z"
      },
      "bom-ref": "394260b1-08b9-45ac-aa1a-88c75536921e",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: validate payload size in ipc response If installing malicious ksmbd-tools, ksmbd.mountd can return invalid ipc response to ksmbd kernel server. ksmbd should validate payload size of ipc response from ksmbd.mountd to avoid memory overrun or slab-out-of-bounds. This patch validate 3 ipc response that has payload.",
      "id": "CVE-2024-26811",
      "published": "2024-04-08T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-27T21:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:20Z"
      },
      "bom-ref": "c6f30449-4c7a-4175-b8d4-9af084fd33ee",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: vfio/pci: Create persistent INTx handler A vulnerability exists where the eventfd for INTx signaling can be deconfigured, which unregisters the IRQ handler but still allows eventfds to be signaled with a NULL context through the SET_IRQS ioctl or through unmask irqfd if the device interrupt is pending. Ideally this could be solved with some additional locking; the igate mutex serializes the ioctl and config space accesses, and the interrupt handler is unregistered relative to the trigger, but the irqfd path runs asynchronous to those. The igate mutex cannot be acquired from the atomic context of the eventfd wake function. Disabling the irqfd relative to the eventfd registration is potentially incompatible with existing userspace. As a result, the solution implemented here moves configuration of the INTx interrupt handler to track the lifetime of the INTx context object and irq_type configuration, rather than registration of a particular trigger eventfd. Synchronization is added between the ioctl path and eventfd_signal() wrapper such that the eventfd trigger can be dynamically updated relative to in-flight interrupts or irqfd callbacks.",
      "id": "CVE-2024-26812",
      "published": "2024-04-05T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T17:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:21Z"
      },
      "bom-ref": "5f4d7761-2690-46b0-888b-29c3a4bb63a8",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: vfio/fsl-mc: Block calling interrupt handler without trigger The eventfd_ctx trigger pointer of the vfio_fsl_mc_irq object is initially NULL and may become NULL if the user sets the trigger eventfd to -1. The interrupt handler itself is guaranteed that trigger is always valid between request_irq() and free_irq(), but the loopback testing mechanisms to invoke the handler function need to test the trigger. The triggering and setting ioctl paths both make use of igate and are therefore mutually exclusive. The vfio-fsl-mc driver does not make use of irqfds, nor does it support any sort of masking operations, therefore unlike vfio-pci and vfio-platform, the flow can remain essentially unchanged.",
      "id": "CVE-2024-26814",
      "published": "2024-04-05T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-27T21:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:23Z"
      },
      "bom-ref": "fe55eac7-3db8-473e-a888-76055046b0c6",
      "cwes": [
        191
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: fix underflow in parse_server_interfaces() In this loop, we step through the buffer and after each item we check if the size_left is greater than the minimum size we need. However, the problem is that \"bytes_left\" is type ssize_t while sizeof() is type size_t. That means that because of type promotion, the comparison is done as an unsigned and if we have negative bytes left the loop continues instead of ending.",
      "id": "CVE-2024-26828",
      "published": "2024-04-17T10:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:24Z"
      },
      "bom-ref": "20e94e1a-9576-4e04-8696-e695de88cc38",
      "description": "In the Linux kernel, the following vulnerability has been resolved: i40e: Do not allow untrusted VF to remove administratively set MAC Currently when PF administratively sets VF's MAC address and the VF is put down (VF tries to delete all MACs) then the MAC is removed from MAC filters and primary VF MAC is zeroed. Do not allow untrusted VF to remove primary MAC when it was set administratively by PF. Reproducer: 1) Create VF 2) Set VF interface up 3) Administratively set the VF's MAC 4) Put VF interface down [root@host ~]# echo 1 > /sys/class/net/enp2s0f0/device/sriov_numvfs [root@host ~]# ip link set enp2s0f0v0 up [root@host ~]# ip link set enp2s0f0 vf 0 mac fe:6c:b5:da:c7:7d [root@host ~]# ip link show enp2s0f0 23: enp2s0f0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 3c:ec:ef:b7:dd:04 brd ff:ff:ff:ff:ff:ff vf 0 link/ether fe:6c:b5:da:c7:7d brd ff:ff:ff:ff:ff:ff, spoof checking on, link-state auto, trust off [root@host ~]# ip link set enp2s0f0v0 down [root@host ~]# ip link show enp2s0f0 23: enp2s0f0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 3c:ec:ef:b7:dd:04 brd ff:ff:ff:ff:ff:ff vf 0 link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff, spoof checking on, link-state auto, trust off",
      "id": "CVE-2024-26830",
      "published": "2024-04-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T13:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:26Z"
      },
      "bom-ref": "2b2d776d-76dc-43c5-9833-a45b2656bf6d",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: switchdev: Skip MDB replays of deferred events on offload Before this change, generation of the list of MDB events to replay would race against the creation of new group memberships, either from the IGMP/MLD snooping logic or from user configuration. While new memberships are immediately visible to walkers of br->mdb_list, the notification of their existence to switchdev event subscribers is deferred until a later point in time. So if a replay list was generated during a time that overlapped with such a window, it would also contain a replay of the not-yet-delivered event. The driver would thus receive two copies of what the bridge internally considered to be one single event. On destruction of the bridge, only a single membership deletion event was therefore sent. As a consequence of this, drivers which reference count memberships (at least DSA), would be left with orphan groups in their hardware database when the bridge was destroyed. This is only an issue when replaying additions. While deletion events may still be pending on the deferred queue, they will already have been removed from br->mdb_list, so no duplicates can be generated in that scenario. To a user this meant that old group memberships, from a bridge in which a port was previously attached, could be reanimated (in hardware) when the port joined a new bridge, without the new bridge's knowledge. For example, on an mv88e6xxx system, create a snooping bridge and immediately add a port to it: root@infix-06-0b-00:~$ ip link add dev br0 up type bridge mcast_snooping 1 && \\ > ip link set dev x3 up master br0 And then destroy the bridge: root@infix-06-0b-00:~$ ip link del dev br0 root@infix-06-0b-00:~$ mvls atu ADDRESS FID STATE Q F 0 1 2 3 4 5 6 7 8 9 a DEV:0 Marvell 88E6393X 33:33:00:00:00:6a 1 static - - 0 . . . . . . . . . . 33:33:ff:87:e4:3f 1 static - - 0 . . . . . . . . . . ff:ff:ff:ff:ff:ff 1 static - - 0 1 2 3 4 5 6 7 8 9 a root@infix-06-0b-00:~$ The two IPv6 groups remain in the hardware database because the port (x3) is notified of the host's membership twice: once via the original event and once via a replay. Since only a single delete notification is sent, the count remains at 1 when the bridge is destroyed. Then add the same port (or another port belonging to the same hardware domain) to a new bridge, this time with snooping disabled: root@infix-06-0b-00:~$ ip link add dev br1 up type bridge mcast_snooping 0 && \\ > ip link set dev x3 up master br1 All multicast, including the two IPv6 groups from br0, should now be flooded, according to the policy of br1. But instead the old memberships are still active in the hardware database, causing the switch to only forward traffic to those groups towards the CPU (port 0). Eliminate the race in two steps: 1. Grab the write-side lock of the MDB while generating the replay list. This prevents new memberships from showing up while we are generating the replay list. But it leaves the scenario in which a deferred event was already generated, but not delivered, before we grabbed the lock. Therefore: 2. Make sure that no deferred version of a replay event is already enqueued to the switchdev deferred queue, before adding it to the replay list, when replaying additions.",
      "id": "CVE-2024-26837",
      "published": "2024-04-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T13:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:27Z"
      },
      "bom-ref": "4010bff5-331c-499e-945a-7a0f7126f69a",
      "cwes": [
        459
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: Update cpu_sibling_map when disabling nonboot CPUs Update cpu_sibling_map when disabling nonboot CPUs by defining & calling clear_cpu_sibling_map(), otherwise we get such errors on SMT systems: jump label: negative count! WARNING: CPU: 6 PID: 45 at kernel/jump_label.c:263 __static_key_slow_dec_cpuslocked+0xec/0x100 CPU: 6 PID: 45 Comm: cpuhp/6 Not tainted 6.8.0-rc5+ #1340 pc 90000000004c302c ra 90000000004c302c tp 90000001005bc000 sp 90000001005bfd20 a0 000000000000001b a1 900000000224c278 a2 90000001005bfb58 a3 900000000224c280 a4 900000000224c278 a5 90000001005bfb50 a6 0000000000000001 a7 0000000000000001 t0 ce87a4763eb5234a t1 ce87a4763eb5234a t2 0000000000000000 t3 0000000000000000 t4 0000000000000006 t5 0000000000000000 t6 0000000000000064 t7 0000000000001964 t8 000000000009ebf6 u0 9000000001f2a068 s9 0000000000000000 s0 900000000246a2d8 s1 ffffffffffffffff s2 ffffffffffffffff s3 90000000021518c0 s4 0000000000000040 s5 9000000002151058 s6 9000000009828e40 s7 00000000000000b4 s8 0000000000000006 ra: 90000000004c302c __static_key_slow_dec_cpuslocked+0xec/0x100 ERA: 90000000004c302c __static_key_slow_dec_cpuslocked+0xec/0x100 CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE) PRMD: 00000004 (PPLV0 +PIE -PWE) EUEN: 00000000 (-FPE -SXE -ASXE -BTE) ECFG: 00071c1c (LIE=2-4,10-12 VS=7) ESTAT: 000c0000 [BRK] (IS= ECode=12 EsubCode=0) PRID: 0014d000 (Loongson-64bit, Loongson-3A6000-HV) CPU: 6 PID: 45 Comm: cpuhp/6 Not tainted 6.8.0-rc5+ #1340 Stack : 0000000000000000 900000000203f258 900000000179afc8 90000001005bc000 90000001005bf980 0000000000000000 90000001005bf988 9000000001fe0be0 900000000224c280 900000000224c278 90000001005bf8c0 0000000000000001 0000000000000001 ce87a4763eb5234a 0000000007f38000 90000001003f8cc0 0000000000000000 0000000000000006 0000000000000000 4c206e6f73676e6f 6f4c203a656d616e 000000000009ec99 0000000007f38000 0000000000000000 900000000214b000 9000000001fe0be0 0000000000000004 0000000000000000 0000000000000107 0000000000000009 ffffffffffafdabe 00000000000000b4 0000000000000006 90000000004c302c 9000000000224528 00005555939a0c7c 00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c ... Call Trace: [<9000000000224528>] show_stack+0x48/0x1a0 [<900000000179afc8>] dump_stack_lvl+0x78/0xa0 [<9000000000263ed0>] __warn+0x90/0x1a0 [<90000000017419b8>] report_bug+0x1b8/0x280 [<900000000179c564>] do_bp+0x264/0x420 [<90000000004c302c>] __static_key_slow_dec_cpuslocked+0xec/0x100 [<90000000002b4d7c>] sched_cpu_deactivate+0x2fc/0x300 [<9000000000266498>] cpuhp_invoke_callback+0x178/0x8a0 [<9000000000267f70>] cpuhp_thread_fun+0xf0/0x240 [<90000000002a117c>] smpboot_thread_fn+0x1dc/0x2e0 [<900000000029a720>] kthread+0x140/0x160 [<9000000000222288>] ret_from_kernel_thread+0xc/0xa4",
      "id": "CVE-2024-26841",
      "published": "2024-04-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T13:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "bf2df5c6-ed6d-47dc-be81-5d85e093bf26",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Fix shift issue in ufshcd_clear_cmd() When task_tag >= 32 (in MCQ mode) and sizeof(unsigned int) == 4, 1U << task_tag will out of bounds for a u32 mask. Fix this up to prevent SHIFT_ISSUE (bitwise shifts that are out of bounds for their data type). [name:debug_monitors&]Unexpected kernel BRK exception at EL1 [name:traps&]Internal error: BRK handler: 00000000f2005514 [#1] PREEMPT SMP [name:mediatek_cpufreq_hw&]cpufreq stop DVFS log done [name:mrdump&]Kernel Offset: 0x1ba5800000 from 0xffffffc008000000 [name:mrdump&]PHYS_OFFSET: 0x80000000 [name:mrdump&]pstate: 22400005 (nzCv daif +PAN -UAO) [name:mrdump&]pc : [0xffffffdbaf52bb2c] ufshcd_clear_cmd+0x280/0x288 [name:mrdump&]lr : [0xffffffdbaf52a774] ufshcd_wait_for_dev_cmd+0x3e4/0x82c [name:mrdump&]sp : ffffffc0081471b0 <snip> Workqueue: ufs_eh_wq_0 ufshcd_err_handler Call trace: dump_backtrace+0xf8/0x144 show_stack+0x18/0x24 dump_stack_lvl+0x78/0x9c dump_stack+0x18/0x44 mrdump_common_die+0x254/0x480 [mrdump] ipanic_die+0x20/0x30 [mrdump] notify_die+0x15c/0x204 die+0x10c/0x5f8 arm64_notify_die+0x74/0x13c do_debug_exception+0x164/0x26c el1_dbg+0x64/0x80 el1h_64_sync_handler+0x3c/0x90 el1h_64_sync+0x68/0x6c ufshcd_clear_cmd+0x280/0x288 ufshcd_wait_for_dev_cmd+0x3e4/0x82c ufshcd_exec_dev_cmd+0x5bc/0x9ac ufshcd_verify_dev_init+0x84/0x1c8 ufshcd_probe_hba+0x724/0x1ce0 ufshcd_host_reset_and_restore+0x260/0x574 ufshcd_reset_and_restore+0x138/0xbd0 ufshcd_err_handler+0x1218/0x2f28 process_one_work+0x5fc/0x1140 worker_thread+0x7d8/0xe20 kthread+0x25c/0x468 ret_from_fork+0x10/0x20",
      "id": "CVE-2024-26842",
      "published": "2024-04-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-04T15:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:29Z"
      },
      "bom-ref": "1faf5eaa-8cf8-4680-b69c-3f3b2bda4a93",
      "description": "In the Linux kernel, the following vulnerability has been resolved: block: Fix WARNING in _copy_from_iter Syzkaller reports a warning in _copy_from_iter because an iov_iter is supposedly used in the wrong direction. The reason is that syzcaller managed to generate a request with a transfer direction of SG_DXFER_TO_FROM_DEV. This instructs the kernel to copy user buffers into the kernel, read into the copied buffers and then copy the data back to user space. Thus the iovec is used in both directions. Detect this situation in the block layer and construct a new iterator with the correct direction for the copy-in.",
      "id": "CVE-2024-26844",
      "published": "2024-04-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T13:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:30Z"
      },
      "bom-ref": "95128fb1-31b9-4dea-b762-fca2a3321e43",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: igc: avoid returning frame twice in XDP_REDIRECT When a frame can not be transmitted in XDP_REDIRECT (e.g. due to a full queue), it is necessary to free it by calling xdp_return_frame_rx_napi. However, this is the responsibility of the caller of the ndo_xdp_xmit (see for example bq_xmit_all in kernel/bpf/devmap.c) and thus calling it inside igc_xdp_xmit (which is the ndo_xdp_xmit of the igc driver) as well will lead to memory corruption. In fact, bq_xmit_all expects that it can return all frames after the last successfully transmitted one. Therefore, break for the first not transmitted frame, but do not call xdp_return_frame_rx_napi in igc_xdp_xmit. This is equally implemented in other Intel drivers such as the igb. There are two alternatives to this that were rejected: 1. Return num_frames as all the frames would have been transmitted and release them inside igc_xdp_xmit. While it might work technically, it is not what the return value is meant to represent (i.e. the number of SUCCESSFULLY transmitted packets). 2. Rework kernel/bpf/devmap.c and all drivers to support non-consecutively dropped packets. Besides being complex, it likely has a negative performance impact without a significant gain since it is anyway unlikely that the next frame can be transmitted if the previous one was dropped. The memory corruption can be reproduced with the following script which leads to a kernel panic after a few seconds. It basically generates more traffic than a i225 NIC can transmit and pushes it via XDP_REDIRECT from a virtual interface to the physical interface where frames get dropped. #!/bin/bash INTERFACE=enp4s0 INTERFACE_IDX=`cat /sys/class/net/$INTERFACE/ifindex` sudo ip link add dev veth1 type veth peer name veth2 sudo ip link set up $INTERFACE sudo ip link set up veth1 sudo ip link set up veth2 cat << EOF > redirect.bpf.c SEC(\"prog\") int redirect(struct xdp_md *ctx) { return bpf_redirect($INTERFACE_IDX, 0); } char _license[] SEC(\"license\") = \"GPL\"; EOF clang -O2 -g -Wall -target bpf -c redirect.bpf.c -o redirect.bpf.o sudo ip link set veth2 xdp obj redirect.bpf.o cat << EOF > pass.bpf.c SEC(\"prog\") int pass(struct xdp_md *ctx) { return XDP_PASS; } char _license[] SEC(\"license\") = \"GPL\"; EOF clang -O2 -g -Wall -target bpf -c pass.bpf.c -o pass.bpf.o sudo ip link set $INTERFACE xdp obj pass.bpf.o cat << EOF > trafgen.cfg { /* Ethernet Header */ 0xe8, 0x6a, 0x64, 0x41, 0xbf, 0x46, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, const16(ETH_P_IP), /* IPv4 Header */ 0b01000101, 0, # IPv4 version, IHL, TOS const16(1028), # IPv4 total length (UDP length + 20 bytes (IP header)) const16(2), # IPv4 ident 0b01000000, 0, # IPv4 flags, fragmentation off 64, # IPv4 TTL 17, # Protocol UDP csumip(14, 33), # IPv4 checksum /* UDP Header */ 10, 0, 1, 1, # IP Src - adapt as needed 10, 0, 1, 2, # IP Dest - adapt as needed const16(6666), # UDP Src Port const16(6666), # UDP Dest Port const16(1008), # UDP length (UDP header 8 bytes + payload length) csumudp(14, 34), # UDP checksum /* Payload */ fill('W', 1000), } EOF sudo trafgen -i trafgen.cfg -b3000MB -o veth1 --cpp",
      "id": "CVE-2024-26853",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T13:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "ff1892f3-12bf-45cd-89d6-45fb8e01d5c5",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: rds: tcp: Fix use-after-free of net in reqsk_timer_handler(). syzkaller reported a warning of netns tracker [0] followed by KASAN splat [1] and another ref tracker warning [1]. syzkaller could not find a repro, but in the log, the only suspicious sequence was as follows: 18:26:22 executing program 1: r0 = socket$inet6_mptcp(0xa, 0x1, 0x106) ... connect$inet6(r0, &(0x7f0000000080)={0xa, 0x4001, 0x0, @loopback}, 0x1c) (async) The notable thing here is 0x4001 in connect(), which is RDS_TCP_PORT. So, the scenario would be: 1. unshare(CLONE_NEWNET) creates a per netns tcp listener in rds_tcp_listen_init(). 2. syz-executor connect()s to it and creates a reqsk. 3. syz-executor exit()s immediately. 4. netns is dismantled. [0] 5. reqsk timer is fired, and UAF happens while freeing reqsk. [1] 6. listener is freed after RCU grace period. [2] Basically, reqsk assumes that the listener guarantees netns safety until all reqsk timers are expired by holding the listener's refcount. However, this was not the case for kernel sockets. Commit 740ea3c4a0b2 (\"tcp: Clean up kernel listener's reqsk in inet_twsk_purge()\") fixed this issue only for per-netns ehash. Let's apply the same fix for the global ehash. [0]: ref_tracker: net notrefcnt@0000000065449cc3 has 1/1 users at sk_alloc (./include/net/net_namespace.h:337 net/core/sock.c:2146) inet6_create (net/ipv6/af_inet6.c:192 net/ipv6/af_inet6.c:119) __sock_create (net/socket.c:1572) rds_tcp_listen_init (net/rds/tcp_listen.c:279) rds_tcp_init_net (net/rds/tcp.c:577) ops_init (net/core/net_namespace.c:137) setup_net (net/core/net_namespace.c:340) copy_net_ns (net/core/net_namespace.c:497) create_new_namespaces (kernel/nsproxy.c:110) unshare_nsproxy_namespaces (kernel/nsproxy.c:228 (discriminator 4)) ksys_unshare (kernel/fork.c:3429) __x64_sys_unshare (kernel/fork.c:3496) do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129) ... WARNING: CPU: 0 PID: 27 at lib/ref_tracker.c:179 ref_tracker_dir_exit (lib/ref_tracker.c:179) [1]: BUG: KASAN: slab-use-after-free in inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966) Read of size 8 at addr ffff88801b370400 by task swapper/0/0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014 Call Trace: <IRQ> dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1)) print_report (mm/kasan/report.c:378 mm/kasan/report.c:488) kasan_report (mm/kasan/report.c:603) inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966) reqsk_timer_handler (net/ipv4/inet_connection_sock.c:979 net/ipv4/inet_connection_sock.c:1092) call_timer_fn (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/timer.h:127 kernel/time/timer.c:1701) __run_timers.part.0 (kernel/time/timer.c:1752 kernel/time/timer.c:2038) run_timer_softirq (kernel/time/timer.c:2053) __do_softirq (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/irq.h:142 kernel/softirq.c:554) irq_exit_rcu (kernel/softirq.c:427 kernel/softirq.c:632 kernel/softirq.c:644) sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1076 (discriminator 14)) </IRQ> Allocated by task 258 on cpu 0 at 83.612050s: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (mm/kasan/common.c:68) __kasan_slab_alloc (mm/kasan/common.c:343) kmem_cache_alloc (mm/slub.c:3813 mm/slub.c:3860 mm/slub.c:3867) copy_net_ns (./include/linux/slab.h:701 net/core/net_namespace.c:421 net/core/net_namespace.c:480) create_new_namespaces (kernel/nsproxy.c:110) unshare_nsproxy_name ---truncated---",
      "id": "CVE-2024-26865",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T17:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:32Z"
      },
      "bom-ref": "5fcd18bd-5c2c-4f3e-b094-e86ebcee2792",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: spi: lpspi: Avoid potential use-after-free in probe() fsl_lpspi_probe() is allocating/disposing memory manually with spi_alloc_host()/spi_alloc_target(), but uses devm_spi_register_controller(). In case of error after the latter call the memory will be explicitly freed in the probe function by spi_controller_put() call, but used afterwards by \"devm\" management outside probe() (spi_unregister_controller() <- devm_spi_unregister() below). Unable to handle kernel NULL pointer dereference at virtual address 0000000000000070 ... Call trace: kernfs_find_ns kernfs_find_and_get_ns sysfs_remove_group sysfs_remove_groups device_remove_attrs device_del spi_unregister_controller devm_spi_unregister release_nodes devres_release_all really_probe driver_probe_device __device_attach_driver bus_for_each_drv __device_attach device_initial_probe bus_probe_device deferred_probe_work_func process_one_work worker_thread kthread ret_from_fork",
      "id": "CVE-2024-26866",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-27T15:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:33Z"
      },
      "bom-ref": "506b650a-1615-4c18-b33d-258186741065",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to truncate meta inode pages forcely Below race case can cause data corruption: Thread A GC thread - gc_data_segment - ra_data_block - locked meta_inode page - f2fs_inplace_write_data - invalidate_mapping_pages : fail to invalidate meta_inode page due to lock failure or dirty|writeback status - f2fs_submit_page_bio : write last dirty data to old blkaddr - move_data_block - load old data from meta_inode page - f2fs_submit_page_write : write old data to new blkaddr Because invalidate_mapping_pages() will skip invalidating page which has unclear status including locked, dirty, writeback and so on, so we need to use truncate_inode_pages_range() instead of invalidate_mapping_pages() to make sure meta_inode page will be dropped.",
      "id": "CVE-2024-26869",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T17:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:35Z"
      },
      "bom-ref": "9aa6e896-d8d8-4fa7-be11-570abea899f3",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/bridge: adv7511: fix crash on irq during probe Moved IRQ registration down to end of adv7511_probe(). If an IRQ already is pending during adv7511_probe (before adv7511_cec_init) then cec_received_msg_ts could crash using uninitialized data: Unable to handle kernel read from unreadable memory at virtual address 00000000000003d5 Internal error: Oops: 96000004 [#1] PREEMPT_RT SMP Call trace: cec_received_msg_ts+0x48/0x990 [cec] adv7511_cec_irq_process+0x1cc/0x308 [adv7511] adv7511_irq_process+0xd8/0x120 [adv7511] adv7511_irq_handler+0x1c/0x30 [adv7511] irq_thread_fn+0x30/0xa0 irq_thread+0x14c/0x238 kthread+0x190/0x1a8",
      "id": "CVE-2024-26876",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-04T15:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:36Z"
      },
      "bom-ref": "54739e1e-aee0-4dfa-ac32-ebce6cdce48b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: af_bluetooth: Fix deadlock Attemting to do sock_lock on .recvmsg may cause a deadlock as shown bellow, so instead of using sock_sock this uses sk_receive_queue.lock on bt_sock_ioctl to avoid the UAF: INFO: task kworker/u9:1:121 blocked for more than 30 seconds. Not tainted 6.7.6-lemon #183 Workqueue: hci0 hci_rx_work Call Trace: <TASK> __schedule+0x37d/0xa00 schedule+0x32/0xe0 __lock_sock+0x68/0xa0 ? __pfx_autoremove_wake_function+0x10/0x10 lock_sock_nested+0x43/0x50 l2cap_sock_recv_cb+0x21/0xa0 l2cap_recv_frame+0x55b/0x30a0 ? psi_task_switch+0xeb/0x270 ? finish_task_switch.isra.0+0x93/0x2a0 hci_rx_work+0x33a/0x3f0 process_one_work+0x13a/0x2f0 worker_thread+0x2f0/0x410 ? __pfx_worker_thread+0x10/0x10 kthread+0xe0/0x110 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2c/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK>",
      "id": "CVE-2024-26886",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-21T14:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:38Z"
      },
      "bom-ref": "be19a974-bd9b-49c3-b5c6-7d7ea700c830",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Fix double free in SMC transport cleanup path When the generic SCMI code tears down a channel, it calls the chan_free callback function, defined by each transport. Since multiple protocols might share the same transport_info member, chan_free() might want to clean up the same member multiple times within the given SCMI transport implementation. In this case, it is SMC transport. This will lead to a NULL pointer dereference at the second time: | scmi_protocol scmi_dev.1: Enabled polling mode TX channel - prot_id:16 | arm-scmi firmware:scmi: SCMI Notifications - Core Enabled. | arm-scmi firmware:scmi: unable to communicate with SCMI | Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 | Mem abort info: | ESR = 0x0000000096000004 | EC = 0x25: DABT (current EL), IL = 32 bits | SET = 0, FnV = 0 | EA = 0, S1PTW = 0 | FSC = 0x04: level 0 translation fault | Data abort info: | ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 | CM = 0, WnR = 0, TnD = 0, TagAccess = 0 | GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 | user pgtable: 4k pages, 48-bit VAs, pgdp=0000000881ef8000 | [0000000000000000] pgd=0000000000000000, p4d=0000000000000000 | Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP | Modules linked in: | CPU: 4 PID: 1 Comm: swapper/0 Not tainted 6.7.0-rc2-00124-g455ef3d016c9-dirty #793 | Hardware name: FVP Base RevC (DT) | pstate: 61400009 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--) | pc : smc_chan_free+0x3c/0x6c | lr : smc_chan_free+0x3c/0x6c | Call trace: | smc_chan_free+0x3c/0x6c | idr_for_each+0x68/0xf8 | scmi_cleanup_channels.isra.0+0x2c/0x58 | scmi_probe+0x434/0x734 | platform_probe+0x68/0xd8 | really_probe+0x110/0x27c | __driver_probe_device+0x78/0x12c | driver_probe_device+0x3c/0x118 | __driver_attach+0x74/0x128 | bus_for_each_dev+0x78/0xe0 | driver_attach+0x24/0x30 | bus_add_driver+0xe4/0x1e8 | driver_register+0x60/0x128 | __platform_driver_register+0x28/0x34 | scmi_driver_init+0x84/0xc0 | do_one_initcall+0x78/0x33c | kernel_init_freeable+0x2b8/0x51c | kernel_init+0x24/0x130 | ret_from_fork+0x10/0x20 | Code: f0004701 910a0021 aa1403e5 97b91c70 (b9400280) | ---[ end trace 0000000000000000 ]--- Simply check for the struct pointer being NULL before trying to access its members, to avoid this situation. This was found when a transport doesn't really work (for instance no SMC service), the probe routines then tries to clean up, and triggers a crash.",
      "id": "CVE-2024-26893",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-27T15:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:39Z"
      },
      "bom-ref": "1e66048c-3464-4843-ac38-330fdac888e2",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: wfx: fix memory leak when starting AP Kmemleak reported this error: unreferenced object 0xd73d1180 (size 184): comm \"wpa_supplicant\", pid 1559, jiffies 13006305 (age 964.245s) hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 1e 00 01 00 00 00 00 00 ................ backtrace: [<5ca11420>] kmem_cache_alloc+0x20c/0x5ac [<127bdd74>] __alloc_skb+0x144/0x170 [<fb8a5e38>] __netdev_alloc_skb+0x50/0x180 [<0f9fa1d5>] __ieee80211_beacon_get+0x290/0x4d4 [mac80211] [<7accd02d>] ieee80211_beacon_get_tim+0x54/0x18c [mac80211] [<41e25cc3>] wfx_start_ap+0xc8/0x234 [wfx] [<93a70356>] ieee80211_start_ap+0x404/0x6b4 [mac80211] [<a4a661cd>] nl80211_start_ap+0x76c/0x9e0 [cfg80211] [<47bd8b68>] genl_rcv_msg+0x198/0x378 [<453ef796>] netlink_rcv_skb+0xd0/0x130 [<6b7c977a>] genl_rcv+0x34/0x44 [<66b2d04d>] netlink_unicast+0x1b4/0x258 [<f965b9b6>] netlink_sendmsg+0x1e8/0x428 [<aadb8231>] ____sys_sendmsg+0x1e0/0x274 [<d2b5212d>] ___sys_sendmsg+0x80/0xb4 [<69954f45>] __sys_sendmsg+0x64/0xa8 unreferenced object 0xce087000 (size 1024): comm \"wpa_supplicant\", pid 1559, jiffies 13006305 (age 964.246s) hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 10 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00 ...@............ backtrace: [<9a993714>] __kmalloc_track_caller+0x230/0x600 [<f83ea192>] kmalloc_reserve.constprop.0+0x30/0x74 [<a2c61343>] __alloc_skb+0xa0/0x170 [<fb8a5e38>] __netdev_alloc_skb+0x50/0x180 [<0f9fa1d5>] __ieee80211_beacon_get+0x290/0x4d4 [mac80211] [<7accd02d>] ieee80211_beacon_get_tim+0x54/0x18c [mac80211] [<41e25cc3>] wfx_start_ap+0xc8/0x234 [wfx] [<93a70356>] ieee80211_start_ap+0x404/0x6b4 [mac80211] [<a4a661cd>] nl80211_start_ap+0x76c/0x9e0 [cfg80211] [<47bd8b68>] genl_rcv_msg+0x198/0x378 [<453ef796>] netlink_rcv_skb+0xd0/0x130 [<6b7c977a>] genl_rcv+0x34/0x44 [<66b2d04d>] netlink_unicast+0x1b4/0x258 [<f965b9b6>] netlink_sendmsg+0x1e8/0x428 [<aadb8231>] ____sys_sendmsg+0x1e0/0x274 [<d2b5212d>] ___sys_sendmsg+0x80/0xb4 However, since the kernel is build optimized, it seems the stack is not accurate. It appears the issue is related to wfx_set_mfp_ap(). The issue is obvious in this function: memory allocated by ieee80211_beacon_get() is never released. Fixing this leak makes kmemleak happy.",
      "id": "CVE-2024-26896",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-21T14:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_BLK_DEV_MD not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6f33c9bb-6d9e-43f4-a8a6-bca3bd0a76ad",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: md: fix kmemleak of rdev->serial If kobject_add() is fail in bind_rdev_to_array(), 'rdev->serial' will be alloc not be freed, and kmemleak occurs. unreferenced object 0xffff88815a350000 (size 49152): comm \"mdadm\", pid 789, jiffies 4294716910 hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc f773277a): [<0000000058b0a453>] kmemleak_alloc+0x61/0xe0 [<00000000366adf14>] __kmalloc_large_node+0x15e/0x270 [<000000002e82961b>] __kmalloc_node.cold+0x11/0x7f [<00000000f206d60a>] kvmalloc_node+0x74/0x150 [<0000000034bf3363>] rdev_init_serial+0x67/0x170 [<0000000010e08fe9>] mddev_create_serial_pool+0x62/0x220 [<00000000c3837bf0>] bind_rdev_to_array+0x2af/0x630 [<0000000073c28560>] md_add_new_disk+0x400/0x9f0 [<00000000770e30ff>] md_ioctl+0x15bf/0x1c10 [<000000006cfab718>] blkdev_ioctl+0x191/0x3f0 [<0000000085086a11>] vfs_ioctl+0x22/0x60 [<0000000018b656fe>] __x64_sys_ioctl+0xba/0xe0 [<00000000e54e675e>] do_syscall_64+0x71/0x150 [<000000008b0ad622>] entry_SYSCALL_64_after_hwframe+0x6c/0x74",
      "id": "CVE-2024-26900",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:41Z"
      },
      "bom-ref": "61625d02-4f9e-44c0-a75f-15ac783cb3a5",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: perf: RISCV: Fix panic on pmu overflow handler (1 << idx) of int is not desired when setting bits in unsigned long overflowed_ctrs, use BIT() instead. This panic happens when running 'perf record -e branches' on sophgo sg2042. [ 273.311852] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000098 [ 273.320851] Oops [#1] [ 273.323179] Modules linked in: [ 273.326303] CPU: 0 PID: 1475 Comm: perf Not tainted 6.6.0-rc3+ #9 [ 273.332521] Hardware name: Sophgo Mango (DT) [ 273.336878] epc : riscv_pmu_ctr_get_width_mask+0x8/0x62 [ 273.342291] ra : pmu_sbi_ovf_handler+0x2e0/0x34e [ 273.347091] epc : ffffffff80aecd98 ra : ffffffff80aee056 sp : fffffff6e36928b0 [ 273.354454] gp : ffffffff821f82d0 tp : ffffffd90c353200 t0 : 0000002ade4f9978 [ 273.361815] t1 : 0000000000504d55 t2 : ffffffff8016cd8c s0 : fffffff6e3692a70 [ 273.369180] s1 : 0000000000000020 a0 : 0000000000000000 a1 : 00001a8e81800000 [ 273.376540] a2 : 0000003c00070198 a3 : 0000003c00db75a4 a4 : 0000000000000015 [ 273.383901] a5 : ffffffd7ff8804b0 a6 : 0000000000000015 a7 : 000000000000002a [ 273.391327] s2 : 000000000000ffff s3 : 0000000000000000 s4 : ffffffd7ff8803b0 [ 273.398773] s5 : 0000000000504d55 s6 : ffffffd905069800 s7 : ffffffff821fe210 [ 273.406139] s8 : 000000007fffffff s9 : ffffffd7ff8803b0 s10: ffffffd903f29098 [ 273.413660] s11: 0000000080000000 t3 : 0000000000000003 t4 : ffffffff8017a0ca [ 273.421022] t5 : ffffffff8023cfc2 t6 : ffffffd9040780e8 [ 273.426437] status: 0000000200000100 badaddr: 0000000000000098 cause: 000000000000000d [ 273.434512] [<ffffffff80aecd98>] riscv_pmu_ctr_get_width_mask+0x8/0x62 [ 273.441169] [<ffffffff80076bd8>] handle_percpu_devid_irq+0x98/0x1ee [ 273.447562] [<ffffffff80071158>] generic_handle_domain_irq+0x28/0x36 [ 273.454151] [<ffffffff8047a99a>] riscv_intc_irq+0x36/0x4e [ 273.459659] [<ffffffff80c944de>] handle_riscv_irq+0x4a/0x74 [ 273.465442] [<ffffffff80c94c48>] do_irq+0x62/0x92 [ 273.470360] Code: 0420 60a2 6402 5529 0141 8082 0013 0000 0013 0000 (6d5c) b783 [ 273.477921] ---[ end trace 0000000000000000 ]--- [ 273.482630] Kernel panic - not syncing: Fatal exception in interrupt",
      "id": "CVE-2024-26902",
      "published": "2024-04-17T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "c9e55c79-7df6-4da8-a8f2-805a6c3236fb",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_debug_files_proc_show() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-26928",
      "published": "2024-04-28T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "d98ad4e9-93d5-4711-8ede-843f72188178",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: zoned: fix use-after-free in do_zone_finish() Shinichiro reported the following use-after-free triggered by the device replace operation in fstests btrfs/070. BTRFS info (device nullb1): scrub: finished on devid 1 with status: 0 ================================================================== BUG: KASAN: slab-use-after-free in do_zone_finish+0x91a/0xb90 [btrfs] Read of size 8 at addr ffff8881543c8060 by task btrfs-cleaner/3494007 CPU: 0 PID: 3494007 Comm: btrfs-cleaner Tainted: G W 6.8.0-rc5-kts #1 Hardware name: Supermicro Super Server/X11SPi-TF, BIOS 3.3 02/21/2020 Call Trace: <TASK> dump_stack_lvl+0x5b/0x90 print_report+0xcf/0x670 ? __virt_addr_valid+0x200/0x3e0 kasan_report+0xd8/0x110 ? do_zone_finish+0x91a/0xb90 [btrfs] ? do_zone_finish+0x91a/0xb90 [btrfs] do_zone_finish+0x91a/0xb90 [btrfs] btrfs_delete_unused_bgs+0x5e1/0x1750 [btrfs] ? __pfx_btrfs_delete_unused_bgs+0x10/0x10 [btrfs] ? btrfs_put_root+0x2d/0x220 [btrfs] ? btrfs_clean_one_deleted_snapshot+0x299/0x430 [btrfs] cleaner_kthread+0x21e/0x380 [btrfs] ? __pfx_cleaner_kthread+0x10/0x10 [btrfs] kthread+0x2e3/0x3c0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x31/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30 </TASK> Allocated by task 3493983: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 btrfs_alloc_device+0xb3/0x4e0 [btrfs] device_list_add.constprop.0+0x993/0x1630 [btrfs] btrfs_scan_one_device+0x219/0x3d0 [btrfs] btrfs_control_ioctl+0x26e/0x310 [btrfs] __x64_sys_ioctl+0x134/0x1b0 do_syscall_64+0x99/0x190 entry_SYSCALL_64_after_hwframe+0x6e/0x76 Freed by task 3494056: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3f/0x60 poison_slab_object+0x102/0x170 __kasan_slab_free+0x32/0x70 kfree+0x11b/0x320 btrfs_rm_dev_replace_free_srcdev+0xca/0x280 [btrfs] btrfs_dev_replace_finishing+0xd7e/0x14f0 [btrfs] btrfs_dev_replace_by_ioctl+0x1286/0x25a0 [btrfs] btrfs_ioctl+0xb27/0x57d0 [btrfs] __x64_sys_ioctl+0x134/0x1b0 do_syscall_64+0x99/0x190 entry_SYSCALL_64_after_hwframe+0x6e/0x76 The buggy address belongs to the object at ffff8881543c8000 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 96 bytes inside of freed 1024-byte region [ffff8881543c8000, ffff8881543c8400) The buggy address belongs to the physical page: page:00000000fe2c1285 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1543c8 head:00000000fe2c1285 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0 flags: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff) page_type: 0xffffffff() raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002 raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb This UAF happens because we're accessing stale zone information of a already removed btrfs_device in do_zone_finish(). The sequence of events is as follows: btrfs_dev_replace_start btrfs_scrub_dev btrfs_dev_replace_finishing btrfs_dev_replace_update_device_in_mapping_tree <-- devices replaced btrfs_rm_dev_replace_free_srcdev btrfs_free_device <-- device freed cleaner_kthread btrfs_delete_unused_bgs btrfs_zone_finish do_zone_finish <-- refers the freed device The reason for this is that we're using a ---truncated---",
      "id": "CVE-2024-26944",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-14T14:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:42Z"
      },
      "bom-ref": "3fc6d236-1bd5-4cab-87c8-e7d6f7a38c7b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: iaa - Fix nr_cpus < nr_iaa case If nr_cpus < nr_iaa, the calculated cpus_per_iaa will be 0, which causes a divide-by-0 in rebalance_wq_table(). Make sure cpus_per_iaa is 1 in that case, and also in the nr_iaa == 0 case, even though cpus_per_iaa is never used if nr_iaa == 0, for paranoia.",
      "id": "CVE-2024-26945",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "531252d5-5e83-483e-91d0-f53d355d81c6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu/pm: Fix NULL pointer dereference when get power limit Because powerplay_table initialization is skipped under sriov case, We check and set default lower and upper OD value if powerplay_table is NULL.",
      "id": "CVE-2024-26949",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "867bcc42-7895-4800-b43a-5ba2ce284470",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab-out-of-bounds in smb_strndup_from_utf16() If ->NameOffset of smb2_create_req is smaller than Buffer offset of smb2_create_req, slab-out-of-bounds read can happen from smb2_open. This patch set the minimum value of the name offset to the buffer offset to validate name length of smb2_create_req().",
      "id": "CVE-2024-26954",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-04T16:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:44Z"
      },
      "bom-ref": "d07f28cd-45a2-4405-b3bb-1ae51dbdb1b4",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: dm-raid456, md/raid456: fix a deadlock for dm-raid456 while io concurrent with reshape For raid456, if reshape is still in progress, then IO across reshape position will wait for reshape to make progress. However, for dm-raid, in following cases reshape will never make progress hence IO will hang: 1) the array is read-only; 2) MD_RECOVERY_WAIT is set; 3) MD_RECOVERY_FROZEN is set; After commit c467e97f079f (\"md/raid6: use valid sector values to determine if an I/O should wait on the reshape\") fix the problem that IO across reshape position doesn't wait for reshape, the dm-raid test shell/lvconvert-raid-reshape.sh start to hang: [root@fedora ~]# cat /proc/979/stack [<0>] wait_woken+0x7d/0x90 [<0>] raid5_make_request+0x929/0x1d70 [raid456] [<0>] md_handle_request+0xc2/0x3b0 [md_mod] [<0>] raid_map+0x2c/0x50 [dm_raid] [<0>] __map_bio+0x251/0x380 [dm_mod] [<0>] dm_submit_bio+0x1f0/0x760 [dm_mod] [<0>] __submit_bio+0xc2/0x1c0 [<0>] submit_bio_noacct_nocheck+0x17f/0x450 [<0>] submit_bio_noacct+0x2bc/0x780 [<0>] submit_bio+0x70/0xc0 [<0>] mpage_readahead+0x169/0x1f0 [<0>] blkdev_readahead+0x18/0x30 [<0>] read_pages+0x7c/0x3b0 [<0>] page_cache_ra_unbounded+0x1ab/0x280 [<0>] force_page_cache_ra+0x9e/0x130 [<0>] page_cache_sync_ra+0x3b/0x110 [<0>] filemap_get_pages+0x143/0xa30 [<0>] filemap_read+0xdc/0x4b0 [<0>] blkdev_read_iter+0x75/0x200 [<0>] vfs_read+0x272/0x460 [<0>] ksys_read+0x7a/0x170 [<0>] __x64_sys_read+0x1c/0x30 [<0>] do_syscall_64+0xc6/0x230 [<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74 This is because reshape can't make progress. For md/raid, the problem doesn't exist because register new sync_thread doesn't rely on the IO to be done any more: 1) If array is read-only, it can switch to read-write by ioctl/sysfs; 2) md/raid never set MD_RECOVERY_WAIT; 3) If MD_RECOVERY_FROZEN is set, mddev_suspend() doesn't hold 'reconfig_mutex', hence it can be cleared and reshape can continue by sysfs api 'sync_action'. However, I'm not sure yet how to avoid the problem in dm-raid yet. This patch on the one hand make sure raid_message() can't change sync_thread() through raid_message() after presuspend(), on the other hand detect the above 3 cases before wait for IO do be done in dm_suspend(), and let dm-raid requeue those IO.",
      "id": "CVE-2024-26962",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-23T13:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:45Z"
      },
      "bom-ref": "517b05e1-19bd-48ff-a3ab-cb5f1ee3b039",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: serial: max310x: fix NULL pointer dereference in I2C instantiation When trying to instantiate a max14830 device from userspace: echo max14830 0x60 > /sys/bus/i2c/devices/i2c-2/new_device we get the following error: Unable to handle kernel NULL pointer dereference at virtual address... ... Call trace: max310x_i2c_probe+0x48/0x170 [max310x] i2c_device_probe+0x150/0x2a0 ... Add check for validity of devtype to prevent the error, and abort probe with a meaningful error message.",
      "id": "CVE-2024-26978",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "b83bbcb0-d239-4b57-83c5-aa763b2d07c8",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Squashfs: check the inode number is not the invalid value of zero Syskiller has produced an out of bounds access in fill_meta_index(). That out of bounds access is ultimately caused because the inode has an inode number with the invalid value of zero, which was not checked. The reason this causes the out of bounds access is due to following sequence of events: 1. Fill_meta_index() is called to allocate (via empty_meta_index()) and fill a metadata index. It however suffers a data read error and aborts, invalidating the newly returned empty metadata index. It does this by setting the inode number of the index to zero, which means unused (zero is not a valid inode number). 2. When fill_meta_index() is subsequently called again on another read operation, locate_meta_index() returns the previous index because it matches the inode number of 0. Because this index has been returned it is expected to have been filled, and because it hasn't been, an out of bounds access is performed. This patch adds a sanity check which checks that the inode number is not zero when the inode is created and returns -EINVAL if it is. [phillip@squashfs.org.uk: whitespace fix]",
      "id": "CVE-2024-26982",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-16T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "6ac6d9ff-0a21-4098-81fc-d8e03117e148",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bootconfig: use memblock_free_late to free xbc memory to buddy On the time to free xbc memory in xbc_exit(), memblock may has handed over memory to buddy allocator. So it doesn't make sense to free memory back to memblock. memblock_free() called by xbc_exit() even causes UAF bugs on architectures with CONFIG_ARCH_KEEP_MEMBLOCK disabled like x86. Following KASAN logs shows this case. This patch fixes the xbc memory free problem by calling memblock_free() in early xbc init error rewind path and calling memblock_free_late() in xbc exit path to free memory to buddy allocator. [ 9.410890] ================================================================== [ 9.418962] BUG: KASAN: use-after-free in memblock_isolate_range+0x12d/0x260 [ 9.426850] Read of size 8 at addr ffff88845dd30000 by task swapper/0/1 [ 9.435901] CPU: 9 PID: 1 Comm: swapper/0 Tainted: G U 6.9.0-rc3-00208-g586b5dfb51b9 #5 [ 9.446403] Hardware name: Intel Corporation RPLP LP5 (CPU:RaptorLake)/RPLP LP5 (ID:13), BIOS IRPPN02.01.01.00.00.19.015.D-00000000 Dec 28 2023 [ 9.460789] Call Trace: [ 9.463518] <TASK> [ 9.465859] dump_stack_lvl+0x53/0x70 [ 9.469949] print_report+0xce/0x610 [ 9.473944] ? __virt_addr_valid+0xf5/0x1b0 [ 9.478619] ? memblock_isolate_range+0x12d/0x260 [ 9.483877] kasan_report+0xc6/0x100 [ 9.487870] ? memblock_isolate_range+0x12d/0x260 [ 9.493125] memblock_isolate_range+0x12d/0x260 [ 9.498187] memblock_phys_free+0xb4/0x160 [ 9.502762] ? __pfx_memblock_phys_free+0x10/0x10 [ 9.508021] ? mutex_unlock+0x7e/0xd0 [ 9.512111] ? __pfx_mutex_unlock+0x10/0x10 [ 9.516786] ? kernel_init_freeable+0x2d4/0x430 [ 9.521850] ? __pfx_kernel_init+0x10/0x10 [ 9.526426] xbc_exit+0x17/0x70 [ 9.529935] kernel_init+0x38/0x1e0 [ 9.533829] ? _raw_spin_unlock_irq+0xd/0x30 [ 9.538601] ret_from_fork+0x2c/0x50 [ 9.542596] ? __pfx_kernel_init+0x10/0x10 [ 9.547170] ret_from_fork_asm+0x1a/0x30 [ 9.551552] </TASK> [ 9.555649] The buggy address belongs to the physical page: [ 9.561875] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x1 pfn:0x45dd30 [ 9.570821] flags: 0x200000000000000(node=0|zone=2) [ 9.576271] page_type: 0xffffffff() [ 9.580167] raw: 0200000000000000 ffffea0011774c48 ffffea0012ba1848 0000000000000000 [ 9.588823] raw: 0000000000000001 0000000000000000 00000000ffffffff 0000000000000000 [ 9.597476] page dumped because: kasan: bad access detected [ 9.605362] Memory state around the buggy address: [ 9.610714] ffff88845dd2ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 9.618786] ffff88845dd2ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 9.626857] >ffff88845dd30000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.634930] ^ [ 9.638534] ffff88845dd30080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.646605] ffff88845dd30100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff [ 9.654675] ==================================================================",
      "id": "CVE-2024-26983",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-23T14:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ARCH_MEDIATEK is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "65931880-ce32-4404-ac3e-400469374737",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: clk: mediatek: Do a runtime PM get on controllers during probe mt8183-mfgcfg has a mutual dependency with genpd during the probing stage, which leads to a deadlock in the following call stack: CPU0: genpd_lock --> clk_prepare_lock genpd_power_off_work_fn() genpd_lock() generic_pm_domain::power_off() clk_unprepare() clk_prepare_lock() CPU1: clk_prepare_lock --> genpd_lock clk_register() __clk_core_init() clk_prepare_lock() clk_pm_runtime_get() genpd_lock() Do a runtime PM get at the probe function to make sure clk_register() won't acquire the genpd lock. Instead of only modifying mt8183-mfgcfg, do this on all mediatek clock controller probings because we don't believe this would cause any regression. Verified on MT8183 and MT8192 Chromebooks.",
      "id": "CVE-2024-27002",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-23T19:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:47Z"
      },
      "bom-ref": "fe56abaa-6ca0-44e4-b9db-9e92e7d200d9",
      "cwes": [
        362,
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: interconnect: Don't access req_list while it's being manipulated The icc_lock mutex was split into separate icc_lock and icc_bw_lock mutexes in [1] to avoid lockdep splats. However, this didn't adequately protect access to icc_node::req_list. The icc_set_bw() function will eventually iterate over req_list while only holding icc_bw_lock, but req_list can be modified while only holding icc_lock. This causes races between icc_set_bw(), of_icc_get(), and icc_put(). Example A: CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&icc_bw_lock); icc_put(path_b) mutex_lock(&icc_lock); aggregate_requests() hlist_for_each_entry(r, ... hlist_del(... <r = invalid pointer> Example B: CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&icc_bw_lock); path_b = of_icc_get() of_icc_get_by_index() mutex_lock(&icc_lock); path_find() path_init() aggregate_requests() hlist_for_each_entry(r, ... hlist_add_head(... <r = invalid pointer> Fix this by ensuring icc_bw_lock is always held before manipulating icc_node::req_list. The additional places icc_bw_lock is held don't perform any memory allocations, so we should still be safe from the original lockdep splats that motivated the separate locks. [1] commit af42269c3523 (\"interconnect: Fix locking for runpm vs reclaim\")",
      "id": "CVE-2024-27005",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T18:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:48Z"
      },
      "bom-ref": "650facca-458a-4d32-a3b5-dd5cbcd05b91",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/sched: Fix mirred deadlock on device recursion When the mirred action is used on a classful egress qdisc and a packet is mirrored or redirected to self we hit a qdisc lock deadlock. See trace below. [..... other info removed for brevity....] [ 82.890906] [ 82.890906] ============================================ [ 82.890906] WARNING: possible recursive locking detected [ 82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G W [ 82.890906] -------------------------------------------- [ 82.890906] ping/418 is trying to acquire lock: [ 82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at: __dev_queue_xmit+0x1778/0x3550 [ 82.890906] [ 82.890906] but task is already holding lock: [ 82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at: __dev_queue_xmit+0x1778/0x3550 [ 82.890906] [ 82.890906] other info that might help us debug this: [ 82.890906] Possible unsafe locking scenario: [ 82.890906] [ 82.890906] CPU0 [ 82.890906] ---- [ 82.890906] lock(&sch->q.lock); [ 82.890906] lock(&sch->q.lock); [ 82.890906] [ 82.890906] *** DEADLOCK *** [ 82.890906] [..... other info removed for brevity....] Example setup (eth0->eth0) to recreate tc qdisc add dev eth0 root handle 1: htb default 30 tc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\ action mirred egress redirect dev eth0 Another example(eth0->eth1->eth0) to recreate tc qdisc add dev eth0 root handle 1: htb default 30 tc filter add dev eth0 handle 1: protocol ip prio 2 matchall \\ action mirred egress redirect dev eth1 tc qdisc add dev eth1 root handle 1: htb default 30 tc filter add dev eth1 handle 1: protocol ip prio 2 matchall \\ action mirred egress redirect dev eth0 We fix this by adding an owner field (CPU id) to struct Qdisc set after root qdisc is entered. When the softirq enters it a second time, if the qdisc owner is the same CPU, the packet is dropped to break the loop.",
      "id": "CVE-2024-27010",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-23T14:05:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:50Z"
      },
      "bom-ref": "ea149723-f50b-4a3d-b176-014aa3818774",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: fix memleak in map from abort path The delete set command does not rely on the transaction object for element removal, therefore, a combination of delete element + delete set from the abort path could result in restoring twice the refcount of the mapping. Check for inactive element in the next generation for the delete element command in the abort path, skip restoring state if next generation bit has been already cleared. This is similar to the activate logic using the set walk iterator. [ 6170.286929] ------------[ cut here ]------------ [ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.287071] Modules linked in: [...] [ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365 [ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f [ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202 [ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000 [ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750 [ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55 [ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10 [ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100 [ 6170.287940] FS: 0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000 [ 6170.287948] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0 [ 6170.287962] Call Trace: [ 6170.287967] <TASK> [ 6170.287973] ? __warn+0x9f/0x1a0 [ 6170.287986] ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.288092] ? report_bug+0x1b1/0x1e0 [ 6170.287986] ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.288092] ? report_bug+0x1b1/0x1e0 [ 6170.288104] ? handle_bug+0x3c/0x70 [ 6170.288112] ? exc_invalid_op+0x17/0x40 [ 6170.288120] ? asm_exc_invalid_op+0x1a/0x20 [ 6170.288132] ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables] [ 6170.288243] ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables] [ 6170.288366] ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables] [ 6170.288483] nf_tables_trans_destroy_work+0x588/0x590 [nf_tables]",
      "id": "CVE-2024-27011",
      "published": "2024-05-01T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-23T14:06:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:51Z"
      },
      "bom-ref": "82e392a3-4a33-4389-8ed8-b8519022ee1a",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid potential panic during recovery During recovery, if FAULT_BLOCK is on, it is possible that f2fs_reserve_new_block() will return -ENOSPC during recovery, then it may trigger panic. Also, if fault injection rate is 1 and only FAULT_BLOCK fault type is on, it may encounter deadloop in loop of block reservation. Let's change as below to fix these issues: - remove bug_on() to avoid panic. - limit the loop count of block reservation to avoid potential deadloop.",
      "id": "CVE-2024-27032",
      "published": "2024-05-01T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T18:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "81a62937-7010-4c3e-8d9c-7a4ff191cf4a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix NULL checks for adev->dm.dc in amdgpu_dm_fini() Since 'adev->dm.dc' in amdgpu_dm_fini() might turn out to be NULL before the call to dc_enable_dmub_notifications(), check beforehand to ensure there will not be a possible NULL-ptr-deref there. Also, since commit 1e88eb1b2c25 (\"drm/amd/display: Drop CONFIG_DRM_AMD_DC_HDCP\") there are two separate checks for NULL in 'adev->dm.dc' before dc_deinit_callbacks() and dc_dmub_srv_destroy(). Clean up by combining them all under one 'if'. Found by Linux Verification Center (linuxtesting.org) with static analysis tool SVACE.",
      "id": "CVE-2024-27041",
      "published": "2024-05-01T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T18:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:53Z"
      },
      "bom-ref": "a468afac-9386-4b7c-82c8-78779a7828dd",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nouveau: lock the client object tree. It appears the client object tree has no locking unless I've missed something else. Fix races around adding/removing client objects, mostly vram bar mappings. 4562.099306] general protection fault, probably for non-canonical address 0x6677ed422bceb80c: 0000 [#1] PREEMPT SMP PTI [ 4562.099314] CPU: 2 PID: 23171 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27 [ 4562.099324] Hardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF, BIOS F8 11/05/2021 [ 4562.099330] RIP: 0010:nvkm_object_search+0x1d/0x70 [nouveau] [ 4562.099503] Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 48 89 f8 48 85 f6 74 39 48 8b 87 a0 00 00 00 48 85 c0 74 12 <48> 8b 48 f8 48 39 ce 73 15 48 8b 40 10 48 85 c0 75 ee 48 c7 c0 fe [ 4562.099506] RSP: 0000:ffffa94cc420bbf8 EFLAGS: 00010206 [ 4562.099512] RAX: 6677ed422bceb814 RBX: ffff98108791f400 RCX: ffff9810f26b8f58 [ 4562.099517] RDX: 0000000000000000 RSI: ffff9810f26b9158 RDI: ffff98108791f400 [ 4562.099519] RBP: ffff9810f26b9158 R08: 0000000000000000 R09: 0000000000000000 [ 4562.099521] R10: ffffa94cc420bc48 R11: 0000000000000001 R12: ffff9810f02a7cc0 [ 4562.099526] R13: 0000000000000000 R14: 00000000000000ff R15: 0000000000000007 [ 4562.099528] FS: 00007f629c5017c0(0000) GS:ffff98142c700000(0000) knlGS:0000000000000000 [ 4562.099534] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 4562.099536] CR2: 00007f629a882000 CR3: 000000017019e004 CR4: 00000000003706f0 [ 4562.099541] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 4562.099542] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 4562.099544] Call Trace: [ 4562.099555] <TASK> [ 4562.099573] ? die_addr+0x36/0x90 [ 4562.099583] ? exc_general_protection+0x246/0x4a0 [ 4562.099593] ? asm_exc_general_protection+0x26/0x30 [ 4562.099600] ? nvkm_object_search+0x1d/0x70 [nouveau] [ 4562.099730] nvkm_ioctl+0xa1/0x250 [nouveau] [ 4562.099861] nvif_object_map_handle+0xc8/0x180 [nouveau] [ 4562.099986] nouveau_ttm_io_mem_reserve+0x122/0x270 [nouveau] [ 4562.100156] ? dma_resv_test_signaled+0x26/0xb0 [ 4562.100163] ttm_bo_vm_fault_reserved+0x97/0x3c0 [ttm] [ 4562.100182] ? __mutex_unlock_slowpath+0x2a/0x270 [ 4562.100189] nouveau_ttm_fault+0x69/0xb0 [nouveau] [ 4562.100356] __do_fault+0x32/0x150 [ 4562.100362] do_fault+0x7c/0x560 [ 4562.100369] __handle_mm_fault+0x800/0xc10 [ 4562.100382] handle_mm_fault+0x17c/0x3e0 [ 4562.100388] do_user_addr_fault+0x208/0x860 [ 4562.100395] exc_page_fault+0x7f/0x200 [ 4562.100402] asm_exc_page_fault+0x26/0x30 [ 4562.100412] RIP: 0033:0x9b9870 [ 4562.100419] Code: 85 a8 f7 ff ff 8b 8d 80 f7 ff ff 89 08 e9 18 f2 ff ff 0f 1f 84 00 00 00 00 00 44 89 32 e9 90 fa ff ff 0f 1f 84 00 00 00 00 00 <44> 89 32 e9 f8 f1 ff ff 0f 1f 84 00 00 00 00 00 66 44 89 32 e9 e7 [ 4562.100422] RSP: 002b:00007fff9ba2dc70 EFLAGS: 00010246 [ 4562.100426] RAX: 0000000000000004 RBX: 000000000dd65e10 RCX: 000000fff0000000 [ 4562.100428] RDX: 00007f629a882000 RSI: 00007f629a882000 RDI: 0000000000000066 [ 4562.100432] RBP: 00007fff9ba2e570 R08: 0000000000000000 R09: 0000000123ddf000 [ 4562.100434] R10: 0000000000000001 R11: 0000000000000246 R12: 000000007fffffff [ 4562.100436] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000 [ 4562.100446] </TASK> [ 4562.100448] Modules linked in: nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink cmac bnep sunrpc iwlmvm intel_rapl_msr intel_rapl_common snd_sof_pci_intel_cnl x86_pkg_temp_thermal intel_powerclamp snd_sof_intel_hda_common mac80211 coretemp snd_soc_acpi_intel_match kvm_intel snd_soc_acpi snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda_mlink ---truncated---",
      "id": "CVE-2024-27062",
      "published": "2024-05-01T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_NTFS3_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "4561177f-b550-4f79-8b6a-06a91d6cc0ba",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fixed overflow check in mi_enum_attr()",
      "id": "CVE-2024-27407",
      "published": "2024-05-17T12:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T15:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:54Z"
      },
      "bom-ref": "63669ad1-9566-4c4e-be21-d5010038bac6",
      "description": "In the Linux kernel, the following vulnerability has been resolved: vfio/pci: Disable auto-enable of exclusive INTx IRQ Currently for devices requiring masking at the irqchip for INTx, ie. devices without DisINTx support, the IRQ is enabled in request_irq() and subsequently disabled as necessary to align with the masked status flag. This presents a window where the interrupt could fire between these events, resulting in the IRQ incrementing the disable depth twice. This would be unrecoverable for a user since the masked flag prevents nested enables through vfio. Instead, invert the logic using IRQF_NO_AUTOEN such that exclusive INTx is never auto-enabled, then unmask as required.",
      "id": "CVE-2024-27437",
      "published": "2024-04-05T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-27T21:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_BTRFS_FS is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "a61bc177-b11c-4e61-923a-40c85119f72d",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix deadlock with fiemap and extent locking While working on the patchset to remove extent locking I got a lockdep splat with fiemap and pagefaulting with my new extent lock replacement lock. This deadlock exists with our normal code, we just don't have lockdep annotations with the extent locking so we've never noticed it. Since we're copying the fiemap extent to user space on every iteration we have the chance of pagefaulting. Because we hold the extent lock for the entire range we could mkwrite into a range in the file that we have mmap'ed. This would deadlock with the following stack trace [<0>] lock_extent+0x28d/0x2f0 [<0>] btrfs_page_mkwrite+0x273/0x8a0 [<0>] do_page_mkwrite+0x50/0xb0 [<0>] do_fault+0xc1/0x7b0 [<0>] __handle_mm_fault+0x2fa/0x460 [<0>] handle_mm_fault+0xa4/0x330 [<0>] do_user_addr_fault+0x1f4/0x800 [<0>] exc_page_fault+0x7c/0x1e0 [<0>] asm_exc_page_fault+0x26/0x30 [<0>] rep_movs_alternative+0x33/0x70 [<0>] _copy_to_user+0x49/0x70 [<0>] fiemap_fill_next_extent+0xc8/0x120 [<0>] emit_fiemap_extent+0x4d/0xa0 [<0>] extent_fiemap+0x7f8/0xad0 [<0>] btrfs_fiemap+0x49/0x80 [<0>] __x64_sys_ioctl+0x3e1/0xb50 [<0>] do_syscall_64+0x94/0x1a0 [<0>] entry_SYSCALL_64_after_hwframe+0x6e/0x76 I wrote an fstest to reproduce this deadlock without my replacement lock and verified that the deadlock exists with our existing locking. To fix this simply don't take the extent lock for the entire duration of the fiemap. This is safe in general because we keep track of where we are when we're searching the tree, so if an ordered extent updates in the middle of our fiemap call we'll still emit the correct extents because we know what offset we were on before. The only place we maintain the lock is searching delalloc. Since the delalloc stuff can change during writeback we want to lock the extent range so we have a consistent view of delalloc at the time we're checking to see if we need to set the delalloc flag. With this patch applied we no longer deadlock with my testcase.",
      "id": "CVE-2024-35784",
      "published": "2024-05-17T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-10T18:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:56Z"
      },
      "bom-ref": "36ef6c4b-bd63-4539-b7b7-0560ef36bf89",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "id": "CVE-2024-35788",
      "published": "2024-05-17T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "78c57472-3f80-420f-b3f3-83614f412954",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: altmodes/displayport: create sysfs nodes as driver's default device attribute group The DisplayPort driver's sysfs nodes may be present to the userspace before typec_altmode_set_drvdata() completes in dp_altmode_probe. This means that a sysfs read can trigger a NULL pointer error by deferencing dp->hpd in hpd_show or dp->lock in pin_assignment_show, as dev_get_drvdata() returns NULL in those cases. Remove manual sysfs node creation in favor of adding attribute group as default for devices bound to the driver. The ATTRIBUTE_GROUPS() macro is not used here otherwise the path to the sysfs nodes is no longer compliant with the ABI.",
      "id": "CVE-2024-35790",
      "published": "2024-05-17T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:48:59Z"
      },
      "bom-ref": "e2fa38cf-e8af-462b-a9a7-b6ba14f94610",
      "description": "In the Linux kernel, the following vulnerability has been resolved: iommu/vt-d: Use device rbtree in iopf reporting path The existing I/O page fault handler currently locates the PCI device by calling pci_get_domain_bus_and_slot(). This function searches the list of all PCI devices until the desired device is found. To improve lookup efficiency, replace it with device_rbtree_find() to search the device within the probed device rbtree. The I/O page fault is initiated by the device, which does not have any synchronization mechanism with the software to ensure that the device stays in the probed device tree. Theoretically, a device could be released by the IOMMU subsystem after device_rbtree_find() and before iopf_get_dev_fault_param(), which would cause a use-after-free problem. Add a mutex to synchronize the I/O page fault reporting path and the IOMMU release device path. This lock doesn't introduce any performance overhead, as the conflict between I/O page fault reporting and device releasing is very rare.",
      "id": "CVE-2024-35843",
      "published": "2024-05-17T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-07T19:05:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "d7c56bbe-f4d7-4c3a-b074-81d75963eb24",
      "cwes": [
        667
      ],
      "description": "A deadlock flaw was found in the Linux kernel\u2019s BPF subsystem. This flaw allows a local user to potentially crash the system.",
      "id": "CVE-2023-0160",
      "published": "2023-07-18T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "504adfd8-3f80-4848-afd5-5f2012ae8a54",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in rawv6_push_pending_frames in net/ipv6/raw.c in the network subcomponent in the Linux kernel. This flaw causes the system to crash.",
      "id": "CVE-2023-0394",
      "published": "2023-01-26T21:18:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-31T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "ae805ac0-921c-4acb-b305-57581b5f0afb",
      "cwes": [
        476
      ],
      "description": "A speculative pointer dereference problem exists in the Linux Kernel on the do_prlimit() function. The resource argument value is controlled and is used in pointer arithmetic for the 'rlim' variable and can be used to leak the contents. We recommend upgrading past version 6.1.8 or commit\u00a0739790605705ddcf18f21782b9c99ad7d53a8c11",
      "id": "CVE-2023-0458",
      "published": "2023-04-26T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "900de29e-8c43-41be-b71f-470d6e44b15e",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in io_uring/poll.c in io_poll_check_events in the io_uring subcomponent in the Linux Kernel due to a race condition of poll_refs. This flaw may cause a NULL pointer dereference.",
      "id": "CVE-2023-0468",
      "published": "2023-01-26T21:18:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "cd93e538-2464-4b0b-88b7-10e80a8bf595",
      "cwes": [
        191
      ],
      "description": "A use-after-free flaw was found in io_uring/filetable.c in io_install_fixed_file in the io_uring subcomponent in the Linux Kernel during call cleanup. This flaw may lead to a denial of service.",
      "id": "CVE-2023-0469",
      "published": "2023-01-26T21:18:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "d11248fc-a17a-4ebc-bd42-a8392f335d02",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in qdisc_graft in net/sched/sch_api.c in the Linux Kernel due to a race problem. This flaw leads to a denial of service issue. If patch ebda44da44f6 (\"net: sched: fix race condition in qdisc_graft()\") not applied yet, then kernel could be affected.",
      "id": "CVE-2023-0590",
      "published": "2023-03-23T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "a8319e28-5615-42a9-ab19-cb1a895124d9",
      "cwes": [
        369,
        190,
        401
      ],
      "description": "A memory leak flaw and potential divide by zero and Integer overflow was found in the Linux kernel V4L2 and vivid test code functionality. This issue occurs when a user triggers ioctls, such as VIDIOC_S_DV_TIMINGS ioctl. This could allow a local user to crash the system if vivid test code enabled.",
      "id": "CVE-2023-0615",
      "published": "2023-02-06T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "a9218683-7272-4e12-a882-c6fad4ad7263",
      "cwes": [
        416
      ],
      "description": "A flaw was found in the Linux kernel. A use-after-free may be triggered in asus_kbd_backlight_set when plugging/disconnecting in a malicious USB device, which advertises itself as an Asus device. Similarly to the previous known CVE-2023-25012, but in asus devices, the work_struct may be scheduled by the LED controller while the device is disconnecting, triggering a use-after-free on the struct asus_kbd_leds *led structure. A malicious USB device may exploit the issue to cause memory corruption with controlled data.",
      "id": "CVE-2023-1079",
      "published": "2023-03-27T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-19T22:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "7a9b94db-85c6-463e-8dd7-af09512577fb",
      "cwes": [
        476
      ],
      "description": "In nf_tables_updtable, if nf_tables_table_enable returns an error, nft_trans_destroy is called to free the transaction object. nft_trans_destroy() calls list_del(), but the transaction was never placed on a list -- the list head is all zeroes, this results in a NULL pointer dereference.",
      "id": "CVE-2023-1095",
      "published": "2023-02-28T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "a9ee179a-dab3-4c60-94cc-46f7ae8fcdba",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in smb2_is_status_io_timeout() in CIFS in the Linux Kernel. After CIFS transfers response data to a system call, there are still local variable points to the memory region, and if the system call frees it faster than CIFS uses it, CIFS will access a free memory region, leading to a denial of service.",
      "id": "CVE-2023-1192",
      "published": "2023-11-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "199cceb2-7e60-4e2c-807e-ce1a56239912",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in setup_async_work in the KSMBD implementation of the in-kernel samba server and CIFS in the Linux kernel. This issue could allow an attacker to crash the system by accessing freed work.",
      "id": "CVE-2023-1193",
      "published": "2023-11-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "9e6c3604-61b9-46ee-ae05-83fe5f1578ae",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in reconn_set_ipaddr_from_hostname in fs/cifs/connect.c in the Linux kernel. The issue occurs when it forgets to set the free pointer server->hostname to NULL, leading to an invalid pointer request.",
      "id": "CVE-2023-1195",
      "published": "2023-05-18T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "62ed3820-cd96-4a7d-b7e0-b88e8afe8ba0",
      "cwes": [
        400
      ],
      "description": "A hash collision flaw was found in the IPv6 connection lookup table in the Linux kernel\u2019s IPv6 functionality when a user makes a new kind of SYN flood attack. A user located in the local network or with a high bandwidth connection can increase the CPU usage of the server that accepts IPV6 connections up to 95%.",
      "id": "CVE-2023-1206",
      "published": "2023-06-30T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "4a701454-adaa-43cf-8487-61b518330722",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in the Linux kernel\u2019s core dump subsystem. This flaw allows a local user to crash the system. Only if patch 390031c94211 (\"coredump: Use the vma snapshot in fill_files_note\") not applied yet, then kernel could be affected.",
      "id": "CVE-2023-1249",
      "published": "2023-03-23T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "66751e79-b474-4c99-bdb8-b6dd3f264486",
      "cwes": [
        476
      ],
      "description": "A data race flaw was found in the Linux kernel, between where con is allocated and con->sock is set. This issue leads to a NULL pointer dereference when accessing con->sock->sk in net/tipc/topsrv.c in the tipc protocol in the Linux kernel.",
      "id": "CVE-2023-1382",
      "published": "2023-04-19T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "496c0bb9-51b3-42cd-b1e1-86e969d7886d",
      "cwes": [
        665
      ],
      "description": "A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on 32-bit systems, there might be some uninitialized portions of the kvm_debugregs structure that could be copied to userspace, causing an information leak.",
      "id": "CVE-2023-1513",
      "published": "2023-03-23T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-25T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "16bf6a7d-6606-44a0-8ced-ce1ac0417a6c",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.",
      "id": "CVE-2023-1855",
      "published": "2023-04-05T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-12T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "365d1e30-f4fd-4b25-8c7f-cd1a6e21685e",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in xen_9pfs_front_removet in net/9p/trans_xen.c in Xen transport for 9pfs in the Linux Kernel. This flaw could allow a local attacker to crash the system due to a race problem, possibly leading to a kernel information leak.",
      "id": "CVE-2023-1859",
      "published": "2023-05-17T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "a32055a0-d8f1-44ca-a576-4614f96ec3ca",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux Kernel io_uring system can be exploited to achieve local privilege escalation. The io_file_get_fixed function lacks the presence of ctx->uring_lock which can lead to a Use-After-Free vulnerability due a race condition with fixed files getting unregistered. We recommend upgrading past commit da24142b1ef9fd5d36b76e36bab328a5b27523e8.",
      "id": "CVE-2023-1872",
      "published": "2023-04-12T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "c4159101-20d2-4764-8a47-d6257c1c53b8",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in ndlc_remove in drivers/nfc/st-nci/ndlc.c in the Linux Kernel. This flaw could allow an attacker to crash the system due to a race problem.",
      "id": "CVE-2023-1990",
      "published": "2023-04-12T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "1fd64a96-a90c-4807-a154-b0b2952dbd6c",
      "cwes": [
        203
      ],
      "description": "The Linux kernel allows userspace processes to enable mitigations by calling prctl with PR_SET_SPECULATION_CTRL which disables the speculation feature as well as by using seccomp. We had noticed that on VMs of at least one major cloud provider, the kernel still left the victim process exposed to attacks in some cases even after enabling the spectre-BTI mitigation with prctl. The same behavior can be observed on a bare-metal machine when forcing the mitigation to IBRS on boot command line. This happened because when plain IBRS was enabled (not enhanced IBRS), the kernel had some logic that determined that STIBP was not needed. The IBRS bit implicitly protects against cross-thread branch target injection. However, with legacy IBRS, the IBRS bit was cleared on returning to userspace, due to performance reasons, which disabled the implicit STIBP and left userspace threads vulnerable to cross-thread branch target injection against which STIBP protects.",
      "id": "CVE-2023-1998",
      "published": "2023-04-21T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "2b4bc9b0-9994-445d-9cbb-4b6aec28818d",
      "cwes": [
        863
      ],
      "description": "A vulnerability was found in the HCI sockets implementation due to a missing capability check in net/bluetooth/hci_sock.c in the Linux Kernel. This flaw allows an attacker to unauthorized execution of management commands, compromising the confidentiality, integrity, and availability of Bluetooth communication.",
      "id": "CVE-2023-2002",
      "published": "2023-05-26T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain local user access to the device. Attack Complexity (AC): Attack complexity is Low(L). Privileges Required (PR): Low (L) privileges are required. Given that a successful attack requires the user to gain access to the device due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "82a6a4ff-7b16-4f3a-8831-70362fc76a57",
      "cwes": [
        667
      ],
      "description": "The specific flaw exists within the DPT I2O Controller driver. The issue results from the lack of proper locking when performing operations on an object. An attacker can leverage this in conjunction with other vulnerabilities to escalate privileges and execute arbitrary code in the context of the kernel.",
      "id": "CVE-2023-2007",
      "published": "2023-04-24T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "f3f6a5bc-ba13-4895-a0de-36fed7656c01",
      "cwes": [
        129
      ],
      "description": "A flaw was found in the Linux kernel's udmabuf device driver. The specific flaw exists within a fault handler. The issue results from the lack of proper validation of user-supplied data, which can result in a memory access past the end of an array. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel.",
      "id": "CVE-2023-2008",
      "published": "2023-04-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "457b1abc-5abc-4bd0-ae9c-ca7c6be9b07b",
      "description": "A flaw was found in the Linux kernel's netdevsim device driver, within the scheduling of events. This issue results from the improper management of a reference count. This may allow an attacker to create a denial of service condition on the system.",
      "id": "CVE-2023-2019",
      "published": "2023-04-24T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "2a140519-fede-49dd-beb0-58da0853498e",
      "cwes": [
        787
      ],
      "description": "An out-of-bounds memory access flaw was found in the Linux kernel\u2019s XFS file system in how a user restores an XFS image after failure (with a dirty log journal). This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "id": "CVE-2023-2124",
      "published": "2023-05-15T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "5c7ea9e1-b9b3-4a22-9375-19556c19a44b",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability was found in iscsi_sw_tcp_session_create in drivers/scsi/iscsi_tcp.c in SCSI sub-component in the Linux Kernel. In this flaw an attacker could leak kernel internal information.",
      "id": "CVE-2023-2162",
      "published": "2023-04-19T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "adbe646f-c229-42d9-9303-e78ca8a0ce81",
      "cwes": [
        476
      ],
      "description": "A null pointer dereference issue was found in can protocol in net/can/af_can.c in the Linux before Linux. ml_priv may not be initialized in the receive path of CAN frames. A local user could use this flaw to crash the system or potentially cause a denial of service.",
      "id": "CVE-2023-2166",
      "published": "2023-04-19T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "c1662db5-f03b-46c8-a9f2-621ba710511e",
      "cwes": [
        476
      ],
      "description": "A null pointer dereference issue was found in the sctp network protocol in net/sctp/stream_sched.c in Linux Kernel. If stream_in allocation is failed, stream_out is freed which would further be accessed. A local user could use this flaw to crash the system or potentially cause a denial of service.",
      "id": "CVE-2023-2177",
      "published": "2023-04-20T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "277c6265-babf-42d8-a1bb-78a471a838c1",
      "cwes": [
        787
      ],
      "description": "An out-of-bounds write vulnerability was found in the Linux kernel's SLIMpro I2C device driver. The userspace \"data->block[0]\" variable was not capped to a number between 0-255 and was used as the size of a memcpy, possibly writing beyond the end of dma_buffer. This flaw could allow a local privileged user to crash the system or potentially achieve code execution.",
      "id": "CVE-2023-2194",
      "published": "2023-04-20T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Considered Not Affacted as CONFIG_USB_DWC3_QCOM not set thus the weakness is not in use on the system",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1fcb2807-910e-49c2-9c83-7151401aa810",
      "description": "In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.",
      "id": "CVE-2023-22995",
      "published": "2023-02-28T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "a8cbad4c-c94c-40bd-b8cc-9a13c5b1426f",
      "cwes": [
        772
      ],
      "description": "In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not release an of_find_device_by_node reference after use, e.g., with put_device.",
      "id": "CVE-2023-22996",
      "published": "2023-02-28T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "da1e9662-a3ae-48bb-97b4-d9b925f70b73",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets the module_get_next_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
      "id": "CVE-2023-22997",
      "published": "2023-02-28T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "080f7e70-b682-466a-a003-36d80e6f8889",
      "cwes": [
        436
      ],
      "description": "In the Linux kernel before 6.0.3, drivers/gpu/drm/virtio/virtgpu_object.c misinterprets the drm_gem_shmem_get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
      "id": "CVE-2023-22998",
      "published": "2023-02-28T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:57Z"
      },
      "bom-ref": "34c9debb-9852-4438-81d0-8a92cc7ca416",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
      "id": "CVE-2023-22999",
      "published": "2023-02-28T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "3551dad5-3658-4289-8fb0-f393de04feb6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case, but an error pointer is used.",
      "id": "CVE-2023-23000",
      "published": "2023-03-01T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:59Z"
      },
      "bom-ref": "abd862f7-fcf5-48d3-8b35-f6e681ce80b5",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 5.16.3, drivers/scsi/ufs/ufs-mediatek.c misinterprets the regulator_get return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
      "id": "CVE-2023-23001",
      "published": "2023-03-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:59Z"
      },
      "bom-ref": "374d6ccf-50dc-4822-af1d-f3ceae11fb10",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets the devm_gpiod_get_index_optional return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
      "id": "CVE-2023-23002",
      "published": "2023-03-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:59Z"
      },
      "bom-ref": "216fcccc-da7f-4e2f-a026-ac31198ddd93",
      "cwes": [
        252
      ],
      "description": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",
      "id": "CVE-2023-23003",
      "published": "2023-03-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:59Z"
      },
      "bom-ref": "6b802c90-113b-4e39-91c5-96bd4611c3b0",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets the get_sg_table return value (expects it to be NULL in the error case, whereas it is actually an error pointer).",
      "id": "CVE-2023-23004",
      "published": "2023-03-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:48:59Z"
      },
      "bom-ref": "74543e6f-8dc9-469e-a56a-5728d615a6eb",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 6.2, mm/memory-tiers.c misinterprets the alloc_memory_type return value (expects it to be NULL in the error case, whereas it is actually an error pointer). NOTE: this is disputed by third parties because there are no realistic cases in which a user can cause the alloc_memory_type error case to be reached.",
      "id": "CVE-2023-23005",
      "published": "2023-03-01T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "ccf4c61b-74f2-4dd5-a141-0bc52afe9312",
      "cwes": [
        362
      ],
      "description": "An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().",
      "id": "CVE-2023-23039",
      "published": "2023-02-22T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "77c688de-b642-43a0-b940-397785f5f822",
      "cwes": [
        843
      ],
      "description": "cbq_classify in net/sched/sch_cbq.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service (slab-out-of-bounds read) because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).",
      "id": "CVE-2023-23454",
      "published": "2023-01-12T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "df2f82fb-4c8e-44ab-8dbd-a4ec973da771",
      "cwes": [
        843
      ],
      "description": "atm_tc_enqueue in net/sched/sch_atm.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).",
      "id": "CVE-2023-23455",
      "published": "2023-01-12T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "4b542a3b-ec3e-4da6-be09-64025f8dd51d",
      "cwes": [
        667
      ],
      "description": "A vulnerability was found due to missing lock for IOPOLL flaw in io_cqring_event_overflow() in io_uring.c in Linux Kernel. This flaw allows a local attacker with user privilege to trigger a Denial of Service threat.",
      "id": "CVE-2023-2430",
      "published": "2023-07-23T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T22:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "4384ad5d-d315-417e-9466-a669eb4c0d60",
      "cwes": [
        416
      ],
      "description": "The Linux kernel through 6.1.9 has a Use-After-Free in bigben_remove in drivers/hid/hid-bigbenff.c via a crafted USB device because the LED controllers remain registered for too long.",
      "id": "CVE-2023-25012",
      "published": "2023-02-02T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "f4546243-fd92-4290-ab6a-3e6588620cc6",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability was found in the Linux kernel's ext4 filesystem in the way it handled the extra inode size for extended attributes. This flaw could allow a privileged local user to cause a system crash or other undefined behaviors.",
      "id": "CVE-2023-2513",
      "published": "2023-05-08T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Considered Not Affected as CONFIG_FPGA not set thus the weakness is not in use on the system",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "73316266-cf10-4451-927c-77d0bb4cd931",
      "cwes": [
        190
      ],
      "description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
      "id": "CVE-2023-26242",
      "published": "2023-02-21T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "f977276c-aaf0-438e-8853-25d9907f19c4",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device.",
      "id": "CVE-2023-26545",
      "published": "2023-02-25T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "562a3f6a-1432-4eca-8535-3528d3d1a52d",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the UNIX protocol in net/unix/diag.c In unix_diag_get_exact in the Linux Kernel. The newly allocated skb does not have sk, leading to a NULL pointer. This flaw allows a local user to crash or potentially cause a denial of service.",
      "id": "CVE-2023-28327",
      "published": "2023-04-19T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "ee292c65-86ea-45e8-a8d7-1cd6a88ad397",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the az6027 driver in drivers/media/usb/dev-usb/az6027.c in the Linux Kernel. The message from user space is not checked properly before transferring into the device. This flaw allows a local user to crash the system or potentially cause a denial of service.",
      "id": "CVE-2023-28328",
      "published": "2023-04-19T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "f945afeb-1539-4a45-8267-5eb8eb4c75eb",
      "cwes": [
        125
      ],
      "description": "An out-of-bounds read vulnerability was found in the SR-IPv6 implementation in the Linux kernel. The flaw exists within the processing of seg6 attributes. The issue results from the improper validation of user-supplied data, which can result in a read past the end of an allocated buffer. This flaw allows a privileged local user to disclose sensitive information on affected installations of the Linux kernel.",
      "id": "CVE-2023-2860",
      "published": "2023-07-24T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "2bd98f37-9927-4b36-b34b-8cfd323606c5",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel through 6.2.8, net/bluetooth/hci_sync.c allows out-of-bounds access because amp_init1[] and amp_init2[] are supposed to have an intentionally invalid element, but do not.",
      "id": "CVE-2023-28866",
      "published": "2023-03-27T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "4c11f8bb-ccce-43d3-9966-74adbf267dee",
      "cwes": [
        416
      ],
      "description": "A use after free flaw was found in hfsplus_put_super in fs/hfsplus/super.c in the Linux Kernel. This flaw could allow a local user to cause a denial of service problem.",
      "id": "CVE-2023-2985",
      "published": "2023-06-01T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "8fb1b94f-b642-4dff-906d-b5d11d059c49",
      "description": "An issue was discovered in arch/x86/kvm/vmx/nested.c in the Linux kernel before 6.2.8. nVMX on x86_64 lacks consistency checks for CR0 and CR4.",
      "id": "CVE-2023-30456",
      "published": "2023-04-10T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "64d40a02-b11f-486b-9af1-5cf4360c9c2e",
      "cwes": [
        416
      ],
      "description": "The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/power/supply/da9150-charger.c if a physically proximate attacker unplugs a device.",
      "id": "CVE-2023-30772",
      "published": "2023-04-16T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "ebd9bbad-4476-4129-9f30-7896bb93e4d1",
      "cwes": [
        416
      ],
      "description": "A use after free issue was discovered in driver/firewire in outbound_phy_packet_callback in the Linux Kernel. In this flaw a local attacker with special privilege may cause a use after free problem when queue_event() fails.",
      "id": "CVE-2023-3159",
      "published": "2023-06-12T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "7c091409-7588-4a6b-9ee4-8d093783ce87",
      "cwes": [
        682
      ],
      "description": "A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.",
      "id": "CVE-2023-3161",
      "published": "2023-06-12T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-11T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "a90b69ba-4020-46eb-b0c8-24829bffd8b0",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference issue was found in the gfs2 file system in the Linux kernel. It occurs on corrupt gfs2 file systems when the evict code tries to reference the journal descriptor structure after it has been freed and set to NULL. A privileged local user could use this flaw to cause a kernel panic.",
      "id": "CVE-2023-3212",
      "published": "2023-06-23T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "6a573c5d-a5fd-423a-984e-882c513a1607",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 6.1-rc8. dpu_crtc_atomic_check in drivers/gpu/drm/msm/disp/dpu1/dpu_crtc.c lacks check of the return value of kzalloc() and will cause the NULL Pointer Dereference.",
      "id": "CVE-2023-3220",
      "published": "2023-06-20T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-11T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "083e08d6-dd7e-4e91-8311-974ea9b3bc93",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c, there is a use-after-free because accept is also allowed for a successfully connected AF_NETROM socket. However, in order for an attacker to exploit this, the system must have netrom routing configured or the attacker must have the CAP_NET_ADMIN capability.",
      "id": "CVE-2023-32269",
      "published": "2023-05-05T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "1503a877-35e1-4c77-a442-7b97acdd68ee",
      "cwes": [
        125
      ],
      "description": "An out of bounds (OOB) memory access flaw was found in the Linux kernel in relay_file_read_start_pos in kernel/relay.c in the relayfs. This flaw could allow a local attacker to crash the system or leak kernel internal information.",
      "id": "CVE-2023-3268",
      "published": "2023-06-16T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-11T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "79c0fb82-0ba5-4f44-a069-3fa2e8191daa",
      "cwes": [
        362
      ],
      "description": "The Linux kernel before 6.2.9 has a race condition and resultant use-after-free in drivers/net/ethernet/qualcomm/emac/emac.c if a physically proximate attacker unplugs an emac based device.",
      "id": "CVE-2023-33203",
      "published": "2023-05-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "0b1f9e96-9876-4aa0-9309-b5d46cb4bcdc",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.",
      "id": "CVE-2023-33288",
      "published": "2023-05-22T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "8408bd84-1195-4741-8140-22dc31369696",
      "cwes": [
        476
      ],
      "description": "A null pointer dereference flaw was found in the Linux kernel's DECnet networking protocol. This issue could allow a remote user to crash the system.",
      "id": "CVE-2023-3338",
      "published": "2023-06-30T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "8ccba502-fd67-43d6-bd25-91af6f10b791",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the Linux kernel's drivers/gpu/drm/msm/msm_gem_submit.c code in the submit_lookup_cmds function, which fails because it lacks a check of the return value of kmalloc(). This issue allows a local user to crash the system.",
      "id": "CVE-2023-3355",
      "published": "2023-06-28T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "fafba05c-a9cb-49e5-a8d1-6883441e2e2f",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the Linux kernel AMD Sensor Fusion Hub driver. This flaw allows a local user to crash the system.",
      "id": "CVE-2023-3357",
      "published": "2023-06-28T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-10T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "2e623fac-1c16-439c-ac05-bb14ab8afe66",
      "cwes": [
        476
      ],
      "description": "A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.",
      "id": "CVE-2023-3358",
      "published": "2023-06-28T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-10T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "f2dfe7a6-a190-482d-86ce-bdcbd4b38d07",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel brcm_nvram_parse in drivers/nvmem/brcm_nvram.c. Lacks for the check of the return value of kzalloc() can cause the NULL Pointer Dereference.",
      "id": "CVE-2023-3359",
      "published": "2023-06-28T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "49b7116f-c3d6-47af-b0fb-628388a4a6c4",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux Kernel io_uring subsystem can be exploited to achieve local privilege escalation. Racing a io_uring cancel poll request with a linked timeout can cause a UAF in a hrtimer. We recommend upgrading past commit ef7dfac51d8ed961b742218f526bd589f3900a59 (4716c73b188566865bdd79c3a6709696a224ac04 for 5.10 stable and\u00a00e388fce7aec40992eadee654193cad345d62663 for 5.15 stable).",
      "id": "CVE-2023-3389",
      "published": "2023-06-28T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "eceab792-31c8-4c9c-9540-9f5734111910",
      "cwes": [
        362,
        667
      ],
      "description": "A race condition vulnerability was found in the vmwgfx driver in the Linux kernel. The flaw exists within the handling of GEM objects. The issue results from improper locking when performing operations on an object. This flaw allows a local privileged user to disclose information in the context of the kernel.",
      "id": "CVE-2023-33951",
      "published": "2023-07-24T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:C/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:06:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "6f3ff97f-8131-461c-a848-a7cb86a66c4a",
      "cwes": [
        415
      ],
      "description": "A double-free vulnerability was found in handling vmw_buffer_object objects in the vmwgfx driver in the Linux kernel. This issue occurs due to the lack of validating the existence of an object prior to performing further free operations on the object, which may allow a local privileged user to escalate privileges and execute code in the context of the kernel.",
      "id": "CVE-2023-33952",
      "published": "2023-07-24T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:06:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:01Z"
      },
      "bom-ref": "4480cbba-e6e9-41cf-b415-cbfec878c4e9",
      "cwes": [
        125
      ],
      "description": "An issue was discovered in the Linux kernel before 6.3.3. There is an out-of-bounds read in crc16 in lib/crc16.c when called from fs/ext4/super.c because ext4_group_desc_csum does not properly check an offset. NOTE: this is disputed by third parties because the kernel is not intended to defend against attackers with the stated \"When modifying the block device while it is mounted by the filesystem\" access.",
      "id": "CVE-2023-34256",
      "published": "2023-05-31T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "280f895f-b1b9-484f-a04a-3423a8881b74",
      "cwes": [
        416
      ],
      "description": "A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service.",
      "id": "CVE-2023-3439",
      "published": "2023-06-28T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "9c05fddc-1ca4-4aac-a5f3-e8cf3c3335bf",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in vcs_read in drivers/tty/vt/vc_screen.c in vc_screen in the Linux Kernel. This issue may allow an attacker with local user access to cause a system crash or leak internal kernel information.",
      "id": "CVE-2023-3567",
      "published": "2023-07-24T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "a563fa05-d7a4-4c40-8768-b76937b8674e",
      "cwes": [
        362,
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in saa7134_finidev in drivers/media/pci/saa7134/saa7134-core.c.",
      "id": "CVE-2023-35823",
      "published": "2023-06-18T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "efec268b-6469-4630-b7b5-5582c5c0629d",
      "cwes": [
        362,
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in dm1105_remove in drivers/media/pci/dm1105/dm1105.c.",
      "id": "CVE-2023-35824",
      "published": "2023-06-18T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "063ad754-a6c4-46bc-b307-21538b75b24e",
      "cwes": [
        362,
        416
      ],
      "description": "An issue was discovered in the Linux kernel through 6.3.8. A use-after-free was found in ravb_remove in drivers/net/ethernet/renesas/ravb_main.c.",
      "id": "CVE-2023-35827",
      "published": "2023-06-18T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "baf172d9-f19b-4b8e-b38d-89ff0cf75a43",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation. If tcf_change_indev() fails, u32_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability. We recommend upgrading past commit 04c55383fa5689357bcdd2c8036725a55ed632bc.",
      "id": "CVE-2023-3609",
      "published": "2023-07-21T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:02Z"
      },
      "bom-ref": "8641d78b-a9e2-4e51-b546-c6dd88c4e1d5",
      "cwes": [
        125
      ],
      "description": "An issue was discovered in the USB subsystem in the Linux kernel through 6.4.2. There is an out-of-bounds and crash in read_descriptors in drivers/usb/core/sysfs.c.",
      "id": "CVE-2023-37453",
      "published": "2023-07-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "c470405e-a145-4ab6-b189-d2ca6fc5ee50",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in the Linux kernel through 6.4.2. A crafted UDF filesystem image causes a use-after-free write operation in the udf_put_super and udf_close_lvid functions in fs/udf/super.c. NOTE: the suse.com reference has a different perspective about this.",
      "id": "CVE-2023-37454",
      "published": "2023-07-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "57d2efd3-6fe2-4859-9f70-532f2dfe843f",
      "description": "An issue was discovered in set_con2fb_map in drivers/video/fbdev/core/fbcon.c in the Linux kernel before 6.2.12. Because an assignment occurs only for the first vc, the fbcon_registered_fb and fbcon_display arrays can be desynchronized in fbcon_mode_deleted (the con2fb_map points at the old fb_info).",
      "id": "CVE-2023-38409",
      "published": "2023-07-17T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "5d95da2e-a86d-41ce-a799-966556184ff3",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.",
      "id": "CVE-2023-3863",
      "published": "2023-07-24T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.1,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "dc512a22-9107-4bdd-9f9b-5128cff7b398",
      "cwes": [
        125
      ],
      "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The nfnl_osf_add_callback function did not validate the user mode controlled opt_num field. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, leading to a crash or information disclosure.",
      "id": "CVE-2023-39189",
      "published": "2023-10-09T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "99214b16-8188-4bc5-b1ae-711b946db8f9",
      "cwes": [
        125
      ],
      "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The xt_u32 module did not validate the fields in the xt_u32 structure. This flaw allows a local privileged attacker to trigger an out-of-bounds read by setting the size fields with a value beyond the array boundaries, leading to a crash or information disclosure.",
      "id": "CVE-2023-39192",
      "published": "2023-10-09T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "880f0249-5660-4691-882b-02f4fe2d40a3",
      "cwes": [
        125
      ],
      "description": "A flaw was found in the Netfilter subsystem in the Linux kernel. The sctp_mt_check did not validate the flag_count field. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, leading to a crash or information disclosure.",
      "id": "CVE-2023-39193",
      "published": "2023-10-09T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "154f9216-f328-4e82-b814-23285fac010b",
      "cwes": [
        125
      ],
      "description": "A flaw was found in the XFRM subsystem in the Linux kernel. The specific flaw exists within the processing of state filters, which can result in a read past the end of an allocated buffer. This flaw allows a local privileged (CAP_NET_ADMIN) attacker to trigger an out-of-bounds read, potentially leading to an information disclosure.",
      "id": "CVE-2023-39194",
      "published": "2023-10-09T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "ceef5452-6d9e-4c68-bbc2-f6d523eae68a",
      "cwes": [
        416
      ],
      "description": "A race condition was found in the QXL driver in the Linux kernel. The qxl_mode_dumb_create() function dereferences the qobj returned by the qxl_gem_object_create_with_handle(), but the handle is the only one holding a reference to it. This flaw allows an attacker to guess the returned handle value and trigger a use-after-free issue, potentially leading to a denial of service or privilege escalation.",
      "id": "CVE-2023-39198",
      "published": "2023-11-09T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "01f03507-5d93-4a87-87e9-c323da61036e",
      "description": "extract_user_to_sg in lib/scatterlist.c in the Linux kernel before 6.4.12 fails to unpin pages in a certain situation, as demonstrated by a WARNING for try_grab_page.",
      "id": "CVE-2023-40791",
      "published": "2023-10-16T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:04Z"
      },
      "bom-ref": "6fc6e37f-163b-40b5-bcbf-dcf59370d2bb",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability was found in the siano smsusb module in the Linux kernel. The bug occurs during device initialization when the siano device is plugged in. This flaw allows a local user to crash the system, causing a denial of service condition.",
      "id": "CVE-2023-4132",
      "published": "2023-08-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "e45b3ee2-923f-4d78-a479-22ce857d0e6e",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.",
      "id": "CVE-2023-4133",
      "published": "2023-08-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "57b826f0-bf45-44f1-a0b5-ca4a8fc1ea2e",
      "cwes": [
        863
      ],
      "description": "A flaw was found in the Linux kernel's TUN/TAP functionality. This issue could allow a local user to bypass network filters and gain unauthorized access to some resources. The original patches fixing CVE-2023-1076 are incorrect or incomplete. The problem is that the following upstream commits - a096ccca6e50 (\"tun: tun_chr_open(): correctly initialize socket uid\"), - 66b2c338adce (\"tap: tap_open(): correctly initialize socket uid\"), pass \"inode->i_uid\" to sock_init_data_uid() as the last parameter and that turns out to not be accurate.",
      "id": "CVE-2023-4194",
      "published": "2023-08-07T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "9e3f2831-a9df-4695-bb40-9515273a843c",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. Due to a race condition between nf_tables netlink control plane transaction and nft_set element garbage collection, it is possible to underflow the reference counter causing a use-after-free vulnerability. We recommend upgrading past commit 3e91b0ebd994635df2346353322ac51ce84ce6d8.",
      "id": "CVE-2023-4244",
      "published": "2023-09-06T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T17:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "e591f29d-0ec9-4640-87b9-41470d2fff82",
      "cwes": [
        787
      ],
      "description": "A flaw was found in the exFAT driver of the Linux kernel. The vulnerability exists in the implementation of the file name reconstruction function, which is responsible for reading file name entries from a directory index and merging file name parts belonging to one file into a single long file name. Since the file name characters are copied into a stack variable, a local privileged attacker could use this flaw to overflow the kernel stack.",
      "id": "CVE-2023-4273",
      "published": "2023-08-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "badeed4e-8d83-4ac3-b2ea-f4eb03aaea75",
      "cwes": [
        190
      ],
      "description": "An integer overflow flaw was found in the Linux kernel. This issue leads to the kernel allocating `skb_shared_info` in the userspace, which is exploitable in systems without SMAP protection since `skb_shared_info` contains references to function pointers.",
      "id": "CVE-2023-42752",
      "published": "2023-10-13T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "49da4b00-98ce-46fd-9856-f395a962ff7b",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the Linux kernel ipv4 stack. The socket buffer (skb) was assumed to be associated with a device before calling __ip_options_compile, which is not always the case if the skb is re-routed by ipvs. This issue may allow a local user with CAP_NET_ADMIN privileges to crash the system.",
      "id": "CVE-2023-42754",
      "published": "2023-10-05T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "04d6d317-83aa-45b2-bcf4-6733caa7a60d",
      "cwes": [
        125
      ],
      "description": "A flaw was found in the IPv4 Resource Reservation Protocol (RSVP) classifier in the Linux kernel. The xprt pointer may go beyond the linear part of the skb, leading to an out-of-bounds read in the `rsvp_classify` function. This issue may allow a local user to crash the system and cause a denial of service.",
      "id": "CVE-2023-42755",
      "published": "2023-10-05T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "e5009573-cd75-425e-909a-e1a65c4ab447",
      "cwes": [
        362
      ],
      "description": "A flaw was found in the Netfilter subsystem of the Linux kernel. A race condition between IPSET_CMD_ADD and IPSET_CMD_SWAP can lead to a kernel panic due to the invocation of `__ip_set_put` on a wrong `set`. This issue may allow a local user to crash the system.",
      "id": "CVE-2023-42756",
      "published": "2023-09-28T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "28c13c3f-33cd-42c9-87e7-7fbc2d2c5d38",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in dbFree in fs/jfs/jfs_dmap.c in the journaling file system (JFS) in the Linux Kernel. This issue may allow a local attacker to crash the system due to a missing sanity check.",
      "id": "CVE-2023-4385",
      "published": "2023-08-16T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "b58a6646-f337-413b-9457-bba49a50239b",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in btrfs_get_dev_args_from_path in fs/btrfs/volumes.c in btrfs file-system in the Linux Kernel. This flaw allows a local attacker with special privileges to cause a system crash or leak internal kernel information",
      "id": "CVE-2023-4394",
      "published": "2023-08-17T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "1c2517e4-74c6-4443-9757-168478cbb054",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in vmxnet3_rq_cleanup in drivers/net/vmxnet3/vmxnet3_drv.c in the networking sub-component in vmxnet3 in the Linux Kernel. This issue may allow a local attacker with normal user privilege to cause a denial of service due to a missing sanity check during cleanup.",
      "id": "CVE-2023-4459",
      "published": "2023-08-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "dc06041a-a397-4f6a-90c7-529d8c9d6913",
      "cwes": [
        401
      ],
      "description": "A memory leak flaw was found in nft_set_catchall_flush in net/netfilter/nf_tables_api.c in the Linux Kernel. This issue may allow a local attacker to cause double-deactivations of catchall elements, which can result in a memory leak.",
      "id": "CVE-2023-4569",
      "published": "2023-08-28T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "0e1e612e-f4e6-4f1c-b219-cd5f86e53324",
      "cwes": [
        770
      ],
      "description": "An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.",
      "id": "CVE-2023-45862",
      "published": "2023-10-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "e56d12da-d7bc-42db-abc3-3bf128cea6db",
      "cwes": [
        787
      ],
      "description": "An issue was discovered in lib/kobject.c in the Linux kernel before 6.2.3. With root access, an attacker can trigger a race condition that results in a fill_kobj_path out-of-bounds write.",
      "id": "CVE-2023-45863",
      "published": "2023-10-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "c075af55-99d9-4ef0-b3a6-5cae79dfba0e",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in mm/mempolicy.c in the memory management subsystem in the Linux Kernel. This issue is caused by a race between mbind() and VMA-locked page fault, and may allow a local attacker to crash the system or lead to a kernel information leak.",
      "id": "CVE-2023-4611",
      "published": "2023-08-29T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "ce05c404-d331-47bd-a10d-397ca2411bbc",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux kernel's af_unix component can be exploited to achieve local privilege escalation. The unix_stream_sendpage() function tries to add data to the last skb in the peer's recv queue without locking the queue. Thus there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free. We recommend upgrading past commit 790c2f9d15b594350ae9bca7b236f2b1859de02c.",
      "id": "CVE-2023-4622",
      "published": "2023-09-06T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "da486fb6-bd2d-45c8-af41-7d60cb78af50",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 6.5.9, there is a NULL pointer dereference in send_acknowledge in net/nfc/nci/spi.c.",
      "id": "CVE-2023-46343",
      "published": "2024-01-23T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-17T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "878c83ec-3243-4688-8db1-2501f90f0312",
      "description": "An issue was discovered in the Linux kernel before 6.5.9, exploitable by local users with userspace access to MMIO registers. Incorrect access checking in the #VC handler and instruction emulation of the SEV-ES emulation of MMIO accesses could lead to arbitrary write access to kernel memory (and thus privilege escalation). This depends on a race condition through which userspace can replace an instruction before the #VC handler reads it.",
      "id": "CVE-2023-46813",
      "published": "2023-10-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:06Z"
      },
      "bom-ref": "7439af47-2805-41ee-91a6-df3a1049ceaf",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 6.5.9. During a race with SQ thread exit, an io_uring/fdinfo.c io_uring_show_fdinfo NULL pointer dereference can occur.",
      "id": "CVE-2023-46862",
      "published": "2023-10-29T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_PCI, CONFIG_MQ_IOSCHED_DEADLINE, CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_USB_DWC2_DUAL_ROLE, CONFIG_BLK_DEV_MD, CONFIG_ARCH_HAS_RELR, CONFIG_NETDEVICES, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_SYNC, CONFIG_NET_DSA, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_CFG80211_C, CONFIG_TRACING, CONFIG_WLAN, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_BPF, CONFIG_ARM, CONFIG_USB_DWC3_DUAL_ROLE, CONFIG_NET, CONFIG_CFG80211, CONFIG_IOMMU_SUPPORT, CONFIG_SYNC_FILE, CONFIG_PHYLIB, CONFIG_USB, CONFIG_SMP, CONFIG_MODVERSIONS, CONFIG_WIRELESS, CONFIG_FRAME_WARN, CONFIG_BPF_JIT, CONFIG_DM_VERITY_FEC, CONFIG_OF, CONFIG_NET_PTP_CLASSIFY, CONFIG_SYSFS, CONFIG_PCI_QUIRKS, CONFIG_POWER_SUPPLY, CONFIG_FRAME_POINTER, CONFIG_MDIO_DEVICE, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_HAS_IOMEM, CONFIG_MODULES, CONFIG_ARC, CONFIG_BPF_SYSCALL, CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG, CONFIG_OF_FLATTREE, CONFIG_OF_EARLY_FLATTREE, CONFIG_DRM, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_DMA_SHARED_BUFFER, CONFIG_LD_IS_BFD, CONFIG_KEXEC_FILE, CONFIG_COMMON_CLK, CONFIG_ARM64, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_VLAN_8021Q, CONFIG_LTO, CONFIG_HWMON, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_NF_CONNTRACK, CONFIG_PM, CONFIG_EFI_CAPSULE_LOADER, CONFIG_CPU_LITTLE_ENDIAN, CONFIG_LD_ORPHAN_WARN, CONFIG_IPV6",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:49:17Z"
      },
      "bom-ref": "36fafeb9-be06-4fa1-ad05-45c5c372a997",
      "cwes": [
        416
      ],
      "description": "The brcm80211 component in the Linux kernel through 6.5.10 has a brcmf_cfg80211_detach use-after-free in the device unplugging (disconnect the USB by hotplug) code. For physically proximate attackers with local access, this \"could be exploited in a real world scenario.\" This is related to brcmf_cfg80211_escan_timeout_worker in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c.",
      "id": "CVE-2023-47233",
      "published": "2023-11-03T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "c2e56f56-a786-4645-be9a-06b6ecbb0d5e",
      "cwes": [
        755
      ],
      "description": "A flaw was found in KVM. An improper check in svm_set_x2apic_msr_interception() may allow direct access to host x2apic msrs when the guest resets its apic, potentially leading to a denial of service condition.",
      "id": "CVE-2023-5090",
      "published": "2023-11-06T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "237221fa-ff9b-4ef8-98a9-f8129af4d985",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel before 6.4.12, amdgpu_cs_wait_all_fences in drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c has a fence use-after-free.",
      "id": "CVE-2023-51042",
      "published": "2024-01-23T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "6f8ad8f7-70f4-4e4c-b5d2-e1e600494bf5",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel before 6.4.5, drivers/gpu/drm/drm_atomic.c has a use-after-free during a race condition between a nonblocking atomic commit and a driver unload.",
      "id": "CVE-2023-51043",
      "published": "2024-01-23T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "8f0504aa-448e-4fae-9e99-66aea1653cb3",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.6.8. do_vcc_ioctl in net/atm/ioctl.c has a use-after-free because of a vcc_recvmsg race condition.",
      "id": "CVE-2023-51780",
      "published": "2024-01-11T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "00805854-042d-45a5-b46f-e97fb70aa494",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.6.8. atalk_ioctl in net/appletalk/ddp.c has a use-after-free because of an atalk_recvmsg race condition.",
      "id": "CVE-2023-51781",
      "published": "2024-01-11T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "66a78092-8cf8-48e2-a0ce-e6d130707d60",
      "cwes": [
        416
      ],
      "description": "An issue was discovered in the Linux kernel before 6.6.8. rose_ioctl in net/rose/af_rose.c has a use-after-free because of a rose_accept race condition.",
      "id": "CVE-2023-51782",
      "published": "2024-01-11T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:09Z"
      },
      "bom-ref": "35efc1fb-aa93-4dc6-9a25-77912ed7b841",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux kernel's netfilter: nf_tables component can be exploited to achieve local privilege escalation. Addition and removal of rules from chain bindings within the same transaction causes leads to use-after-free. We recommend upgrading past commit f15f29fd4779be8a418b66e9d52979bb6d6c2325.",
      "id": "CVE-2023-5197",
      "published": "2023-09-27T15:19:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Not affected due to bpf not used",
        "justification": "code_not_reachable",
        "response": [
          "will_not_fix"
        ],
        "state": "not_affected"
      },
      "bom-ref": "6584353e-687c-4a41-a997-3790d3d732f0",
      "cwes": [
        665
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix accesses to uninit stack slots Privileged programs are supposed to be able to read uninitialized stack memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons. This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it. Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead. This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue. A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
      "id": "CVE-2023-52452",
      "published": "2024-02-22T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:10Z"
      },
      "bom-ref": "92634ce9-c88d-4383-8da4-eeda967ad634",
      "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: errata: Add Cortex-A520 speculative unprivileged load workaround Implement the workaround for ARM Cortex-A520 erratum 2966298. On an affected Cortex-A520 core, a speculatively executed unprivileged load might leak data from a privileged load via a cache side channel. The issue only exists for loads within a translation regime with the same translation (e.g. same ASID and VMID). Therefore, the issue only affects the return to EL0. The workaround is to execute a TLBI before returning to EL0 after all loads of privileged data. A non-shareable TLBI to any address is sufficient. The workaround isn't necessary if page table isolation (KPTI) is enabled, but for simplicity it will be. Page table isolation should normally be disabled for Cortex-A520 as it supports the CSV3 feature and the E0PD feature (used when KASLR is enabled).",
      "id": "CVE-2023-52481",
      "published": "2024-02-29T06:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-04T14:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "665cca1b-95aa-45b8-9978-cc38d2c0b601",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Wake DMCUB before sending a command [Why] We can hang in place trying to send commands when the DMCUB isn't powered on. [How] For functions that execute within a DC context or DC lock we can wrap the direct calls to dm_execute_dmub_cmd/list with code that exits idle power optimizations and reallows once we're done with the command submission on success. For DM direct submissions the DM will need to manage the enter/exit sequencing manually. We cannot invoke a DMCUB command directly within the DM execution helper or we can deadlock.",
      "id": "CVE-2023-52485",
      "published": "2024-02-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T20:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:11Z"
      },
      "bom-ref": "145da116-a175-4245-81ae-fd3f66a159f8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: serial: sc16is7xx: convert from _raw_ to _noinc_ regmap functions for FIFO The SC16IS7XX IC supports a burst mode to access the FIFOs where the initial register address is sent ($00), followed by all the FIFO data without having to resend the register address each time. In this mode, the IC doesn't increment the register address for each R/W byte. The regmap_raw_read() and regmap_raw_write() are functions which can perform IO over multiple registers. They are currently used to read/write from/to the FIFO, and although they operate correctly in this burst mode on the SPI bus, they would corrupt the regmap cache if it was not disabled manually. The reason is that when the R/W size is more than 1 byte, these functions assume that the register address is incremented and handle the cache accordingly. Convert FIFO R/W functions to use the regmap _noinc_ versions in order to remove the manual cache control which was a workaround when using the _raw_ versions. FIFO registers are properly declared as volatile so cache will not be used/updated for FIFO accesses.",
      "id": "CVE-2023-52488",
      "published": "2024-03-11T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T16:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:13Z"
      },
      "bom-ref": "58afbeed-b671-44f9-b741-839c2df99e9d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: Set all reserved memblocks on Node#0 at initialization After commit 61167ad5fecdea (\"mm: pass nid to reserve_bootmem_region()\") we get a panic if DEFERRED_STRUCT_PAGE_INIT is enabled: [ 0.000000] CPU 0 Unable to handle kernel paging request at virtual address 0000000000002b82, era == 90000000040e3f28, ra == 90000000040e3f18 [ 0.000000] Oops[#1]: [ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 6.5.0+ #733 [ 0.000000] pc 90000000040e3f28 ra 90000000040e3f18 tp 90000000046f4000 sp 90000000046f7c90 [ 0.000000] a0 0000000000000001 a1 0000000000200000 a2 0000000000000040 a3 90000000046f7ca0 [ 0.000000] a4 90000000046f7ca4 a5 0000000000000000 a6 90000000046f7c38 a7 0000000000000000 [ 0.000000] t0 0000000000000002 t1 9000000004b00ac8 t2 90000000040e3f18 t3 90000000040f0800 [ 0.000000] t4 00000000000f0000 t5 80000000ffffe07e t6 0000000000000003 t7 900000047fff5e20 [ 0.000000] t8 aaaaaaaaaaaaaaab u0 0000000000000018 s9 0000000000000000 s0 fffffefffe000000 [ 0.000000] s1 0000000000000000 s2 0000000000000080 s3 0000000000000040 s4 0000000000000000 [ 0.000000] s5 0000000000000000 s6 fffffefffe000000 s7 900000000470b740 s8 9000000004ad4000 [ 0.000000] ra: 90000000040e3f18 reserve_bootmem_region+0xec/0x21c [ 0.000000] ERA: 90000000040e3f28 reserve_bootmem_region+0xfc/0x21c [ 0.000000] CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE) [ 0.000000] PRMD: 00000000 (PPLV0 -PIE -PWE) [ 0.000000] EUEN: 00000000 (-FPE -SXE -ASXE -BTE) [ 0.000000] ECFG: 00070800 (LIE=11 VS=7) [ 0.000000] ESTAT: 00010800 [PIL] (IS=11 ECode=1 EsubCode=0) [ 0.000000] BADV: 0000000000002b82 [ 0.000000] PRID: 0014d000 (Loongson-64bit, Loongson-3A6000) [ 0.000000] Modules linked in: [ 0.000000] Process swapper (pid: 0, threadinfo=(____ptrval____), task=(____ptrval____)) [ 0.000000] Stack : 0000000000000000 9000000002eb5430 0000003a00000020 90000000045ccd00 [ 0.000000] 900000000470e000 90000000002c1918 0000000000000000 9000000004110780 [ 0.000000] 00000000fe6c0000 0000000480000000 9000000004b4e368 9000000004110748 [ 0.000000] 0000000000000000 900000000421ca84 9000000004620000 9000000004564970 [ 0.000000] 90000000046f7d78 9000000002cc9f70 90000000002c1918 900000000470e000 [ 0.000000] 9000000004564970 90000000040bc0e0 90000000046f7d78 0000000000000000 [ 0.000000] 0000000000004000 90000000045ccd00 0000000000000000 90000000002c1918 [ 0.000000] 90000000002c1900 900000000470b700 9000000004b4df78 9000000004620000 [ 0.000000] 90000000046200a8 90000000046200a8 0000000000000000 9000000004218b2c [ 0.000000] 9000000004270008 0000000000000001 0000000000000000 90000000045ccd00 [ 0.000000] ... [ 0.000000] Call Trace: [ 0.000000] [<90000000040e3f28>] reserve_bootmem_region+0xfc/0x21c [ 0.000000] [<900000000421ca84>] memblock_free_all+0x114/0x350 [ 0.000000] [<9000000004218b2c>] mm_core_init+0x138/0x3cc [ 0.000000] [<9000000004200e38>] start_kernel+0x488/0x7a4 [ 0.000000] [<90000000040df0d8>] kernel_entry+0xd8/0xdc [ 0.000000] [ 0.000000] Code: 02eb21ad 00410f4c 380c31ac <262b818d> 6800b70d 02c1c196 0015001c 57fe4bb1 260002cd The reason is early memblock_reserve() in memblock_init() set node id to MAX_NUMNODES, making NODE_DATA(nid) a NULL dereference in the call chain reserve_bootmem_region() -> init_reserved_page(). After memblock_init(), those late calls of memblock_reserve() operate on subregions of memblock .memory regions. As a result, these reserved regions will be set to the correct node at the first iteration of memmap_init_reserved_pages(). So set all reserved memblocks on Node#0 at initialization can avoid this panic.",
      "id": "CVE-2023-52506",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-13T18:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:15Z"
      },
      "bom-ref": "024e9d10-e8c2-46f6-b9cd-fbc84284bac7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-fc: Prevent null pointer dereference in nvme_fc_io_getuuid() The nvme_fc_fcp_op structure describing an AEN operation is initialized with a null request structure pointer. An FC LLDD may make a call to nvme_fc_io_getuuid passing a pointer to an nvmefc_fcp_req for an AEN operation. Add validation of the request structure pointer before dereference.",
      "id": "CVE-2023-52508",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T16:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:16Z"
      },
      "bom-ref": "bf50123a-42c7-417b-9694-8731150c7a2b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: mana: Fix TX CQE error handling For an unknown TX CQE error type (probably from a newer hardware), still free the SKB, update the queue tail, etc., otherwise the accounting will be wrong. Also, TX errors can be triggered by injecting corrupted packets, so replace the WARN_ONCE to ratelimited error logging.",
      "id": "CVE-2023-52532",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-16T16:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:17Z"
      },
      "bom-ref": "53d9ba63-41cd-46e5-aaec-6ac053501a41",
      "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: dts: qcom: sdm845-db845c: Mark cont splash memory region as reserved Adding a reserved memory region for the framebuffer memory (the splash memory region set up by the bootloader). It fixes a kernel panic (arm-smmu: Unhandled context fault at this particular memory region) reported on DB845c running v5.10.y.",
      "id": "CVE-2023-52561",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T15:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:19Z"
      },
      "bom-ref": "03c0c46b-c538-4c82-b54b-e2f0609496e9",
      "cwes": [
        617
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: remove BUG() after failure to insert delayed dir index item Instead of calling BUG() when we fail to insert a delayed dir index item into the delayed node's tree, we can just release all the resources we have allocated/acquired before and return the error to the caller. This is fine because all existing call chains undo anything they have done before calling btrfs_insert_delayed_dir_index() or BUG_ON (when creating pending snapshots in the transaction commit path). So remove the BUG() call and do proper error handling. This relates to a syzbot report linked below, but does not fix it because it only prevents hitting a BUG(), it does not fix the issue where somehow we attempt to use twice the same index number for different index items.",
      "id": "CVE-2023-52569",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "421f0bce-cb2f-42ad-8e29-f2a8cec5beb6",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix UAF in cifs_demultiplex_thread() There is a UAF when xfstests on cifs: BUG: KASAN: use-after-free in smb2_is_network_name_deleted+0x27/0x160 Read of size 4 at addr ffff88810103fc08 by task cifsd/923 CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45 ... Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_report+0x171/0x472 kasan_report+0xad/0x130 kasan_check_range+0x145/0x1a0 smb2_is_network_name_deleted+0x27/0x160 cifs_demultiplex_thread.cold+0x172/0x5a4 kthread+0x165/0x1a0 ret_from_fork+0x1f/0x30 </TASK> Allocated by task 923: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 __kasan_slab_alloc+0x54/0x60 kmem_cache_alloc+0x147/0x320 mempool_alloc+0xe1/0x260 cifs_small_buf_get+0x24/0x60 allocate_buffers+0xa1/0x1c0 cifs_demultiplex_thread+0x199/0x10d0 kthread+0x165/0x1a0 ret_from_fork+0x1f/0x30 Freed by task 921: kasan_save_stack+0x1e/0x40 kasan_set_track+0x21/0x30 kasan_save_free_info+0x2a/0x40 ____kasan_slab_free+0x143/0x1b0 kmem_cache_free+0xe3/0x4d0 cifs_small_buf_release+0x29/0x90 SMB2_negotiate+0x8b7/0x1c60 smb2_negotiate+0x51/0x70 cifs_negotiate_protocol+0xf0/0x160 cifs_get_smb_ses+0x5fa/0x13c0 mount_get_conns+0x7a/0x750 cifs_mount+0x103/0xd00 cifs_smb3_do_mount+0x1dd/0xcb0 smb3_get_tree+0x1d5/0x300 vfs_get_tree+0x41/0xf0 path_mount+0x9b3/0xdd0 __x64_sys_mount+0x190/0x1d0 do_syscall_64+0x35/0x80 entry_SYSCALL_64_after_hwframe+0x46/0xb0 The UAF is because: mount(pid: 921) | cifsd(pid: 923) -------------------------------|------------------------------- | cifs_demultiplex_thread SMB2_negotiate | cifs_send_recv | compound_send_recv | smb_send_rqst | wait_for_response | wait_event_state [1] | | standard_receive3 | cifs_handle_standard | handle_mid | mid->resp_buf = buf; [2] | dequeue_mid [3] KILL the process [4] | resp_iov[i].iov_base = buf | free_rsp_buf [5] | | is_network_name_deleted [6] | callback 1. After send request to server, wait the response until mid->mid_state != SUBMITTED; 2. Receive response from server, and set it to mid; 3. Set the mid state to RECEIVED; 4. Kill the process, the mid state already RECEIVED, get 0; 5. Handle and release the negotiate response; 6. UAF. It can be easily reproduce with add some delay in [3] - [6]. Only sync call has the problem since async call's callback is executed in cifsd process. Add an extra state to mark the mid state to READY before wakeup the waitter, then it can get the resp safely.",
      "id": "CVE-2023-52572",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:20Z"
      },
      "bom-ref": "23a4cf95-01bf-469e-92ce-6c1e59f9a192",
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/mm, kexec, ima: Use memblock_free_late() from ima_free_kexec_buffer() The code calling ima_free_kexec_buffer() runs long after the memblock allocator has already been torn down, potentially resulting in a use after free in memblock_isolate_range(). With KASAN or KFENCE, this use after free will result in a BUG from the idle task, and a subsequent kernel panic. Switch ima_free_kexec_buffer() over to memblock_free_late() to avoid that bug.",
      "id": "CVE-2023-52576",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T15:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:22Z"
      },
      "bom-ref": "3fff46a4-001e-48f8-86d1-12a5ec979251",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfs: Only call folio_start_fscache() one time for each folio If a network filesystem using netfs implements a clamp_length() function, it can set subrequest lengths smaller than a page size. When we loop through the folios in netfs_rreq_unlock_folios() to set any folios to be written back, we need to make sure we only call folio_start_fscache() once for each folio. Otherwise, this simple testcase: mount -o fsc,rsize=1024,wsize=1024 127.0.0.1:/export /mnt/nfs dd if=/dev/zero of=/mnt/nfs/file.bin bs=4096 count=1 1+0 records in 1+0 records out 4096 bytes (4.1 kB, 4.0 KiB) copied, 0.0126359 s, 324 kB/s echo 3 > /proc/sys/vm/drop_caches cat /mnt/nfs/file.bin > /dev/null will trigger an oops similar to the following: page dumped because: VM_BUG_ON_FOLIO(folio_test_private_2(folio)) ------------[ cut here ]------------ kernel BUG at include/linux/netfs.h:44! ... CPU: 5 PID: 134 Comm: kworker/u16:5 Kdump: loaded Not tainted 6.4.0-rc5 ... RIP: 0010:netfs_rreq_unlock_folios+0x68e/0x730 [netfs] ... Call Trace: netfs_rreq_assess+0x497/0x660 [netfs] netfs_subreq_terminated+0x32b/0x610 [netfs] nfs_netfs_read_completion+0x14e/0x1a0 [nfs] nfs_read_completion+0x2f9/0x330 [nfs] rpc_free_task+0x72/0xa0 [sunrpc] rpc_async_release+0x46/0x70 [sunrpc] process_one_work+0x3bd/0x710 worker_thread+0x89/0x610 kthread+0x181/0x1c0 ret_from_fork+0x29/0x50",
      "id": "CVE-2023-52582",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-16T17:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ARCH_MEDIATEK is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "a600c081-7dc6-4e07-b560-9251b48a481f",
      "description": "In the Linux kernel, the following vulnerability has been resolved: spmi: mediatek: Fix UAF on device remove The pmif driver data that contains the clocks is allocated along with spmi_controller. On device remove, spmi_controller will be freed first, and then devres , including the clocks, will be cleanup. This leads to UAF because putting the clocks will access the clocks in the pmif driver data, which is already freed along with spmi_controller. This can be reproduced by enabling DEBUG_TEST_DRIVER_REMOVE and building the kernel with KASAN. Fix the UAF issue by using unmanaged clk_bulk_get() and putting the clocks before freeing spmi_controller.",
      "id": "CVE-2023-52584",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-14T18:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e94384f3-527f-49df-9d46-cee5cee7b06e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix possible NULL dereference in amdgpu_ras_query_error_status_helper() Return invalid error code -EINVAL for invalid block id. Fixes the below: drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c:1183 amdgpu_ras_query_error_status_helper() error: we previously assumed 'info' could be null (see line 1176)",
      "id": "CVE-2023-52585",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-14T18:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "1d74b3de-84dd-43d4-88af-351634fe1beb",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/msm/dpu: Add mutex lock in control vblank irq Add a mutex lock to control vblank irq to synchronize vblank enable/disable operations happening from different threads to prevent race conditions while registering/unregistering the vblank irq callback. v4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a parameter of dpu_encoder_phys. -Switch from atomic refcnt to a simple int counter as mutex has now been added v3: Mistakenly did not change wording in last version. It is done now. v2: Slightly changed wording of commit message Patchwork: https://patchwork.freedesktop.org/patch/571854/",
      "id": "CVE-2023-52586",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T15:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:23Z"
      },
      "bom-ref": "3c9cb82d-e7af-499c-b1fe-929eb3bff4ad",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: rkisp1: Fix IRQ disable race issue In rkisp1_isp_stop() and rkisp1_csi_disable() the driver masks the interrupts and then apparently assumes that the interrupt handler won't be running, and proceeds in the stop procedure. This is not the case, as the interrupt handler can already be running, which would lead to the ISP being disabled while the interrupt handler handling a captured frame. This brings up two issues: 1) the ISP could be powered off while the interrupt handler is still running and accessing registers, leading to board lockup, and 2) the interrupt handler code and the code that disables the streaming might do things that conflict. It is not clear to me if 2) causes a real issue, but 1) can be seen with a suitable delay (or printk in my case) in the interrupt handler, leading to board lockup.",
      "id": "CVE-2023-52589",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T16:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:25Z"
      },
      "bom-ref": "f953726b-0e0b-492b-a312-2302c8775a4e",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: Avoid touching renamed directory if parent does not change The VFS will not be locking moved directory if its parent does not change. Change ocfs2 rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
      "id": "CVE-2023-52590",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T16:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:27Z"
      },
      "bom-ref": "760b92a8-f24e-48a4-ae96-7cbc72bbcc19",
      "description": "In the Linux kernel, the following vulnerability has been resolved: reiserfs: Avoid touching renamed directory if parent does not change The VFS will not be locking moved directory if its parent does not change. Change reiserfs rename code to avoid touching renamed directory if its parent does not change as without locking that can corrupt the filesystem.",
      "id": "CVE-2023-52591",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-14T18:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:28Z"
      },
      "bom-ref": "421c352d-a87a-4788-987a-81a06f26ff8f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: wfx: fix possible NULL pointer dereference in wfx_set_mfp_ap() Since 'ieee80211_beacon_get()' can return NULL, 'wfx_set_mfp_ap()' should check the return value before examining skb data. So convert the latter to return an appropriate error code and propagate it to return from 'wfx_start_ap()' as well. Compile tested only.",
      "id": "CVE-2023-52593",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-12T15:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:29Z"
      },
      "bom-ref": "07b13307-3992-47f1-a3a0-f78e662ca0d9",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: sysctl: Fix out of bounds access for empty sysctl registers When registering tables to the sysctl subsystem there is a check to see if header is a permanently empty directory (used for mounts). This check evaluates the first element of the ctl_table. This results in an out of bounds evaluation when registering empty directories. The function register_sysctl_mount_point now passes a ctl_table of size 1 instead of size 0. It now relies solely on the type to identify a permanently empty register. Make sure that the ctl_table has at least one element before testing for permanent emptiness.",
      "id": "CVE-2023-52596",
      "published": "2024-03-06T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T16:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "8e07337d-662d-4829-ba23-6f0483fdff98",
      "cwes": [
        617
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Check rcu_read_lock_trace_held() before calling bpf map helpers These three bpf_map_{lookup,update,delete}_elem() helpers are also available for sleepable bpf program, so add the corresponding lock assertion for sleepable bpf program, otherwise the following warning will be reported when a sleepable bpf program manipulates bpf map under interpreter mode (aka bpf_jit_enable=0): WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ...... CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ...... RIP: 0010:bpf_map_lookup_elem+0x54/0x60 ...... Call Trace: <TASK> ? __warn+0xa5/0x240 ? bpf_map_lookup_elem+0x54/0x60 ? report_bug+0x1ba/0x1f0 ? handle_bug+0x40/0x80 ? exc_invalid_op+0x18/0x50 ? asm_exc_invalid_op+0x1b/0x20 ? __pfx_bpf_map_lookup_elem+0x10/0x10 ? rcu_lockdep_current_cpu_online+0x65/0xb0 ? rcu_is_watching+0x23/0x50 ? bpf_map_lookup_elem+0x54/0x60 ? __pfx_bpf_map_lookup_elem+0x10/0x10 ___bpf_prog_run+0x513/0x3b70 __bpf_prog_run32+0x9d/0xd0 ? __bpf_prog_enter_sleepable_recur+0xad/0x120 ? __bpf_prog_enter_sleepable_recur+0x3e/0x120 bpf_trampoline_6442580665+0x4d/0x1000 __x64_sys_getpgid+0x5/0x30 ? do_syscall_64+0x36/0xb0 entry_SYSCALL_64_after_hwframe+0x6e/0x76 </TASK>",
      "id": "CVE-2023-52621",
      "published": "2024-03-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "6df4fc83-79c5-4fdf-8313-390961be64ef",
      "cwes": [
        77
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Wake DMCUB before executing GPINT commands [Why] DMCUB can be in idle when we attempt to interface with the HW through the GPINT mailbox resulting in a system hang. [How] Add dc_wake_and_execute_gpint() to wrap the wake, execute, sleep sequence. If the GPINT executes successfully then DMCUB will be put back into sleep after the optional response is returned. It functions similar to the inbox command interface.",
      "id": "CVE-2023-52624",
      "published": "2024-03-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "199b13c1-c34e-4e60-a2bb-06528e808153",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Refactor DMCUB enter/exit idle interface [Why] We can hang in place trying to send commands when the DMCUB isn't powered on. [How] We need to exit out of the idle state prior to sending a command, but the process that performs the exit also invokes a command itself. Fixing this issue involves the following: 1. Using a software state to track whether or not we need to start the process to exit idle or notify idle. It's possible for the hardware to have exited an idle state without driver knowledge, but entering one is always restricted to a driver allow - which makes the SW state vs HW state mismatch issue purely one of optimization, which should seldomly be hit, if at all. 2. Refactor any instances of exit/notify idle to use a single wrapper that maintains this SW state. This works simialr to dc_allow_idle_optimizations, but works at the DMCUB level and makes sure the state is marked prior to any notify/exit idle so we don't enter an infinite loop. 3. Make sure we exit out of idle prior to sending any commands or waiting for DMCUB idle. This patch takes care of 1/2. A future patch will take care of wrapping DMCUB command submission with calls to this new interface.",
      "id": "CVE-2023-52625",
      "published": "2024-03-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:31Z"
      },
      "bom-ref": "3049cb1a-d07a-4449-802a-d93c5b34adde",
      "description": "In the Linux kernel, the following vulnerability has been resolved: sh: push-switch: Reorder cleanup operations to avoid use-after-free bug The original code puts flush_work() before timer_shutdown_sync() in switch_drv_remove(). Although we use flush_work() to stop the worker, it could be rescheduled in switch_timer(). As a result, a use-after-free bug can occur. The details are shown below: (cpu 0) | (cpu 1) switch_drv_remove() | flush_work() | ... | switch_timer // timer | schedule_work(&psw->work) timer_shutdown_sync() | ... | switch_work_handler // worker kfree(psw) // free | | psw->state = 0 // use This patch puts timer_shutdown_sync() before flush_work() to mitigate the bugs. As a result, the worker and timer will be stopped safely before the deallocate operations.",
      "id": "CVE-2023-52629",
      "published": "2024-03-29T10:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T19:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:32Z"
      },
      "bom-ref": "8fd65787-a808-42f0-9896-6609f0a21cb8",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Fix lock dependency warning with srcu ====================================================== WARNING: possible circular locking dependency detected 6.5.0-kfd-yangp #2289 Not tainted ------------------------------------------------------ kworker/0:2/996 is trying to acquire lock: (srcu){.+.+}-{0:0}, at: __synchronize_srcu+0x5/0x1a0 but task is already holding lock: ((work_completion)(&svms->deferred_list_work)){+.+.}-{0:0}, at: process_one_work+0x211/0x560 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #3 ((work_completion)(&svms->deferred_list_work)){+.+.}-{0:0}: __flush_work+0x88/0x4f0 svm_range_list_lock_and_flush_work+0x3d/0x110 [amdgpu] svm_range_set_attr+0xd6/0x14c0 [amdgpu] kfd_ioctl+0x1d1/0x630 [amdgpu] __x64_sys_ioctl+0x88/0xc0 -> #2 (&info->lock#2){+.+.}-{3:3}: __mutex_lock+0x99/0xc70 amdgpu_amdkfd_gpuvm_restore_process_bos+0x54/0x740 [amdgpu] restore_process_helper+0x22/0x80 [amdgpu] restore_process_worker+0x2d/0xa0 [amdgpu] process_one_work+0x29b/0x560 worker_thread+0x3d/0x3d0 -> #1 ((work_completion)(&(&process->restore_work)->work)){+.+.}-{0:0}: __flush_work+0x88/0x4f0 __cancel_work_timer+0x12c/0x1c0 kfd_process_notifier_release_internal+0x37/0x1f0 [amdgpu] __mmu_notifier_release+0xad/0x240 exit_mmap+0x6a/0x3a0 mmput+0x6a/0x120 do_exit+0x322/0xb90 do_group_exit+0x37/0xa0 __x64_sys_exit_group+0x18/0x20 do_syscall_64+0x38/0x80 -> #0 (srcu){.+.+}-{0:0}: __lock_acquire+0x1521/0x2510 lock_sync+0x5f/0x90 __synchronize_srcu+0x4f/0x1a0 __mmu_notifier_release+0x128/0x240 exit_mmap+0x6a/0x3a0 mmput+0x6a/0x120 svm_range_deferred_list_work+0x19f/0x350 [amdgpu] process_one_work+0x29b/0x560 worker_thread+0x3d/0x3d0 other info that might help us debug this: Chain exists of: srcu --> &info->lock#2 --> (work_completion)(&svms->deferred_list_work) Possible unsafe locking scenario: CPU0 CPU1 ---- ---- lock((work_completion)(&svms->deferred_list_work)); lock(&info->lock#2); lock((work_completion)(&svms->deferred_list_work)); sync(srcu);",
      "id": "CVE-2023-52632",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "16a5990c-833a-4513-a389-e463e80cd96f",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix disable_otg_wa logic [Why] When switching to another HDMI mode, we are unnecesarilly disabling/enabling FIFO causing both HPO and DIG registers to be set at the same time when only HPO is supposed to be set. This can lead to a system hang the next time we change refresh rates as there are cases when we don't disable OTG/FIFO but FIFO is enabled when it isn't supposed to be. [How] Removing the enable/disable FIFO entirely.",
      "id": "CVE-2023-52634",
      "published": "2024-04-02T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "S390 architecture not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "920401e5-d40b-41ab-88b3-fca65b8884bb",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: s390: vsie: fix race during shadow creation Right now it is possible to see gmap->private being zero in kvm_s390_vsie_gmap_notifier resulting in a crash. This is due to the fact that we add gmap->private == kvm after creation: static int acquire_gmap_shadow(struct kvm_vcpu *vcpu, struct vsie_page *vsie_page) { [...] gmap = gmap_shadow(vcpu->arch.gmap, asce, edat); if (IS_ERR(gmap)) return PTR_ERR(gmap); gmap->private = vcpu->kvm; Let children inherit the private field of the parent.",
      "id": "CVE-2023-52639",
      "published": "2024-04-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T15:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:34Z"
      },
      "bom-ref": "3bb92f86-a29c-441d-acae-79067e0cc9f9",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: SUNRPC: fix a memleak in gss_import_v2_context The ctx->mech_used.data allocated by kmemdup is not freed in neither gss_import_v2_context nor it only caller gss_krb5_import_sec_context, which frees ctx on error. Thus, this patch reform the last call of gss_import_v2_context to the gss_krb5_import_ctx_v2, preventing the memleak while keepping the return formation.",
      "id": "CVE-2023-52653",
      "published": "2024-05-01T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T18:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "dc2c584f-362a-487a-bc81-68819c8ae36e",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: atlantic: eliminate double free in error handling logic Driver has a logic leak in ring data allocation/free, where aq_ring_free could be called multiple times on same ring, if system is under stress and got memory allocation error. Ring pointer was used as an indicator of failure, but this is not correct since only ring data is allocated/deallocated. Ring itself is an array member. Changing ring allocation functions to return error code directly. This simplifies error handling and eliminates aq_ring_free on higher layer.",
      "id": "CVE-2023-52664",
      "published": "2024-05-17T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T17:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "7d018860-2bfa-495f-906a-f670e9976dd6",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in lan78xx_disconnect in drivers/net/usb/lan78xx.c in the network sub-component, net/usb/lan78xx in the Linux Kernel. This flaw allows a local attacker to crash the system when the LAN78XX USB device detaches.",
      "id": "CVE-2023-6039",
      "published": "2023-11-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:34Z"
      },
      "bom-ref": "eb57556f-3d91-4b6f-8d2e-adc16ba68d19",
      "cwes": [
        362
      ],
      "description": "A race condition was found in the Linux Kernel. Under certain conditions, an unauthenticated attacker from an adjacent network could send an ICMPv6 router advertisement packet, causing arbitrary code execution.",
      "id": "CVE-2023-6200",
      "published": "2024-01-28T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:34Z"
      },
      "bom-ref": "2c536d59-ffba-49c4-bb0e-99be43f3f343",
      "cwes": [
        416
      ],
      "description": "A flaw was found in the ATA over Ethernet (AoE) driver in the Linux kernel. The aoecmd_cfg_pkts() function improperly updates the refcnt on `struct net_device`, and a use-after-free can be triggered by racing between the free on the struct and the access through the `skbtxq` global queue. This could lead to a denial of service condition or potential code execution.",
      "id": "CVE-2023-6270",
      "published": "2024-01-04T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T19:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:34Z"
      },
      "bom-ref": "bfba225b-251a-41f3-aed6-3758a7e5c629",
      "cwes": [
        362
      ],
      "description": "A use-after-free flaw was found in the Linux Kernel due to a race problem in the unix garbage collector's deletion of SKB races with unix_stream_read_generic() on the socket that the SKB is queued on.",
      "id": "CVE-2023-6531",
      "published": "2024-01-21T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:34Z"
      },
      "bom-ref": "be0b47f3-4db4-49b3-96d9-526a05e0281b",
      "cwes": [
        362
      ],
      "description": "A race condition was found in the GSM 0710 tty multiplexor in the Linux kernel. This issue occurs when two threads execute the GSMIOC_SETCONF ioctl on the same tty file descriptor with the gsm line discipline enabled, and can lead to a use-after-free problem on a struct gsm_dlci while restarting the gsm mux. This could allow a local unprivileged user to escalate their privileges on the system.",
      "id": "CVE-2023-6546",
      "published": "2023-12-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "f0b55b10-c596-47e5-8dcb-64b3eb23e092",
      "cwes": [
        119
      ],
      "description": "An out-of-bounds memory access flaw was found in the io_uring SQ/CQ rings functionality in the Linux kernel. This issue could allow a local user to crash the system.",
      "id": "CVE-2023-6560",
      "published": "2023-12-09T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "c340bfd3-52c4-4673-92f5-7149c3b861af",
      "cwes": [
        476
      ],
      "description": "A null pointer dereference vulnerability was found in nft_dynset_init() in net/netfilter/nft_dynset.c in nf_tables in the Linux kernel. This issue may allow a local attacker with CAP_NET_ADMIN user privilege to trigger a denial of service.",
      "id": "CVE-2023-6622",
      "published": "2023-12-08T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "6a8d8dfe-aa3c-46f0-9e4b-a510c0a6278a",
      "cwes": [
        476
      ],
      "description": "A Null pointer dereference problem was found in ida_free in lib/idr.c in the Linux Kernel. This issue may allow an attacker using this library to cause a denial of service problem due to a missing check at a function return.",
      "id": "CVE-2023-6915",
      "published": "2024-01-15T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "9ff11e27-df05-494a-b2c8-fc668ffb30bd",
      "cwes": [
        787
      ],
      "description": "A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation. A perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group(). We recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.",
      "id": "CVE-2023-6931",
      "published": "2023-12-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T18:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "2f1a6433-cb9a-4bef-9531-adf29a4dcf71",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability in the Linux kernel's ipv4: igmp component can be exploited to achieve local privilege escalation. A race condition can be exploited to cause a timer be mistakenly registered on a RCU read locked object which is freed by another thread. We recommend upgrading past commit e2b706c691905fe78468c361aaabc719d0a496f1.",
      "id": "CVE-2023-6932",
      "published": "2023-12-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T18:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "c3fced26-1d9d-4670-a6ae-2531b888e0be",
      "cwes": [
        401
      ],
      "description": "A memory leak problem was found in ctnetlink_create_conntrack in net/netfilter/nf_conntrack_netlink.c in the Linux Kernel. This issue may allow a local attacker with CAP_NET_ADMIN privileges to cause a denial of service (DoS) attack due to a refcount overflow.",
      "id": "CVE-2023-7192",
      "published": "2024-01-02T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "a869c2c7-0caa-41bd-ae49-11fb39482aa8",
      "cwes": [
        476
      ],
      "description": "A denial of service (DOS) issue was found in the Linux kernel\u2019s smb2_ioctl_query_info function in the fs/cifs/smb2ops.c Common Internet File System (CIFS) due to an incorrect return from the memdup_user function. This flaw allows a local, privileged (CAP_SYS_ADMIN) attacker to crash the system.",
      "id": "CVE-2022-0168",
      "published": "2022-08-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "d6a2f7cd-cee6-4100-b877-ab975fa5e569",
      "cwes": [
        212
      ],
      "description": "A flaw was found in the Linux kernel. The existing KVM SEV API has a vulnerability that allows a non-root (host) user-level application to crash the host kernel by creating a confidential guest VM instance in AMD CPU that supports Secure Encrypted Virtualization (SEV).",
      "id": "CVE-2022-0171",
      "published": "2022-08-26T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "d5ba2f0e-6261-429c-bcd3-a98565bbbb2d",
      "cwes": [
        755
      ],
      "description": "A vulnerability was found in the Linux kernel's eBPF verifier when handling internal data structures. Internal memory locations could be returned to userspace. A local attacker with the permissions to insert eBPF code to the kernel can use this to leak internal kernel memory details defeating some of the exploit mitigations in place for the kernel. This flaws affects kernel versions < v5.16-rc6",
      "id": "CVE-2022-0264",
      "published": "2022-02-04T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "92996026-a4ee-4ca8-9740-75f8ac5aabde",
      "cwes": [
        281
      ],
      "description": "A random memory access flaw was found in the Linux kernel's GPU i915 kernel driver functionality in the way a user may run malicious code on the GPU. This flaw allows a local user to crash the system or escalate their privileges on the system.",
      "id": "CVE-2022-0330",
      "published": "2022-03-25T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "8bc5e1a1-da8e-43c5-a738-bc8d73a5a808",
      "cwes": [
        909
      ],
      "description": "An information leak flaw was found due to uninitialized memory in the Linux kernel's TIPC protocol subsystem, in the way a user sends a TIPC datagram to one or more destinations. This flaw allows a local user to read some kernel memory. This issue is limited to no more than 7 bytes, and the user cannot control what is read. This flaw affects the Linux kernel versions prior to 5.17-rc1.",
      "id": "CVE-2022-0382",
      "published": "2022-02-11T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "5e72d9ca-44fb-46e1-acf0-cd43af64396b",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the Linux kernel's BPF subsystem in the way a user triggers the map_get_next_key function of the BPF bloom filter. This flaw allows a local user to crash the system. This flaw affects Linux kernel versions prior to 5.17-rc1.",
      "id": "CVE-2022-0433",
      "published": "2022-03-10T17:44:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0e850dc9-1350-40af-91eb-9e0b57c1c361",
      "cwes": [
        908
      ],
      "description": "A kernel information leak flaw was identified in the scsi_ioctl function in drivers/scsi/scsi_ioctl.c in the Linux kernel. This flaw allows a local attacker with a special user privilege (CAP_SYS_ADMIN or CAP_SYS_RAWIO) to create issues with confidentiality.",
      "id": "CVE-2022-0494",
      "published": "2022-03-25T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:C/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "857fb628-fda0-49ec-be04-e72b5f71e6ff",
      "description": "A vulnerability was found in kvm_s390_guest_sida_op in the arch/s390/kvm/kvm-s390.c function in KVM for s390 in the Linux kernel. This flaw allows a local attacker with a normal user privilege to obtain unauthorized memory write access. This flaw affects Linux kernel versions prior to 5.17-rc4.",
      "id": "CVE-2022-0516",
      "published": "2022-03-10T17:44:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "ff88f6a4-7dda-4256-9142-a00b890cd69d",
      "cwes": [
        476
      ],
      "description": "A flaw null pointer dereference in the Linux kernel UDF file system functionality was found in the way user triggers udf_file_write_iter function for the malicious UDF image. A local user could use this flaw to crash the system. Actual from Linux kernel 4.2-rc1 till 5.17-rc2.",
      "id": "CVE-2022-0617",
      "published": "2022-02-16T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "5942b181-1425-4ad4-8c91-d47b1948e27d",
      "cwes": [
        401
      ],
      "description": "A memory leak flaw was found in the Linux kernel\u2019s DMA subsystem, in the way a user calls DMA_FROM_DEVICE. This flaw allows a local user to read random memory from the kernel space.",
      "id": "CVE-2022-0854",
      "published": "2022-03-23T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0457029b-9496-4ffc-b3d5-57b29472fe15",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in the Linux kernel\u2019s FUSE filesystem in the way a user triggers write(). This flaw allows a local user to gain unauthorized access to data from the FUSE filesystem, resulting in privilege escalation.",
      "id": "CVE-2022-1011",
      "published": "2022-03-18T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "afa52f6f-ed78-42ce-b152-44357402a966",
      "cwes": [
        401
      ],
      "description": "A memory leak problem was found in the TCP source port generation algorithm in net/ipv4/tcp.c due to the small table perturb size. This flaw may allow an attacker to information leak and may cause a denial of service problem.",
      "id": "CVE-2022-1012",
      "published": "2022-08-05T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.2,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "4e285065-fd0a-4d59-9f8c-5f808d152b5d",
      "cwes": [
        787
      ],
      "description": "A flaw was found in the Linux kernel in linux/net/netfilter/nf_tables_api.c of the netfilter subsystem. This flaw allows a local user to cause an out-of-bounds write issue.",
      "id": "CVE-2022-1015",
      "published": "2022-04-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 6.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "4f995c3c-afb1-4989-b92b-2ee8a27459c4",
      "cwes": [
        909
      ],
      "description": "A flaw was found in the Linux kernel in net/netfilter/nf_tables_core.c:nft_do_chain, which can cause a use-after-free. This issue needs to handle 'return' with proper preconditions, as it can lead to a kernel information leak problem caused by a local, unprivileged attacker.",
      "id": "CVE-2022-1016",
      "published": "2022-08-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "6f1f28f7-7ef2-43e5-8408-06fae0399ad1",
      "cwes": [
        416
      ],
      "description": "A use-after-free exists in the Linux Kernel in tc_new_tfilter that could allow a local attacker to gain privilege escalation. The exploit requires unprivileged user namespaces. We recommend upgrading past commit 04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5",
      "id": "CVE-2022-1055",
      "published": "2022-03-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "dc40be47-967d-48d2-94bd-cc3dd4ea87bd",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability was found in the Linux kernel in drivers/net/hamradio. This flaw allows a local attacker with a user privilege to cause a denial of service (DOS) when the mkiss or sixpack device is detached and reclaim resources early.",
      "id": "CVE-2022-1195",
      "published": "2022-04-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "8672208e-3e26-49f6-90a3-ea59710d7130",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.",
      "id": "CVE-2022-1198",
      "published": "2022-08-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0c65006f-7f6f-4904-8a0a-c93b974ed688",
      "description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
      "id": "CVE-2022-1199",
      "published": "2022-08-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0b4d7fdd-db76-4c89-adeb-e50c5fa10d22",
      "cwes": [
        416
      ],
      "description": "A use-after-free flaw was found in the Linux kernel\u2019s Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.",
      "id": "CVE-2022-1204",
      "published": "2022-08-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "35cd128d-f2b5-4533-b2b9-1cf5fda99a93",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s Amateur Radio AX.25 protocol functionality in the way a user connects with the protocol. This flaw allows a local user to crash the system.",
      "id": "CVE-2022-1205",
      "published": "2022-08-31T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "a258ab24-9c8b-4265-a20c-453b8b0ed475",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference issue was found in KVM when releasing a vCPU with dirty ring support enabled. This flaw allows an unprivileged local attacker on the host to issue specific ioctl calls, causing a kernel oops condition that results in a denial of service.",
      "id": "CVE-2022-1263",
      "published": "2022-08-31T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "f762b318-7afc-4f4e-805d-d48334305941",
      "description": "A vulnerability was found in the pfkey_register function in net/key/af_key.c in the Linux kernel. This flaw allows a local, unprivileged user to gain access to kernel memory, leading to a system crash or a leak of internal kernel information.",
      "id": "CVE-2022-1353",
      "published": "2022-04-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 3.6,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0d83e669-cd96-4079-a2db-4cb891e500d3",
      "cwes": [
        416
      ],
      "description": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.",
      "id": "CVE-2022-1734",
      "published": "2022-05-18T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "5cd9b05c-7fa2-4426-8383-53e06bd30d32",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference flaw was found in the Linux kernel\u2019s KVM module, which can lead to a denial of service in the x86_emulate_insn in arch/x86/kvm/emulate.c. This flaw occurs while executing an illegal instruction in guest in the Intel CPU.",
      "id": "CVE-2022-1852",
      "published": "2022-06-30T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "570ab5cb-fa88-45e3-be80-bcc278fba4e9",
      "cwes": [
        121
      ],
      "description": "A vulnerability was found in the Linux kernel's nft_set_desc_concat_parse() function .This flaw allows an attacker to trigger a buffer overflow via nft_set_desc_concat_parse() , causing a denial of service and possibly to run code.",
      "id": "CVE-2022-2078",
      "published": "2022-06-30T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "021ef249-4915-45fb-a788-1f96351c15a7",
      "cwes": [
        476
      ],
      "description": "A flaw was found in the Linux kernel\u2019s KVM when attempting to set a SynIC IRQ. This issue makes it possible for a misbehaving VMM to write to SYNIC/STIMER MSRs, causing a NULL pointer dereference. This flaw allows an unprivileged local attacker on the host to issue specific ioctl calls, causing a kernel oops condition that results in a denial of service.",
      "id": "CVE-2022-2153",
      "published": "2022-08-31T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "c2ddb6b8-8b31-4f66-ba6c-16cba2ddca6d",
      "cwes": [
        416
      ],
      "description": "There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.",
      "id": "CVE-2022-2318",
      "published": "2022-07-06T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "432d7d54-254a-4735-b4ce-ffc349d8bae7",
      "cwes": [
        787
      ],
      "description": "The Linux kernel was found vulnerable out of bounds memory access in the drivers/video/fbdev/sm712fb.c:smtcfb_read() function. The vulnerability could result in local attackers being able to crash the kernel.",
      "id": "CVE-2022-2380",
      "published": "2022-07-13T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "7f265085-3b21-496b-8632-3b8278fe42a8",
      "cwes": [
        755,
        908
      ],
      "description": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.",
      "id": "CVE-2022-24448",
      "published": "2022-02-04T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 1.9,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "e21e2d59-79a6-444a-a173-fde38cd409a0",
      "cwes": [
        763
      ],
      "description": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.",
      "id": "CVE-2022-24958",
      "published": "2022-02-11T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "9c43dd9b-17dd-45a8-89a9-48ec9f0115cd",
      "cwes": [
        401
      ],
      "description": "An issue was discovered in the Linux kernel before 5.16.5. There is a memory leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.",
      "id": "CVE-2022-24959",
      "published": "2022-02-11T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "e2be5c19-af68-4d8e-ba12-3c41c21b48b3",
      "cwes": [
        287
      ],
      "description": "Dm-verity is used for extending root-of-trust to root filesystems. LoadPin builds on this property to restrict module/firmware loads to just the trusted root filesystem. Device-mapper table reloads currently allow users with root privileges to switch out the target with an equivalent dm-linear target and bypass verification till reboot. This allows root to bypass LoadPin and can be used to load untrusted and unverified kernel modules and firmware, which implies arbitrary kernel execution and persistence for peripherals that do not verify firmware updates. We recommend upgrading past commit 4caae58406f8ceb741603eee460d79bacca9b1b5",
      "id": "CVE-2022-2503",
      "published": "2022-08-12T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "29f0e291-409d-481a-9f22-00465d213c52",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.",
      "id": "CVE-2022-25258",
      "published": "2022-02-16T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: We build the entire system with yocto so there should no old executables that affect us",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "9a78ed6f-5ea8-4df2-bcff-0213910d2305",
      "cwes": [
        913
      ],
      "description": "In the Linux kernel through 5.16.10, certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g., with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.",
      "id": "CVE-2022-25265",
      "published": "2022-02-16T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "6ccb9c9e-7fb7-4d92-ba87-669690a7136a",
      "cwes": [
        1284
      ],
      "description": "An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory.",
      "id": "CVE-2022-25375",
      "published": "2022-02-20T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "38c73ed1-51b5-4cd0-b488-cf279cf9ea13",
      "cwes": [
        416
      ],
      "description": "It was discovered that a nft object or expression could reference a nft set on a different nft table, leading to a use-after-free once that table was deleted.",
      "id": "CVE-2022-2586",
      "published": "2024-01-08T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-19T19:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "a6ff164b-6a53-48ae-85f0-b5fc59650a83",
      "cwes": [
        416
      ],
      "description": "io_uring UAF, Unix SCM garbage collection",
      "id": "CVE-2022-2602",
      "published": "2024-01-08T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "ad9f6926-d349-4405-a933-26e0a6753463",
      "cwes": [
        120
      ],
      "description": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.",
      "id": "CVE-2022-26490",
      "published": "2022-03-06T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T21:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "cfa72cd2-e20b-4cab-999b-d0fe3d045cdf",
      "description": "An issue was discovered in the Linux kernel before 5.16.12. drivers/net/usb/sr9700.c allows attackers to obtain sensitive information from heap memory via crafted frame lengths from a device.",
      "id": "CVE-2022-26966",
      "published": "2022-03-12T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "a93bb3cb-3596-42cf-b03c-0a7c89e28723",
      "cwes": [
        787
      ],
      "description": "A heap buffer overflow flaw was found in IPsec ESP transformation code in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a normal user privilege to overwrite kernel heap objects and may cause a local privilege escalation threat.",
      "id": "CVE-2022-27666",
      "published": "2022-03-23T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "e9139499-f918-40b8-b734-de1e5503a1ac",
      "cwes": [
        125
      ],
      "description": "There exists an arbitrary memory read within the Linux Kernel BPF - Constants provided to fill pointers in structs passed in to bpf_sys_bpf are not verified and can point anywhere, including memory not owned by BPF. An attacker with CAP_BPF can arbitrarily read memory from anywhere on the system. We recommend upgrading past commit 86f44fcec22c",
      "id": "CVE-2022-2785",
      "published": "2022-09-23T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "18115e37-9122-4653-be94-ee9a91146bc2",
      "cwes": [
        401
      ],
      "description": "In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.",
      "id": "CVE-2022-27950",
      "published": "2022-03-28T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "c593fba3-303f-4044-a30e-2f5d8c735eca",
      "description": "In the Linux kernel before 5.17.1, a refcount leak bug was found in net/llc/af_llc.c.",
      "id": "CVE-2022-28356",
      "published": "2022-04-02T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "04acc4bf-1f66-45f3-bf38-8bcfd012f40c",
      "cwes": [
        415
      ],
      "description": "usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free.",
      "id": "CVE-2022-28388",
      "published": "2022-04-03T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0b75b9c3-28f0-4cba-9ad0-f219c12b33fe",
      "cwes": [
        415
      ],
      "description": "mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.",
      "id": "CVE-2022-28389",
      "published": "2022-04-03T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "c1cf2ccf-8060-495c-82b8-ad4d62d42fc9",
      "cwes": [
        415
      ],
      "description": "ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.",
      "id": "CVE-2022-28390",
      "published": "2022-04-03T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T21:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "f812f0c3-bc40-46d8-b4bf-28d41413f778",
      "cwes": [
        131
      ],
      "description": "An out-of-bounds memory access flaw was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way a user triggers the I2C_SMBUS_BLOCK_DATA (with the ioctl I2C_SMBUS) with malicious input data. This flaw allows a local user to crash the system.",
      "id": "CVE-2022-2873",
      "published": "2022-08-22T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "301cb1bf-9d2d-455c-ac48-7cb2af47a722",
      "cwes": [
        125
      ],
      "description": "An out-of-bounds memory read flaw was found in the Linux kernel's BPF subsystem in how a user calls the bpf_tail_call function with a key larger than the max_entries of the map. This flaw allows a local user to gain unauthorized access to data.",
      "id": "CVE-2022-2905",
      "published": "2022-09-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "8cc5d600-2ced-4f7b-ad7b-4a43170e8392",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free due to a race condition in io_uring timeouts. This can be triggered by a local user who has no access to any user namespace; however, the race condition perhaps can only be exploited infrequently.",
      "id": "CVE-2022-29582",
      "published": "2022-04-22T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:C/I:C/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain local user access to the device. Attack Complexity (AC): Attack complexity is High(H). Privileges Required (PR): Low (L) privileges are required. Given that a successful attack requires the user to gain user access to the device due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "56c83ba6-f523-47dc-bcd0-12dc950aabdf",
      "cwes": [
        362
      ],
      "description": "A use-after-free flaw was found in the Linux kernel\u2019s PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
      "id": "CVE-2022-2961",
      "published": "2022-08-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "f8906ca4-ebdb-4b07-82cf-4bdbfaea4eae",
      "cwes": [
        909
      ],
      "description": "An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in fs/io_uring.c lacks initialization of kiocb->private.",
      "id": "CVE-2022-29968",
      "published": "2022-05-02T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "120699b6-d446-4ceb-a981-d99f56f7643f",
      "cwes": [
        120
      ],
      "description": "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.",
      "id": "CVE-2022-3077",
      "published": "2022-09-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-27T17:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0036fffa-4cbb-4e78-899b-386b645d31ff",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. There is a lack of check after calling vzalloc() and lack of free after allocation in drivers/media/test-drivers/vidtv/vidtv_s302m.c.",
      "id": "CVE-2022-3078",
      "published": "2022-09-01T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "8b96fcc8-b8e1-4b85-a0a8-c49457a4f8f2",
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. lkdtm_ARRAY_BOUNDS in drivers/misc/lkdtm/bugs.c lacks check of the return value of kmalloc() and will cause the null pointer dereference.",
      "id": "CVE-2022-3104",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "ac8bfee4-db33-43b3-9d99-0c65e2ac1ae8",
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. uapi_finalize in drivers/infiniband/core/uverbs_uapi.c lacks check of kmalloc_array().",
      "id": "CVE-2022-3105",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "0359c496-1355-4a1e-91c9-f68f911b679e",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. ef100_update_stats in drivers/net/ethernet/sfc/ef100_nic.c lacks check of the return value of kmalloc().",
      "id": "CVE-2022-3106",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T03:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "5f32c79d-604c-42d2-b3e0-9989fa341cdf",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. netvsc_get_ethtool_stats in drivers/net/hyperv/netvsc_drv.c lacks check of the return value of kvmalloc_array() and will cause the null pointer dereference.",
      "id": "CVE-2022-3107",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "e1fd1a6a-5654-4435-9da0-5134dcf5578b",
      "cwes": [
        252
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().",
      "id": "CVE-2022-3108",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "aafc6490-1a67-48b0-a1ec-37ca5bfe2604",
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. _rtw_init_xmit_priv in drivers/staging/r8188eu/core/rtw_xmit.c lacks check of the return value of rtw_alloc_hwxmits() and will cause the null pointer dereference.",
      "id": "CVE-2022-3110",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "9303b45c-bc45-45be-a8e8-62eeccfeb529",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. free_charger_irq() in drivers/power/supply/wm8350_power.c lacks free of WM8350_IRQ_CHG_FAST_RDY, which is registered in wm8350_init_charger().",
      "id": "CVE-2022-3111",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "9bb1fc14-98d0-4e3c-b5d2-44914199d3e3",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. amvdec_set_canvases in drivers/staging/media/meson/vdec/vdec_helpers.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.",
      "id": "CVE-2022-3112",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:36Z"
      },
      "bom-ref": "ec2b7e77-d4f2-4a4d-93dc-f5ca159499e2",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. mtk_vcodec_fw_vpu_init in drivers/media/platform/mtk-vcodec/mtk_vcodec_fw_vpu.c lacks check of the return value of devm_kzalloc() and will cause the null pointer dereference.",
      "id": "CVE-2022-3113",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_PCI, CONFIG_MQ_IOSCHED_DEADLINE, CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_USB_DWC2_DUAL_ROLE, CONFIG_BLK_DEV_MD, CONFIG_ARCH_S32_CLK, CONFIG_ARCH_HAS_RELR, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_SYNC, CONFIG_NET_DSA, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_TRACING, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_ARM, CONFIG_BPF, CONFIG_IOMMU_SUPPORT, CONFIG_USB_DWC3_DUAL_ROLE, CONFIG_USB, CONFIG_SYNC_FILE, CONFIG_PHYLIB, CONFIG_SMP, CONFIG_MODVERSIONS, CONFIG_FRAME_WARN, CONFIG_SYSFS, CONFIG_DM_VERITY_FEC, CONFIG_OF, CONFIG_NET_PTP_CLASSIFY, CONFIG_PCI_QUIRKS, CONFIG_MXC_CLK, CONFIG_POWER_SUPPLY, CONFIG_FRAME_POINTER, CONFIG_MDIO_DEVICE, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_HAS_IOMEM, CONFIG_MODULES, CONFIG_ARC, CONFIG_BPF_SYSCALL, CONFIG_IMX, CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG, CONFIG_OF_FLATTREE, CONFIG_OF_EARLY_FLATTREE, CONFIG_DRM, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_DMA_SHARED_BUFFER, CONFIG_KEXEC_FILE, CONFIG_CLK, CONFIG_COMMON_CLK, CONFIG_ARM64, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_LTO, CONFIG_HWMON, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_EFI_CAPSULE_LOADER, CONFIG_CPU_LITTLE_ENDIAN, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:49:48Z"
      },
      "bom-ref": "6cc52578-ed57-474f-bdc3-ca46960f14ef",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.",
      "id": "CVE-2022-3114",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "622f5607-ba8d-4f65-93dc-f537a0bf9977",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in the Linux kernel through 5.16-rc6. malidp_crtc_reset in drivers/gpu/drm/arm/malidp_crtc.c lacks check of the return value of kzalloc() and will cause the null pointer dereference.",
      "id": "CVE-2022-3115",
      "published": "2022-12-14T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-22T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "587cff07-5fc8-4b8d-a368-fa53ce518728",
      "cwes": [
        330
      ],
      "description": "The Linux kernel before 5.17.9 allows TCP servers to identify clients by observing what source ports are used. This occurs because of use of Algorithm 4 (\"Double-Hash Port Selection Algorithm\") of RFC 6056.",
      "id": "CVE-2022-32296",
      "published": "2022-06-05T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:06:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "c02b79b5-cecf-45d0-b493-a4160f6c2ce0",
      "cwes": [
        120
      ],
      "description": "An issue was discovered in the Linux kernel through 5.18.3 on powerpc 32-bit platforms. There is a buffer overflow in ptrace PEEKUSER and POKEUSER (aka PEEKUSR and POKEUSR) when accessing floating point registers.",
      "id": "CVE-2022-32981",
      "published": "2022-06-10T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:07:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "0d80feb1-8524-494c-91d1-3a3b1453101b",
      "description": "A race condition flaw was found in the Linux kernel sound subsystem due to improper locking. It could lead to a NULL pointer dereference while handling the SNDCTL_DSP_SYNC ioctl. A privileged local user (root or member of the audio group) could use this flaw to crash the system, resulting in a denial of service condition",
      "id": "CVE-2022-3303",
      "published": "2022-09-27T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-21T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "7ff66408-5acd-41e1-8ff1-d270d28df082",
      "description": "A flaw was found in the KVM's AMD nested virtualization (SVM). A malicious L1 guest could purposely fail to intercept the shutdown of a cooperative nested guest (L2), possibly leading to a page fault and kernel panic in the host (L0).",
      "id": "CVE-2022-3344",
      "published": "2022-10-25T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "68ed83f3-de75-4b92-b599-3faf521b4dfc",
      "description": "network backend may cause Linux netfront to use freed SKBs While adding logic to support XDP (eXpress Data Path), a code label was moved in a way allowing for SKBs having references (pointers) retained for further processing to nevertheless be freed.",
      "id": "CVE-2022-33743",
      "published": "2022-07-05T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "fe35379e-1fc7-4c0c-8469-46a4278611f8",
      "description": "Arm guests can cause Dom0 DoS via PV devices When mapping pages of guests on Arm, dom0 is using an rbtree to keep track of the foreign mappings. Updating of that rbtree is not always done completely with the related lock held, resulting in a small race window, which can be used by unprivileged guests via PV devices to cause inconsistencies of the rbtree. These inconsistencies can lead to Denial of Service (DoS) of dom0, e.g. by causing crashes or the inability to perform further mappings of other guests' memory pages.",
      "id": "CVE-2022-33744",
      "published": "2022-07-05T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 1.9,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "ad25c481-2621-489d-9b75-99a6283b13ce",
      "cwes": [
        416
      ],
      "description": "drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to a denial of service, because of a concurrency use-after-free flaw after deallocating raw_cmd in the raw_cmd_ioctl function.",
      "id": "CVE-2022-33981",
      "published": "2022-06-18T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T17:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "8d68c5f0-7a3e-4f8a-a508-a7eeea15ffea",
      "cwes": [
        415
      ],
      "description": "rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.",
      "id": "CVE-2022-34494",
      "published": "2022-06-26T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "df7a7ec7-5eb6-4aa8-8e1d-3b8cecb04030",
      "cwes": [
        415
      ],
      "description": "rpmsg_probe in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.",
      "id": "CVE-2022-34495",
      "published": "2022-06-26T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:37Z"
      },
      "bom-ref": "cb6b7d1b-28d8-4c96-8575-1d513f399d43",
      "cwes": [
        362
      ],
      "description": "A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function kcm_tx_work of the file net/kcm/kcmsock.c of the component kcm. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211018 is the identifier assigned to this vulnerability.",
      "id": "CVE-2022-3521",
      "published": "2022-10-16T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 2.5,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:45Z"
      },
      "bom-ref": "df368b10-d422-4c19-b9c0-54ddc8ee965d",
      "cwes": [
        404
      ],
      "description": "A vulnerability was found in Linux Kernel. It has been rated as problematic. This issue affects the function parse_usdt_arg of the file tools/lib/bpf/usdt.c of the component BPF. The manipulation of the argument reg_name leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211031.",
      "id": "CVE-2022-3533",
      "published": "2022-10-17T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:45Z"
      },
      "bom-ref": "abd16cfd-a809-45d5-aa7f-9ff3ad580d43",
      "cwes": [
        401
      ],
      "description": "A vulnerability, which was classified as problematic, has been found in Linux Kernel. This issue affects the function unix_sock_destructor/unix_release_sock of the file net/unix/af_unix.c of the component BPF. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211043.",
      "id": "CVE-2022-3543",
      "published": "2022-10-17T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "dcb9e8dc-08f7-4621-9d46-c7ccae9dfe7c",
      "cwes": [
        404
      ],
      "description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. Affected is the function damon_sysfs_add_target of the file mm/damon/sysfs.c of the component Netfilter. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211044.",
      "id": "CVE-2022-3544",
      "published": "2022-10-17T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:48Z"
      },
      "bom-ref": "f87f8451-def6-411b-8a05-0de4e0744804",
      "cwes": [
        416
      ],
      "description": "A flaw was found in the Linux kernel\u2019s networking code. A use-after-free was found in the way the sch_sfb enqueue function used the socket buffer (SKB) cb field after the same SKB had been enqueued (and freed) into a child qdisc. This flaw allows a local, unprivileged user to crash the system, causing a denial of service.",
      "id": "CVE-2022-3586",
      "published": "2022-10-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:48Z"
      },
      "bom-ref": "726b0da5-01ca-44fd-b234-2f734a3d29f4",
      "cwes": [
        404
      ],
      "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function intr_callback of the file drivers/net/usb/r8152.c of the component BPF. The manipulation leads to logging of excessive data. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211363.",
      "id": "CVE-2022-3594",
      "published": "2022-10-18T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_CIFS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "2782a5ad-10fe-4413-9a56-9ba80b82d06f",
      "cwes": [
        415
      ],
      "description": "A vulnerability was found in Linux Kernel. It has been rated as problematic. Affected by this issue is the function sess_free_buffer of the file fs/cifs/sess.c of the component CIFS Handler. The manipulation leads to double free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211364.",
      "id": "CVE-2022-3595",
      "published": "2022-10-18T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_ARCH_HAS_RELR, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_BPF, CONFIG_MODVERSIONS, CONFIG_FRAME_WARN, CONFIG_FRAME_POINTER, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_MODULES, CONFIG_ARC, CONFIG_OF_EARLY_FLATTREE, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_LIB, CONFIG_MMU, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_LTO, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:49:54Z"
      },
      "bom-ref": "b7ddd211-4f73-40c9-86bd-5b87e4adcc85",
      "cwes": [
        404
      ],
      "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. This affects the function find_prog_by_sec_insn of the file tools/lib/bpf/libbpf.c of the component BPF. The manipulation leads to null pointer dereference. It is recommended to apply a patch to fix this issue. The identifier VDB-211749 was assigned to this vulnerability.",
      "id": "CVE-2022-3606",
      "published": "2022-10-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "f99aef36-18b9-4853-a62f-12b96a5c6459",
      "description": "The Linux kernel before 5.18.13 lacks a certain clear operation for the block starting symbol (.bss). This allows Xen PV guest OS users to cause a denial of service or gain privileges.",
      "id": "CVE-2022-36123",
      "published": "2022-07-29T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "d00b5755-3399-47f2-b257-aaad62fefc58",
      "description": "An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.",
      "id": "CVE-2022-36879",
      "published": "2022-07-27T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "afefc0d3-c294-44d5-8307-883f5ea2affd",
      "cwes": [
        415
      ],
      "description": "A double-free memory flaw was found in the Linux kernel. The Intel GVT-g graphics driver triggers VGA card system resource overload, causing a fail in the intel_gvt_dma_map_guest_page function. This issue could allow a local user to crash the system.",
      "id": "CVE-2022-3707",
      "published": "2023-03-06T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_DRM_VMWGFX not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "65847d52-9ecb-45b5-a2f8-e95ad1915f55",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference vulnerability was found in vmwgfx driver in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in GPU component of Linux kernel with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
      "id": "CVE-2022-38096",
      "published": "2022-09-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "dd84bd7d-e8ef-4ebc-82a6-7c1c01c9bebd",
      "cwes": [
        416
      ],
      "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_cmd_res_check' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
      "id": "CVE-2022-38457",
      "published": "2022-09-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "5ae9efc6-d298-42d9-b670-d393ceedc136",
      "cwes": [
        362
      ],
      "description": "An issue was discovered in include/asm-generic/tlb.h in the Linux kernel before 5.19. Because of a race condition (unmap_mapping_range versus munmap), a device driver can free a page while it still has stale TLB entries. This only occurs in situations with VM_PFNMAP VMAs.",
      "id": "CVE-2022-39188",
      "published": "2022-09-02T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "40a4f3f9-fd75-4cb9-a1ff-00a70586f792",
      "description": "An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel before 5.19.6. A denial of service can occur upon binding to an already bound chain.",
      "id": "CVE-2022-39190",
      "published": "2022-09-02T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:50Z"
      },
      "bom-ref": "7131c84e-bfde-43f3-8db9-09b43698fef8",
      "cwes": [
        190
      ],
      "description": "An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.",
      "id": "CVE-2022-39842",
      "published": "2022-09-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.1,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:52Z"
      },
      "bom-ref": "adea4fd0-b3b4-4cea-86c1-10e549e05b6f",
      "cwes": [
        416
      ],
      "description": "A use-after-free(UAF) vulnerability was found in function 'vmw_execbuf_tie_context' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege, causing a denial of service(DoS).",
      "id": "CVE-2022-40133",
      "published": "2022-09-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:52Z"
      },
      "bom-ref": "346b0c19-e4e1-4b46-837d-52e74f356cad",
      "cwes": [
        362
      ],
      "description": "An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.",
      "id": "CVE-2022-40307",
      "published": "2022-09-09T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:52Z"
      },
      "bom-ref": "e5fcfbef-69e4-461e-b33d-956921667899",
      "cwes": [
        908
      ],
      "description": "drivers/scsi/stex.c in the Linux kernel through 5.19.9 allows local users to obtain sensitive information from kernel memory because stex_queuecommand_lck lacks a memset for the PASSTHRU_CMD case.",
      "id": "CVE-2022-40768",
      "published": "2022-09-18T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:52Z"
      },
      "bom-ref": "d7aa0315-4e67-41f0-af63-a5a52c552e5f",
      "cwes": [
        416
      ],
      "description": "In drivers/media/dvb-core/dmxdev.c in the Linux kernel through 5.19.10, there is a use-after-free caused by refcount races, affecting dvb_demux_open and dvb_dmxdev_release.",
      "id": "CVE-2022-41218",
      "published": "2022-09-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-28T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:52Z"
      },
      "bom-ref": "42bcb751-4637-43e9-aa97-355599c0001e",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference issue was discovered in the Linux kernel in io_files_update_with_index_alloc. A local user could use this flaw to potentially crash the system causing a denial of service.",
      "id": "CVE-2022-4127",
      "published": "2022-11-28T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "6ae3248b-7836-4a88-9c3a-2305c0c9b421",
      "cwes": [
        362,
        416
      ],
      "description": "drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.",
      "id": "CVE-2022-41848",
      "published": "2022-09-30T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.2,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-20T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "1b4db19a-1567-4da7-8e8b-963211478729",
      "cwes": [
        362,
        416
      ],
      "description": "drivers/video/fbdev/smscufx.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a USB device while calling open(), aka a race condition between ufx_ops_open and ufx_usb_disconnect.",
      "id": "CVE-2022-41849",
      "published": "2022-09-30T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.2,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "3cee0190-8682-4063-89ab-7e449f7d20a7",
      "cwes": [
        362,
        416
      ],
      "description": "roccat_report_event in drivers/hid/hid-roccat.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free in certain situations where a report is received while copying a report->value is in progress.",
      "id": "CVE-2022-41850",
      "published": "2022-09-30T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "0be2c0b0-be06-4ae7-ac9d-c01c16cc9dcb",
      "cwes": [
        667
      ],
      "description": "Guests can trigger deadlock in Linux netback driver T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] The patch for XSA-392 introduced another issue which might result in a deadlock when trying to free the SKB of a packet dropped due to the XSA-392 handling (CVE-2022-42328). Additionally when dropping packages for other reasons the same deadlock could occur in case of netpoll being active for the interface the xen-netback driver is connected to (CVE-2022-42329).",
      "id": "CVE-2022-42328",
      "published": "2022-12-07T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "829b1d8b-b7a8-4566-9351-17411d1829f2",
      "cwes": [
        667
      ],
      "description": "Guests can trigger deadlock in Linux netback driver T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] The patch for XSA-392 introduced another issue which might result in a deadlock when trying to free the SKB of a packet dropped due to the XSA-392 handling (CVE-2022-42328). Additionally when dropping packages for other reasons the same deadlock could occur in case of netpoll being active for the interface the xen-netback driver is connected to (CVE-2022-42329).",
      "id": "CVE-2022-42329",
      "published": "2022-12-07T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-23T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "39cd188e-1cb4-4b6b-ba54-52ec40ce4fa7",
      "cwes": [
        416
      ],
      "description": "mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related to leaf anon_vma double reuse.",
      "id": "CVE-2022-42703",
      "published": "2022-10-09T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "50764682-ceb7-4bf2-9c07-b6fbfa4fb427",
      "cwes": [
        835
      ],
      "description": "A list management bug in BSS handling in the mac80211 stack in the Linux kernel 5.1 through 5.19.x before 5.19.16 could be used by local attackers (able to inject WLAN frames) to corrupt a linked list and, in turn, potentially execute code.",
      "id": "CVE-2022-42721",
      "published": "2022-10-14T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-15T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "f2b5bfd4-ac77-4fa5-8ea0-bc568863d537",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel 5.8 through 5.19.x before 5.19.16, local attackers able to inject WLAN frames into the mac80211 stack could cause a NULL pointer dereference denial-of-service attack against the beacon protection of P2P devices.",
      "id": "CVE-2022-42722",
      "published": "2022-10-14T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:49:53Z"
      },
      "bom-ref": "9b6c9cca-feff-40c9-ad0e-02ecf7d58f0f",
      "cwes": [
        770
      ],
      "description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "id": "CVE-2022-43945",
      "published": "2022-11-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-01T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_PCMCIA not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1367c8c5-12df-4afa-b5ca-fe8ae3ab5ba6",
      "cwes": [
        362
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().",
      "id": "CVE-2022-44032",
      "published": "2022-10-30T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_COMPAT, CONFIG_PCI, CONFIG_MQ_IOSCHED_DEADLINE, CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_USB_DWC2_DUAL_ROLE, CONFIG_BLK_DEV_MD, CONFIG_ARCH_HAS_RELR, CONFIG_HW_RANDOM, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_SYNC, CONFIG_NET_DSA, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_TRACING, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_ARM, CONFIG_BPF, CONFIG_IOMMU_SUPPORT, CONFIG_USB_DWC3_DUAL_ROLE, CONFIG_USB, CONFIG_SYNC_FILE, CONFIG_PHYLIB, CONFIG_SMP, CONFIG_MODVERSIONS, CONFIG_FRAME_WARN, CONFIG_SYSFS, CONFIG_DM_VERITY_FEC, CONFIG_OF, CONFIG_NET_PTP_CLASSIFY, CONFIG_PCI_QUIRKS, CONFIG_POWER_SUPPLY, CONFIG_FRAME_POINTER, CONFIG_MDIO_DEVICE, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_HAS_IOMEM, CONFIG_MODULES, CONFIG_ARC, CONFIG_BPF_SYSCALL, CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG, CONFIG_OF_FLATTREE, CONFIG_OF_EARLY_FLATTREE, CONFIG_DRM, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_DMA_SHARED_BUFFER, CONFIG_KEXEC_FILE, CONFIG_COMMON_CLK, CONFIG_ARM64, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_I2C_CHARDEV, CONFIG_HWMON, CONFIG_LTO, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_EFI_CAPSULE_LOADER, CONFIG_CPU_LITTLE_ENDIAN, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "ce5af140-0e1c-427e-9c65-cbbf4f7e7c55",
      "cwes": [
        362
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().",
      "id": "CVE-2022-44033",
      "published": "2022-10-30T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_COMPAT, CONFIG_PCI, CONFIG_MQ_IOSCHED_DEADLINE, CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_USB_DWC2_DUAL_ROLE, CONFIG_BLK_DEV_MD, CONFIG_ARCH_HAS_RELR, CONFIG_HW_RANDOM, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_SYNC, CONFIG_NET_DSA, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_TRACING, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_ARM, CONFIG_BPF, CONFIG_IOMMU_SUPPORT, CONFIG_USB_DWC3_DUAL_ROLE, CONFIG_USB, CONFIG_SYNC_FILE, CONFIG_PHYLIB, CONFIG_SMP, CONFIG_MODVERSIONS, CONFIG_FRAME_WARN, CONFIG_SYSFS, CONFIG_DM_VERITY_FEC, CONFIG_OF, CONFIG_NET_PTP_CLASSIFY, CONFIG_PCI_QUIRKS, CONFIG_POWER_SUPPLY, CONFIG_FRAME_POINTER, CONFIG_MDIO_DEVICE, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_HAS_IOMEM, CONFIG_MODULES, CONFIG_ARC, CONFIG_BPF_SYSCALL, CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG, CONFIG_OF_FLATTREE, CONFIG_OF_EARLY_FLATTREE, CONFIG_DRM, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_DMA_SHARED_BUFFER, CONFIG_KEXEC_FILE, CONFIG_COMMON_CLK, CONFIG_ARM64, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_I2C_CHARDEV, CONFIG_HWMON, CONFIG_LTO, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_EFI_CAPSULE_LOADER, CONFIG_CPU_LITTLE_ENDIAN, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "d1c52b2a-226f-4f62-b4cc-9227e7984779",
      "cwes": [
        362
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().",
      "id": "CVE-2022-44034",
      "published": "2022-10-30T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Not using intel architecture",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "24d8089b-34dd-41f2-8f98-207eca661f22",
      "cwes": [
        203
      ],
      "description": "A flaw named \"EntryBleed\" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.",
      "id": "CVE-2022-4543",
      "published": "2023-01-11T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-08T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "dc82737d-8d0e-4589-a8cd-0520385c557d",
      "cwes": [
        362
      ],
      "description": "A race condition in the x86 KVM subsystem in the Linux kernel through 6.1-rc6 allows guest OS users to cause a denial of service (host OS crash or host OS memory corruption) when nested virtualisation and the TDP MMU are enabled.",
      "id": "CVE-2022-45869",
      "published": "2022-11-30T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-24T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: TV services or streaming video is not used",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "18c6dc9f-f309-4c71-bb4c-d9996ecee047",
      "cwes": [
        362,
        416
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",
      "id": "CVE-2022-45884",
      "published": "2022-11-25T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: TV services or streaming video is not used",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "53ec894e-7c4f-4e36-9055-9ae00853fec4",
      "cwes": [
        362,
        416
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.",
      "id": "CVE-2022-45885",
      "published": "2022-11-25T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-29T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "a8bf06a0-52a9-4e53-8079-be48b887341b",
      "cwes": [
        362,
        772
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/usb/ttusb-dec/ttusb_dec.c has a memory leak because of the lack of a dvb_frontend_detach call.",
      "id": "CVE-2022-45887",
      "published": "2022-11-25T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-25T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Enabled configs: CONFIG_PCI, CONFIG_MQ_IOSCHED_DEADLINE, CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE, CONFIG_USB_DWC2_DUAL_ROLE, CONFIG_BLK_DEV_MD, CONFIG_ARCH_HAS_RELR, CONFIG_ARCH_WANT_LD_ORPHAN_WARN, CONFIG_SYNC, CONFIG_NET_DSA, CONFIG_CLANG_VERSION, CONFIG_LLD_VERSION, CONFIG_ARM, CONFIG_TRACING, CONFIG_ARCH_SUPPORTS_CFI_CLANG, CONFIG_BPF, CONFIG_IOMMU_SUPPORT, CONFIG_USB_DWC3_DUAL_ROLE, CONFIG_USB, CONFIG_SYNC_FILE, CONFIG_PHYLIB, CONFIG_SMP, CONFIG_MODVERSIONS, CONFIG_FRAME_WARN, CONFIG_SYSFS, CONFIG_DM_VERITY_FEC, CONFIG_OF, CONFIG_NET_PTP_CLASSIFY, CONFIG_PCI_QUIRKS, CONFIG_POWER_SUPPLY, CONFIG_FRAME_POINTER, CONFIG_MDIO_DEVICE, CONFIG_HAVE_C_RECORDMCOUNT, CONFIG_HAS_IOMEM, CONFIG_MODULES, CONFIG_ARC, CONFIG_BPF_SYSCALL, CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG, CONFIG_OF_FLATTREE, CONFIG_OF_EARLY_FLATTREE, CONFIG_DRM, CONFIG_CC_IS_GCC, CONFIG_KALLSYMS, CONFIG_MMU, CONFIG_DMA_SHARED_BUFFER, CONFIG_KEXEC_FILE, CONFIG_COMMON_CLK, CONFIG_ARM64, CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN, CONFIG_LTO, CONFIG_HWMON, CONFIG_CC_HAS_ZERO_CALL_USED_REGS, CONFIG_LD_IS_BFD, CONFIG_EFI_CAPSULE_LOADER, CONFIG_CPU_LITTLE_ENDIAN, CONFIG_LD_ORPHAN_WARN",
        "justification": "vulnerable_code_present",
        "state": "affected",
        "timestamp": "2025-07-06T11:50:08Z"
      },
      "bom-ref": "6c11ecab-e35e-456f-a369-e23ad065e231",
      "cwes": [
        362,
        416
      ],
      "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/char/xillybus/xillyusb.c has a race condition and use-after-free during physical removal of a USB device.",
      "id": "CVE-2022-45888",
      "published": "2022-11-25T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "165edd39-5a14-4fa4-b633-7166950e9aa9",
      "cwes": [
        455
      ],
      "description": "A flaw incorrect access control in the Linux kernel USB core subsystem was found in the way user attaches usb device. A local user could use this flaw to crash the system.",
      "id": "CVE-2022-4662",
      "published": "2022-12-22T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-09T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "b9b037a5-ae77-470d-b1c1-b786888e54c8",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel before 6.1.6, a NULL pointer dereference bug in the traffic control subsystem allows an unprivileged user to trigger a denial of service (system crash) via a crafted traffic control configuration that is set up with \"tc qdisc\" and \"tc class\" commands. This affects qdisc_graft in net/sched/sch_api.c.",
      "id": "CVE-2022-47929",
      "published": "2023-01-17T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-04T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "bfc0964e-1ffb-4941-ac5e-f17c58dab805",
      "cwes": [
        125
      ],
      "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2misc.c has an out-of-bounds read and OOPS for SMB2_TREE_CONNECT.",
      "id": "CVE-2022-47938",
      "published": "2022-12-23T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-15T04:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "0c77f8cf-4864-4d07-aeea-aa678f755819",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel before 6.1.3, fs/ntfs3/record.c does not validate resident attribute names. An out-of-bounds write may occur.",
      "id": "CVE-2022-48423",
      "published": "2023-03-19T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-27T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:03Z"
      },
      "bom-ref": "63b6ea95-a853-4bb2-ac4a-7000ba0a19f4",
      "description": "An issue was discovered in drivers/input/input.c in the Linux kernel before 5.17.10. An attacker can cause a denial of service (panic) because input_set_capability mishandles the situation in which an event code falls outside of a bitmap.",
      "id": "CVE-2022-48619",
      "published": "2024-01-12T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:05Z"
      },
      "bom-ref": "f7ea3bf9-9202-463f-b3a1-515c2dd7e6c2",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ceph: drop messages from MDS when unmounting When unmounting all the dirty buffers will be flushed and after the last osd request is finished the last reference of the i_count will be released. Then it will flush the dirty cap/snap to MDSs, and the unmounting won't wait the possible acks, which will ihold the inodes when updating the metadata locally but makes no sense any more, of this. This will make the evict_inodes() to skip these inodes. If encrypt is enabled the kernel generate a warning when removing the encrypt keys when the skipped inodes still hold the keyring: WARNING: CPU: 4 PID: 168846 at fs/crypto/keyring.c:242 fscrypt_destroy_keyring+0x7e/0xd0 CPU: 4 PID: 168846 Comm: umount Tainted: G S 6.1.0-rc5-ceph-g72ead199864c #1 Hardware name: Supermicro SYS-5018R-WR/X10SRW-F, BIOS 2.0 12/17/2015 RIP: 0010:fscrypt_destroy_keyring+0x7e/0xd0 RSP: 0018:ffffc9000b277e28 EFLAGS: 00010202 RAX: 0000000000000002 RBX: ffff88810d52ac00 RCX: ffff88810b56aa00 RDX: 0000000080000000 RSI: ffffffff822f3a09 RDI: ffff888108f59000 RBP: ffff8881d394fb88 R08: 0000000000000028 R09: 0000000000000000 R10: 0000000000000001 R11: 11ff4fe6834fcd91 R12: ffff8881d394fc40 R13: ffff888108f59000 R14: ffff8881d394f800 R15: 0000000000000000 FS: 00007fd83f6f1080(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f918d417000 CR3: 000000017f89a005 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> generic_shutdown_super+0x47/0x120 kill_anon_super+0x14/0x30 ceph_kill_sb+0x36/0x90 [ceph] deactivate_locked_super+0x29/0x60 cleanup_mnt+0xb8/0x140 task_work_run+0x67/0xb0 exit_to_user_mode_prepare+0x23d/0x240 syscall_exit_to_user_mode+0x25/0x60 do_syscall_64+0x40/0x80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fd83dc39e9b Later the kernel will crash when iput() the inodes and dereferencing the \"sb->s_master_keys\", which has been released by the generic_shutdown_super().",
      "id": "CVE-2022-48628",
      "published": "2024-03-02T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-13T18:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:06Z"
      },
      "bom-ref": "f1649d4b-6b5e-4e84-84c6-7440a58064da",
      "description": "In the Linux kernel, the following vulnerability has been resolved: sfc/siena: fix null pointer dereference in efx_hard_start_xmit Like in previous patch for sfc, prevent potential (but unlikely) NULL pointer dereference.",
      "id": "CVE-2022-48646",
      "published": "2024-04-28T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:08Z"
      },
      "bom-ref": "ba8871a2-e31b-413e-bc02-2a4a5c82ee0d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: core: Fix a use-after-free There are two .exit_cmd_priv implementations. Both implementations use resources associated with the SCSI host. Make sure that these resources are still available when .exit_cmd_priv is called by waiting inside scsi_remove_host() until the tag set has been freed. This commit fixes the following use-after-free: ================================================================== BUG: KASAN: use-after-free in srp_exit_cmd_priv+0x27/0xd0 [ib_srp] Read of size 8 at addr ffff888100337000 by task multipathd/16727 Call Trace: <TASK> dump_stack_lvl+0x34/0x44 print_report.cold+0x5e/0x5db kasan_report+0xab/0x120 srp_exit_cmd_priv+0x27/0xd0 [ib_srp] scsi_mq_exit_request+0x4d/0x70 blk_mq_free_rqs+0x143/0x410 __blk_mq_free_map_and_rqs+0x6e/0x100 blk_mq_free_tag_set+0x2b/0x160 scsi_host_dev_release+0xf3/0x1a0 device_release+0x54/0xe0 kobject_put+0xa5/0x120 device_release+0x54/0xe0 kobject_put+0xa5/0x120 scsi_device_dev_release_usercontext+0x4c1/0x4e0 execute_in_process_context+0x23/0x90 device_release+0x54/0xe0 kobject_put+0xa5/0x120 scsi_disk_release+0x3f/0x50 device_release+0x54/0xe0 kobject_put+0xa5/0x120 disk_release+0x17f/0x1b0 device_release+0x54/0xe0 kobject_put+0xa5/0x120 dm_put_table_device+0xa3/0x160 [dm_mod] dm_put_device+0xd0/0x140 [dm_mod] free_priority_group+0xd8/0x110 [dm_multipath] free_multipath+0x94/0xe0 [dm_multipath] dm_table_destroy+0xa2/0x1e0 [dm_mod] __dm_destroy+0x196/0x350 [dm_mod] dev_remove+0x10c/0x160 [dm_mod] ctl_ioctl+0x2c2/0x590 [dm_mod] dm_ctl_ioctl+0x5/0x10 [dm_mod] __x64_sys_ioctl+0xb4/0xf0 dm_ctl_ioctl+0x5/0x10 [dm_mod] __x64_sys_ioctl+0xb4/0xf0 do_syscall_64+0x3b/0x90 entry_SYSCALL_64_after_hwframe+0x46/0xb0",
      "id": "CVE-2022-48666",
      "published": "2024-04-28T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "2b19f11a-f03e-413e-96d7-2775079525cf",
      "cwes": [
        755
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: Fix possible access to freed memory in link clear After modifying the QP to the Error state, all RX WR would be completed with WC in IB_WC_WR_FLUSH_ERR status. Current implementation does not wait for it is done, but destroy the QP and free the link group directly. So there is a risk that accessing the freed memory in tasklet context. Here is a crash example: BUG: unable to handle page fault for address: ffffffff8f220860 #PF: supervisor write access in kernel mode #PF: error_code(0x0002) - not-present page PGD f7300e067 P4D f7300e067 PUD f7300f063 PMD 8c4e45063 PTE 800ffff08c9df060 Oops: 0002 [#1] SMP PTI CPU: 1 PID: 0 Comm: swapper/1 Kdump: loaded Tainted: G S OE 5.10.0-0607+ #23 Hardware name: Inspur NF5280M4/YZMB-00689-101, BIOS 4.1.20 07/09/2018 RIP: 0010:native_queued_spin_lock_slowpath+0x176/0x1b0 Code: f3 90 48 8b 32 48 85 f6 74 f6 eb d5 c1 ee 12 83 e0 03 83 ee 01 48 c1 e0 05 48 63 f6 48 05 00 c8 02 00 48 03 04 f5 00 09 98 8e <48> 89 10 8b 42 08 85 c0 75 09 f3 90 8b 42 08 85 c0 74 f7 48 8b 32 RSP: 0018:ffffb3b6c001ebd8 EFLAGS: 00010086 RAX: ffffffff8f220860 RBX: 0000000000000246 RCX: 0000000000080000 RDX: ffff91db1f86c800 RSI: 000000000000173c RDI: ffff91db62bace00 RBP: ffff91db62bacc00 R08: 0000000000000000 R09: c00000010000028b R10: 0000000000055198 R11: ffffb3b6c001ea58 R12: ffff91db80e05010 R13: 000000000000000a R14: 0000000000000006 R15: 0000000000000040 FS: 0000000000000000(0000) GS:ffff91db1f840000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffff8f220860 CR3: 00000001f9580004 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <IRQ> _raw_spin_lock_irqsave+0x30/0x40 mlx5_ib_poll_cq+0x4c/0xc50 [mlx5_ib] smc_wr_rx_tasklet_fn+0x56/0xa0 [smc] tasklet_action_common.isra.21+0x66/0x100 __do_softirq+0xd5/0x29c asm_call_irq_on_stack+0x12/0x20 </IRQ> do_softirq_own_stack+0x37/0x40 irq_exit_rcu+0x9d/0xa0 sysvec_call_function_single+0x34/0x80 asm_sysvec_call_function_single+0x12/0x20",
      "id": "CVE-2022-48673",
      "published": "2024-05-03T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "88499e4d-7856-433e-97bd-1fcc405eaf96",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: thermal/int340x_thermal: handle data_vault when the value is ZERO_SIZE_PTR In some case, the GDDV returns a package with a buffer which has zero length. It causes that kmemdup() returns ZERO_SIZE_PTR (0x10). Then the data_vault_read() got NULL point dereference problem when accessing the 0x10 value in data_vault. [ 71.024560] BUG: kernel NULL pointer dereference, address: 0000000000000010 This patch uses ZERO_OR_NULL_PTR() for checking ZERO_SIZE_PTR or NULL value in data_vault.",
      "id": "CVE-2022-48703",
      "published": "2024-05-03T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-05T15:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "fcfed455-4f8a-4259-be5e-da2d6d368a61",
      "cwes": [
        20
      ],
      "description": "There is a vulnerability in the linux kernel versions higher than 5.2 (if kernel compiled with config params CONFIG_BPF_SYSCALL=y , CONFIG_BPF=y , CONFIG_CGROUPS=y , CONFIG_CGROUP_BPF=y , CONFIG_HARDENED_USERCOPY not set, and BPF hook to getsockopt is registered). As result of BPF execution, the local user can trigger bug in __cgroup_bpf_run_filter_getsockopt() function that can lead to heap overflow (because of non-hardened usercopy). The impact of attack could be deny of service or possibly privileges escalation.",
      "id": "CVE-2021-20194",
      "published": "2021-02-23T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "c1303242-1be2-489c-8185-c9b057a4c49c",
      "cwes": [
        787
      ],
      "description": "When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.",
      "id": "CVE-2021-33655",
      "published": "2022-07-18T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "6bf35f31-eb49-4d75-aef7-369f8c11113d",
      "cwes": [
        415
      ],
      "description": "A flaw double-free memory corruption in the Linux kernel HCI device initialization subsystem was found in the way user attach malicious HCI TTY Bluetooth device. A local user could use this flaw to crash the system. This flaw affects all the Linux kernel versions starting from 3.13.",
      "id": "CVE-2021-3564",
      "published": "2021-06-08T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "d6aefdf6-3437-4f3b-acac-6f157c561b93",
      "cwes": [
        770
      ],
      "description": "A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.",
      "id": "CVE-2021-3669",
      "published": "2022-08-26T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "b4a750df-a30a-42f5-8445-a20462b72833",
      "cwes": [
        125
      ],
      "description": "An out-of-bounds (OOB) memory read flaw was found in the Qualcomm IPC router protocol in the Linux kernel. A missing sanity check allows a local attacker to gain access to out-of-bounds memory, leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.",
      "id": "CVE-2021-3743",
      "published": "2022-03-04T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 3.6,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must gain access to the secure customer network where the device resides. Given that a successful attack requires a compromise of the network but not specific authentication credentials, the practical exploitability is considered moderate.",
        "state": "not_affected"
      },
      "bom-ref": "6e74df8b-889e-4687-b575-fab17050c863",
      "cwes": [
        281
      ],
      "description": "An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.",
      "id": "CVE-2021-3847",
      "published": "2022-04-01T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 7.2,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:C/I:C/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "9b915cf7-e1fb-46c2-9626-e850a56ff3fd",
      "cwes": [
        401
      ],
      "description": "A memory leak flaw in the Linux kernel's hugetlbfs memory usage was found in the way the user maps some regions of memory twice using shmget() which are aligned to PUD alignment with the fault of some of the memory pages. A local user could use this flaw to get unauthorized access to some data.",
      "id": "CVE-2021-4002",
      "published": "2022-03-03T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 3.6,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:09Z"
      },
      "bom-ref": "8757375a-8769-4d82-bf44-bdf10614bf83",
      "cwes": [
        787
      ],
      "description": "An out-of-bounds (OOB) memory write flaw was found in the NFSD in the Linux kernel. Missing sanity may lead to a write beyond bmval[bmlen-1] in nfsd4_decode_bitmap4 in fs/nfsd/nfs4xdr.c. In this flaw, a local attacker with user privilege may gain access to out-of-bounds memory, leading to a system integrity and confidentiality threat.",
      "id": "CVE-2021-4090",
      "published": "2022-02-18T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:C/I:C/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:12Z"
      },
      "bom-ref": "9f83b134-0635-401d-9df1-50fd64687413",
      "cwes": [
        476
      ],
      "description": "A NULL pointer dereference was found in the Linux kernel's KVM when dirty ring logging is enabled without an active vCPU context. An unprivileged local attacker on the host may use this flaw to cause a kernel oops condition and thus a denial of service by issuing a KVM_XEN_HVM_SET_ATTR ioctl. This flaw affects Linux kernel versions prior to 5.17-rc1.",
      "id": "CVE-2021-4095",
      "published": "2022-03-10T17:44:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 1.9,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "3eb1e770-3bc2-4e44-87a9-c039f022e3b6",
      "cwes": [
        401
      ],
      "description": "A memory leak vulnerability was found in the Linux kernel's eBPF for the Simulated networking device driver in the way user uses BPF for the device such that function nsim_map_alloc_elem being called. A local user could use this flaw to get unauthorized access to some data.",
      "id": "CVE-2021-4135",
      "published": "2022-07-14T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "7e4eee93-3d1b-42fa-b11e-145e6a70726b",
      "cwes": [
        131
      ],
      "description": "A data leak flaw was found in the way XFS_IOC_ALLOCSP IOCTL in the XFS filesystem allowed for size increase of files with unaligned size. A local attacker could use this flaw to leak data on the XFS filesystem otherwise not accessible to them.",
      "id": "CVE-2021-4155",
      "published": "2022-08-24T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "49e3ae15-9d57-4758-9502-ff690cd2aa20",
      "cwes": [
        476
      ],
      "description": "In gc_data_segment in fs/f2fs/gc.c in the Linux kernel before 5.16.3, special files are not considered, leading to a move_data_page NULL pointer dereference.",
      "id": "CVE-2021-44879",
      "published": "2022-02-14T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "4f7d40af-317c-42b9-a5e7-d748b9a50193",
      "cwes": [
        668
      ],
      "description": "The check_alu_op() function in kernel/bpf/verifier.c in the Linux kernel through v5.16-rc5 did not properly update bounds while handling the mov32 instruction, which allows local users to obtain potentially sensitive address information, aka a \"pointer leak.\"",
      "id": "CVE-2021-45402",
      "published": "2022-02-11T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "1420bd97-1266-4968-ac54-01be36eb25e9",
      "cwes": [
        401
      ],
      "description": "A memory leak vulnerability was found in Linux kernel in llcp_sock_connect",
      "id": "CVE-2020-25672",
      "published": "2021-05-25T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:11Z"
      },
      "bom-ref": "b38afbf5-b2a4-426f-aef6-4b3c84507d23",
      "cwes": [
        119
      ],
      "description": "A flaw was found in the JFS filesystem code in the Linux Kernel which allows a local attacker with the ability to set extended attributes to panic the system, causing memory corruption or escalating privileges. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
      "id": "CVE-2020-27815",
      "published": "2021-05-26T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.1,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:13Z"
      },
      "bom-ref": "834f4624-85cb-4761-8ac0-b47ea287e937",
      "description": "A flaw was found in the Linux kernels implementation of audit rules, where a syscall can unexpectedly not be correctly not be logged by the audit subsystem",
      "id": "CVE-2020-35501",
      "published": "2022-03-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 3.6,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:P/I:P/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 3.4,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T05:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:12Z"
      },
      "bom-ref": "f20aea41-b447-471b-af95-1b97d3d4159f",
      "cwes": [
        362
      ],
      "description": "In a Linux KVM guest that has PV TLB enabled, a process in the guest kernel may be able to read memory locations from another process in the same guest. This problem is limit to the host running linux kernel 4.10 with a guest running linux kernel 4.16 or later. The problem mainly affects AMD processors but Intel CPUs cannot be ruled out.",
      "id": "CVE-2019-3016",
      "published": "2020-01-31T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 1.9,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:12Z"
      },
      "bom-ref": "df056d72-e723-4a30-9583-39d7a16c00ad",
      "cwes": [
        835
      ],
      "description": "A flaw was found in the Linux kernel in the function hid_debug_events_read() in drivers/hid/hid-debug.c file which may enter an infinite loop with certain parameters passed from a userspace. A local privileged user (\"root\") can cause a system lock up and a denial of service. Versions from v4.18 and newer are vulnerable.",
      "id": "CVE-2019-3819",
      "published": "2019-01-25T18:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:12Z"
      },
      "bom-ref": "e45e4d6b-91cc-42b0-9dd9-dee53248fb7a",
      "cwes": [
        863
      ],
      "description": "A flaw was found in the way KVM hypervisor handled x2APIC Machine Specific Rregister (MSR) access with nested(=1) virtualization enabled. In that, L1 guest could access L0's APIC register values via L2 guest, when 'virtualize x2APIC mode' is enabled. A guest could use this flaw to potentially crash the host kernel resulting in DoS issue. Kernel versions from 4.16 and newer are vulnerable to this issue.",
      "id": "CVE-2019-3887",
      "published": "2019-04-09T16:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:N/I:N/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 5.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:15Z"
      },
      "bom-ref": "27ad66d5-9145-4b8f-92a8-256e45755d93",
      "cwes": [
        200
      ],
      "description": "The Linux kernel, when using IPv6, allows remote attackers to determine whether a host is sniffing the network by sending an ICMPv6 Echo Request to a multicast address and determining whether an Echo Reply is sent, as demonstrated by thcping.",
      "id": "CVE-2010-4563",
      "published": "2012-02-02T17:55:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:N/A:N)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T01:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:16Z"
      },
      "bom-ref": "6857e3b1-797e-48ea-82c7-2d93ff6b130e",
      "cwes": [
        59
      ],
      "description": "cp, when running with an option to preserve symlinks on multiple OSes, allows local, user-assisted attackers to overwrite arbitrary files via a symlink attack using crafted directories containing multiple source files that are copied to the same destination.",
      "id": "CVE-2007-4998",
      "published": "2008-01-31T21:00:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:C/I:C/A:C)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T00:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:50:18Z"
      },
      "bom-ref": "bfd3213b-24ae-4eac-a348-c1badce38f70",
      "cwes": [
        16
      ],
      "description": "The ugidd RPC interface, by design, allows remote attackers to enumerate valid usernames by specifying arbitrary UIDs that ugidd maps to local user and group names.",
      "id": "CVE-1999-0656",
      "published": "1999-01-01T05:00:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:N/A:N)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T23:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_RTW89_PCI not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5b88138e-8b08-4a1a-9bf6-44a994fa76ed",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: fix null pointer access when abort scan During cancel scan we might use vif that weren't scanning. Fix this by using the actual scanning vif.",
      "id": "CVE-2024-35946",
      "published": "2024-05-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-31T15:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:20Z"
      },
      "bom-ref": "1ac7fbf3-d10c-44f8-bbd4-5f5fd878e06c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: phy: phy_device: Prevent nullptr exceptions on ISR If phydev->irq is set unconditionally, check for valid interrupt handler or fall back to polling mode to prevent nullptr exceptions in interrupt service routine.",
      "id": "CVE-2024-35945",
      "published": "2024-05-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-31T15:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "37dbcee9-c7f5-44fc-8df0-8b18378fd8f3",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: check A-MSDU format more carefully If it looks like there's another subframe in the A-MSDU but the header isn't fully there, we can end up reading data out of bounds, only to discard later. Make this a bit more careful and check if the subframe header can even be present.",
      "id": "CVE-2024-35937",
      "published": "2024-05-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T12:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "75308d20-be39-4f76-9380-199228bd8bd7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: rcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock() For the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y and CONFIG_RCU_LAZY=y, the following scenarios will trigger WARN_ON_ONCE() in the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions: CPU2 CPU11 kthread rcu_nocb_cb_kthread ksys_write rcu_do_batch vfs_write rcu_torture_timer_cb proc_sys_write __kmem_cache_free proc_sys_call_handler kmemleak_free drop_caches_sysctl_handler delete_object_full drop_slab __delete_object shrink_slab put_object lazy_rcu_shrink_scan call_rcu rcu_nocb_flush_bypass __call_rcu_commn rcu_nocb_bypass_lock raw_spin_trylock(&rdp->nocb_bypass_lock) fail atomic_inc(&rdp->nocb_lock_contended); rcu_nocb_wait_contended WARN_ON_ONCE(smp_processor_id() != rdp->cpu); WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)) | |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __| Reproduce this bug with \"echo 3 > /proc/sys/vm/drop_caches\". This commit therefore uses rcu_nocb_try_flush_bypass() instead of rcu_nocb_flush_bypass() in lazy_rcu_shrink_scan(). If the nocb_bypass queue is being flushed, then rcu_nocb_try_flush_bypass will return directly.",
      "id": "CVE-2024-35929",
      "published": "2024-05-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T19:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:21Z"
      },
      "bom-ref": "6bbfa6b2-54af-4477-bc78-934ec41b0cd9",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: selinux: avoid dereference of garbage after mount failure In case kern_mount() fails and returns an error pointer return in the error branch instead of continuing and dereferencing the error pointer. While on it drop the never read static variable selinuxfs_mount.",
      "id": "CVE-2024-35904",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T16:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "750131ac-543e-45b2-bda4-9104da6eb344",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ax25: fix use-after-free bugs caused by ax25_ds_del_timer When the ax25 device is detaching, the ax25_dev_device_down() calls ax25_ds_del_timer() to cleanup the slave_timer. When the timer handler is running, the ax25_ds_del_timer() that calls del_timer() in it will return directly. As a result, the use-after-free bugs could happen, one of the scenarios is shown below: (Thread 1) | (Thread 2) | ax25_ds_timeout() ax25_dev_device_down() | ax25_ds_del_timer() | del_timer() | ax25_dev_put() //FREE | | ax25_dev-> //USE In order to mitigate bugs, when the device is detaching, use timer_shutdown_sync() to stop the timer.",
      "id": "CVE-2024-35887",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-31T18:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:23Z"
      },
      "bom-ref": "897f9949-9396-48ad-9417-9905e5cd94aa",
      "description": "In the Linux kernel, the following vulnerability has been resolved: of: module: prevent NULL pointer dereference in vsnprintf() In of_modalias(), we can get passed the str and len parameters which would cause a kernel oops in vsnprintf() since it only allows passing a NULL ptr when the length is also 0. Also, we need to filter out the negative values of the len parameter as these will result in a really huge buffer since snprintf() takes size_t parameter while ours is ssize_t... Found by Linux Verification Center (linuxtesting.org) with the Svace static analysis tool.",
      "id": "CVE-2024-35878",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-07T18:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:24Z"
      },
      "bom-ref": "5117bc33-201d-4498-9839-74141c074621",
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix UAF in smb2_reconnect_server() The UAF bug is due to smb2_reconnect_server() accessing a session that is already being teared down by another thread that is executing __cifs_put_smb_ses(). This can happen when (a) the client has connection to the server but no session or (b) another thread ends up setting @ses->ses_status again to something different than SES_EXITING. To fix this, we need to make sure to unconditionally set @ses->ses_status to SES_EXITING and prevent any other threads from setting a new status while we're still tearing it down. The following can be reproduced by adding some delay to right after the ipc is freed in __cifs_put_smb_ses() - which will give smb2_reconnect_server() worker a chance to run and then accessing @ses->ipc: kinit ... mount.cifs //srv/share /mnt/1 -o sec=krb5,nohandlecache,echo_interval=10 [disconnect srv] ls /mnt/1 &>/dev/null sleep 30 kdestroy [reconnect srv] sleep 10 umount /mnt/1 ... CIFS: VFS: Verify user has a krb5 ticket and keyutils is installed CIFS: VFS: \\\\srv Send error in SessSetup = -126 CIFS: VFS: Verify user has a krb5 ticket and keyutils is installed CIFS: VFS: \\\\srv Send error in SessSetup = -126 general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI CPU: 3 PID: 50 Comm: kworker/3:1 Not tainted 6.9.0-rc2 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 04/01/2014 Workqueue: cifsiod smb2_reconnect_server [cifs] RIP: 0010:__list_del_entry_valid_or_report+0x33/0xf0 Code: 4f 08 48 85 d2 74 42 48 85 c9 74 59 48 b8 00 01 00 00 00 00 ad de 48 39 c2 74 61 48 b8 22 01 00 00 00 00 74 69 <48> 8b 01 48 39 f8 75 7b 48 8b 72 08 48 39 c6 0f 85 88 00 00 00 b8 RSP: 0018:ffffc900001bfd70 EFLAGS: 00010a83 RAX: dead000000000122 RBX: ffff88810da53838 RCX: 6b6b6b6b6b6b6b6b RDX: 6b6b6b6b6b6b6b6b RSI: ffffffffc02f6878 RDI: ffff88810da53800 RBP: ffff88810da53800 R08: 0000000000000001 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000001 R12: ffff88810c064000 R13: 0000000000000001 R14: ffff88810c064000 R15: ffff8881039cc000 FS: 0000000000000000(0000) GS:ffff888157c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fe3728b1000 CR3: 000000010caa4000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> ? die_addr+0x36/0x90 ? exc_general_protection+0x1c1/0x3f0 ? asm_exc_general_protection+0x26/0x30 ? __list_del_entry_valid_or_report+0x33/0xf0 __cifs_put_smb_ses+0x1ae/0x500 [cifs] smb2_reconnect_server+0x4ed/0x710 [cifs] process_one_work+0x205/0x6b0 worker_thread+0x191/0x360 ? __pfx_worker_thread+0x10/0x10 kthread+0xe2/0x110 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x34/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",
      "id": "CVE-2024-35870",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-07T18:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:26Z"
      },
      "bom-ref": "612b66af-7a77-4f97-8168-5ed667bcbaf8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: guarantee refcounted children from parent session Avoid potential use-after-free bugs when walking DFS referrals, mounting and performing DFS failover by ensuring that all children from parent @tcon->ses are also refcounted. They're all needed across the entire DFS mount. Get rid of @tcon->dfs_ses_list while we're at it, too.",
      "id": "CVE-2024-35869",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-07T18:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "435cfc02-e04a-4000-bf68-58d05a9a9368",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_stats_proc_write() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35868",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T17:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_CIFS not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "766ad949-6303-4dec-9351-5505ea35b9fb",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_stats_proc_show() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35867",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "07f421c6-2a16-4d3c-8e99-07a94e176423",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_dump_full_key() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35866",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:27Z"
      },
      "bom-ref": "e3249258-deb1-4ef6-8025-ce4d1b8f4cfc",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in smb2_is_valid_oplock_break() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35865",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-07T18:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "d9041ef6-9377-425f-bf8a-8d0f86aa1b25",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in smb2_is_valid_lease_break() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35864",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T14:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB_SERVER not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "cb0da5f8-92ff-4cfc-b0b4-fc19b4eecdbb",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in is_valid_oplock_break() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35863",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T14:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "2ca0eb77-4186-4f93-8824-4893f284bf7f",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in smb2_is_network_name_deleted() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35862",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T15:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "fe622c93-5299-405c-bd23-f6cdf5100984",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential UAF in cifs_signal_cifsd_for_reconnect() Skip sessions that are being teared down (status == SES_EXITING) to avoid UAF.",
      "id": "CVE-2024-35861",
      "published": "2024-05-19T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T14:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:29Z"
      },
      "bom-ref": "db0fc95f-3cd5-4716-b704-b76b84fadddd",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb3: missing lock when picking channel Coverity spotted a place where we should have been holding the channel lock when accessing the ses channel index. Addresses-Coverity: 1582039 (\"Data race condition (MISSING_LOCK)\")",
      "id": "CVE-2024-35999",
      "published": "2024-05-20T10:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-04T14:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:30Z"
      },
      "bom-ref": "ab68d5b8-6cde-4440-bbc9-a2b4429b292c",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb3: fix lock ordering potential deadlock in cifs_sync_mid_result Coverity spotted that the cifs_sync_mid_result function could deadlock \"Thread deadlock (ORDER_REVERSAL) lock_order: Calling spin_lock acquires lock TCP_Server_Info.srv_lock while holding lock TCP_Server_Info.mid_lock\" Addresses-Coverity: 1590401 (\"Thread deadlock (ORDER_REVERSAL)\")",
      "id": "CVE-2024-35998",
      "published": "2024-05-20T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-10T18:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ARCH_MEDIATEK is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "ab45c563-234a-42c7-be57-b452480f905c",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/mediatek: Fix coverity issue with unintentional integer overflow 1. Instead of multiplying 2 variable of different types. Change to assign a value of one variable and then multiply the other variable. 2. Add a int variable for multiplier calculation instead of calculating different types multiplier with dma_addr_t variable directly.",
      "id": "CVE-2023-52857",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-28T22:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "6ebea513-4063-4fb6-8983-1b5e3e3094e0",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nbd: fix uaf in nbd_open Commit 4af5f2e03013 (\"nbd: use blk_mq_alloc_disk and blk_cleanup_disk\") cleans up disk by blk_cleanup_disk() and it won't set disk->private_data as NULL as before. UAF may be triggered in nbd_open() if someone tries to open nbd device right after nbd_put() since nbd has been free in nbd_dev_remove(). Fix this by implementing ->free_disk and free private data in it.",
      "id": "CVE-2023-52837",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-15T18:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as as the functionality is not configured in kernel.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "f7c69cdf-c872-4d61-b649-2b2c48c050ab",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix possible out-of-bound read in ath12k_htt_pull_ppdu_stats() len is extracted from HTT message and could be an unexpected value in case errors happen, so add validation before using to avoid possible out-of-bound read in the following message iteration and parsing. The same issue also applies to ppdu_info->ppdu_stats.common.num_users, so validate it before using too. These are found during code review. Compile test only.",
      "id": "CVE-2023-52827",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config as we're not using AMD CPUs on the devices",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "8c5a8418-aab3-4496-a796-97ca7b860c82",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd: check num of link levels when update pcie param In SR-IOV environment, the value of pcie_table->num_of_link_levels will be 0, and num_of_levels - 1 will cause array index out of bounds",
      "id": "CVE-2023-52812",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-30T20:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_GFS2_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fa2e7c3b-6bc4-45a5-ac94-df46fb0cd51c",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gfs2: Fix slab-use-after-free in gfs2_qd_dealloc In gfs2_put_super(), whether withdrawn or not, the quota should be cleaned up by gfs2_quota_cleanup(). Otherwise, struct gfs2_sbd will be freed before gfs2_qd_dealloc (rcu callback) has run for all gfs2_quota_data objects, resulting in use-after-free. Also, gfs2_destroy_threads() and gfs2_quota_cleanup() is already called by gfs2_make_fs_ro(), so in gfs2_put_super(), after calling gfs2_make_fs_ro(), there is no need to call them again.",
      "id": "CVE-2023-52760",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB not set in kernel config.",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "805275a3-1e31-492a-a2ab-57b46371fb70",
      "cwes": [
        416,
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix potential deadlock when releasing mids All release_mid() callers seem to hold a reference of @mid so there is no need to call kref_put(&mid->refcount, __release_mid) under @server->mid_lock spinlock. If they don't, then an use-after-free bug would have occurred anyways. By getting rid of such spinlock also fixes a potential deadlock as shown below CPU 0 CPU 1 ------------------------------------------------------------------ cifs_demultiplex_thread() cifs_debug_data_proc_show() release_mid() spin_lock(&server->mid_lock); spin_lock(&cifs_tcp_ses_lock) spin_lock(&server->mid_lock) __release_mid() smb2_find_smb_tcon() spin_lock(&cifs_tcp_ses_lock) *deadlock*",
      "id": "CVE-2023-52757",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_CIFS is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "377a8998-1bd2-41f5-937a-0b5c46edc0c4",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free bug in cifs_debug_data_proc_show() Skip SMB sessions that are being teared down (e.g. @ses->ses_status == SES_EXITING) in cifs_debug_data_proc_show() to avoid use-after-free in @ses. This fixes the following GPF when reading from /proc/fs/cifs/DebugData while mounting and umounting [ 816.251274] general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6d81: 0000 [#1] PREEMPT SMP NOPTI ... [ 816.260138] Call Trace: [ 816.260329] <TASK> [ 816.260499] ? die_addr+0x36/0x90 [ 816.260762] ? exc_general_protection+0x1b3/0x410 [ 816.261126] ? asm_exc_general_protection+0x26/0x30 [ 816.261502] ? cifs_debug_tcon+0xbd/0x240 [cifs] [ 816.261878] ? cifs_debug_tcon+0xab/0x240 [cifs] [ 816.262249] cifs_debug_data_proc_show+0x516/0xdb0 [cifs] [ 816.262689] ? seq_read_iter+0x379/0x470 [ 816.262995] seq_read_iter+0x118/0x470 [ 816.263291] proc_reg_read_iter+0x53/0x90 [ 816.263596] ? srso_alias_return_thunk+0x5/0x7f [ 816.263945] vfs_read+0x201/0x350 [ 816.264211] ksys_read+0x75/0x100 [ 816.264472] do_syscall_64+0x3f/0x90 [ 816.264750] entry_SYSCALL_64_after_hwframe+0x6e/0xd8 [ 816.265135] RIP: 0033:0x7fd5e669d381",
      "id": "CVE-2023-52752",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB not set in kernel config.",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "d04fc87f-43b9-4310-b4ad-c6e7cd451af3",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free in smb2_query_info_compound() The following UAF was triggered when running fstests generic/072 with KASAN enabled against Windows Server 2022 and mount options 'multichannel,max_channels=2,vers=3.1.1,mfsymlinks,noperm' BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423/0x6d0 [cifs] Read of size 8 at addr ffff888014941048 by task xfs_io/27534 CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 Call Trace: dump_stack_lvl+0x4a/0x80 print_report+0xcf/0x650 ? srso_alias_return_thunk+0x5/0x7f ? srso_alias_return_thunk+0x5/0x7f ? __phys_addr+0x46/0x90 kasan_report+0xda/0x110 ? smb2_query_info_compound+0x423/0x6d0 [cifs] ? smb2_query_info_compound+0x423/0x6d0 [cifs] smb2_query_info_compound+0x423/0x6d0 [cifs] ? __pfx_smb2_query_info_compound+0x10/0x10 [cifs] ? srso_alias_return_thunk+0x5/0x7f ? __stack_depot_save+0x39/0x480 ? kasan_save_stack+0x33/0x60 ? kasan_set_track+0x25/0x30 ? ____kasan_slab_free+0x126/0x170 smb2_queryfs+0xc2/0x2c0 [cifs] ? __pfx_smb2_queryfs+0x10/0x10 [cifs] ? __pfx___lock_acquire+0x10/0x10 smb311_queryfs+0x210/0x220 [cifs] ? __pfx_smb311_queryfs+0x10/0x10 [cifs] ? srso_alias_return_thunk+0x5/0x7f ? __lock_acquire+0x480/0x26c0 ? lock_release+0x1ed/0x640 ? srso_alias_return_thunk+0x5/0x7f ? do_raw_spin_unlock+0x9b/0x100 cifs_statfs+0x18c/0x4b0 [cifs] statfs_by_dentry+0x9b/0xf0 fd_statfs+0x4e/0xb0 __do_sys_fstatfs+0x7f/0xe0 ? __pfx___do_sys_fstatfs+0x10/0x10 ? srso_alias_return_thunk+0x5/0x7f ? lockdep_hardirqs_on_prepare+0x136/0x200 ? srso_alias_return_thunk+0x5/0x7f do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Allocated by task 27534: kasan_save_stack+0x33/0x60 kasan_set_track+0x25/0x30 __kasan_kmalloc+0x8f/0xa0 open_cached_dir+0x71b/0x1240 [cifs] smb2_query_info_compound+0x5c3/0x6d0 [cifs] smb2_queryfs+0xc2/0x2c0 [cifs] smb311_queryfs+0x210/0x220 [cifs] cifs_statfs+0x18c/0x4b0 [cifs] statfs_by_dentry+0x9b/0xf0 fd_statfs+0x4e/0xb0 __do_sys_fstatfs+0x7f/0xe0 do_syscall_64+0x3f/0x90 entry_SYSCALL_64_after_hwframe+0x6e/0xd8 Freed by task 27534: kasan_save_stack+0x33/0x60 kasan_set_track+0x25/0x30 kasan_save_free_info+0x2b/0x50 ____kasan_slab_free+0x126/0x170 slab_free_freelist_hook+0xd0/0x1e0 __kmem_cache_free+0x9d/0x1b0 open_cached_dir+0xff5/0x1240 [cifs] smb2_query_info_compound+0x5c3/0x6d0 [cifs] smb2_queryfs+0xc2/0x2c0 [cifs] This is a race between open_cached_dir() and cached_dir_lease_break() where the cache entry for the open directory handle receives a lease break while creating it. And before returning from open_cached_dir(), we put the last reference of the new @cfid because of !@cfid->has_lease. Besides the UAF, while running xfstests a lot of missed lease breaks have been noticed in tests that run several concurrent statfs(2) calls on those cached fids CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108 CIFS: VFS: Dump pending requests: CIFS: VFS: \\\\w22-root1.gandalf.test No task to wake, unknown frame... CIFS: VFS: \\\\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1... CIFS: VFS: \\\\w22-root1.gandalf.test smb buf 000000005aa7316e len 108 ... To fix both, in open_cached_dir() ensure that @cfid->has_lease is set right before sending out compounded request so that any potential lease break will be get processed by demultiplex thread while we're still caching @cfid. And, if open failed for some reason, re-check @cfid->has_lease to decide whether or not put lease reference.",
      "id": "CVE-2023-52751",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T20:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:32Z"
      },
      "bom-ref": "2d28836f-f9bd-4b46-80cf-bcdb266e1111",
      "cwes": [
        362,
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: spi: Fix null dereference on suspend A race condition exists where a synchronous (noqueue) transfer can be active during a system suspend. This can cause a null pointer dereference exception to occur when the system resumes. Example order of events leading to the exception: 1. spi_sync() calls __spi_transfer_message_noqueue() which sets ctlr->cur_msg 2. Spi transfer begins via spi_transfer_one_message() 3. System is suspended interrupting the transfer context 4. System is resumed 6. spi_controller_resume() calls spi_start_queue() which resets cur_msg to NULL 7. Spi transfer context resumes and spi_finalize_current_message() is called which dereferences cur_msg (which is now NULL) Wait for synchronous transfers to complete before suspending by acquiring the bus mutex and setting/checking a suspend flag.",
      "id": "CVE-2023-52749",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T20:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_FS_BTRFS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "7718ba1d-0866-47f4-84f8-de1e65221868",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: lock the inode in shared mode before starting fiemap Currently fiemap does not take the inode's lock (VFS lock), it only locks a file range in the inode's io tree. This however can lead to a deadlock if we have a concurrent fsync on the file and fiemap code triggers a fault when accessing the user space buffer with fiemap_fill_next_extent(). The deadlock happens on the inode's i_mmap_lock semaphore, which is taken both by fsync and btrfs_page_mkwrite(). This deadlock was recently reported by syzbot and triggers a trace like the following: task:syz-executor361 state:D stack:20264 pid:5668 ppid:5119 flags:0x00004004 Call Trace: <TASK> context_switch kernel/sched/core.c:5293 [inline] __schedule+0x995/0xe20 kernel/sched/core.c:6606 schedule+0xcb/0x190 kernel/sched/core.c:6682 wait_on_state fs/btrfs/extent-io-tree.c:707 [inline] wait_extent_bit+0x577/0x6f0 fs/btrfs/extent-io-tree.c:751 lock_extent+0x1c2/0x280 fs/btrfs/extent-io-tree.c:1742 find_lock_delalloc_range+0x4e6/0x9c0 fs/btrfs/extent_io.c:488 writepage_delalloc+0x1ef/0x540 fs/btrfs/extent_io.c:1863 __extent_writepage+0x736/0x14e0 fs/btrfs/extent_io.c:2174 extent_write_cache_pages+0x983/0x1220 fs/btrfs/extent_io.c:3091 extent_writepages+0x219/0x540 fs/btrfs/extent_io.c:3211 do_writepages+0x3c3/0x680 mm/page-writeback.c:2581 filemap_fdatawrite_wbc+0x11e/0x170 mm/filemap.c:388 __filemap_fdatawrite_range mm/filemap.c:421 [inline] filemap_fdatawrite_range+0x175/0x200 mm/filemap.c:439 btrfs_fdatawrite_range fs/btrfs/file.c:3850 [inline] start_ordered_ops fs/btrfs/file.c:1737 [inline] btrfs_sync_file+0x4ff/0x1190 fs/btrfs/file.c:1839 generic_write_sync include/linux/fs.h:2885 [inline] btrfs_do_write_iter+0xcd3/0x1280 fs/btrfs/file.c:1684 call_write_iter include/linux/fs.h:2189 [inline] new_sync_write fs/read_write.c:491 [inline] vfs_write+0x7dc/0xc50 fs/read_write.c:584 ksys_write+0x177/0x2a0 fs/read_write.c:637 do_syscall_x64 arch/x86/entry/common.c:50 [inline] do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80 entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7f7d4054e9b9 RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001 RAX: ffffffffffffffda RBX: 00007f7d405d87a0 RCX: 00007f7d4054e9b9 RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006 RBP: 00007f7d405a51d0 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69 R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8 </TASK> INFO: task syz-executor361:5697 blocked for more than 145 seconds. Not tainted 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0 \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. task:syz-executor361 state:D stack:21216 pid:5697 ppid:5119 flags:0x00004004 Call Trace: <TASK> context_switch kernel/sched/core.c:5293 [inline] __schedule+0x995/0xe20 kernel/sched/core.c:6606 schedule+0xcb/0x190 kernel/sched/core.c:6682 rwsem_down_read_slowpath+0x5f9/0x930 kernel/locking/rwsem.c:1095 __down_read_common+0x54/0x2a0 kernel/locking/rwsem.c:1260 btrfs_page_mkwrite+0x417/0xc80 fs/btrfs/inode.c:8526 do_page_mkwrite+0x19e/0x5e0 mm/memory.c:2947 wp_page_shared+0x15e/0x380 mm/memory.c:3295 handle_pte_fault mm/memory.c:4949 [inline] __handle_mm_fault mm/memory.c:5073 [inline] handle_mm_fault+0x1b79/0x26b0 mm/memory.c:5219 do_user_addr_fault+0x69b/0xcb0 arch/x86/mm/fault.c:1428 handle_page_fault arch/x86/mm/fault.c:1519 [inline] exc_page_fault+0x7a/0x110 arch/x86/mm/fault.c:1575 asm_exc_page_fault+0x22/0x30 arch/x86/include/asm/idtentry.h:570 RIP: 0010:copy_user_short_string+0xd/0x40 arch/x86/lib/copy_user_64.S:233 Code: 74 0a 89 (...) RSP: 0018:ffffc9000570f330 EFLAGS: 000502 ---truncated---",
      "id": "CVE-2023-52737",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-10T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:33Z"
      },
      "bom-ref": "a0061767-4847-4c0b-bf0d-3ec25990fe11",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: vdpa: ifcvf: Do proper cleanup if IFCVF init fails ifcvf_mgmt_dev leaks memory if it is not freed before returning. Call is made to correct return statement so memory does not leak. ifcvf_init_hw does not take care of this so it is needed to do it here.",
      "id": "CVE-2022-48706",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T16:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:35Z"
      },
      "bom-ref": "d64fa859-7064-4f71-94c5-d67ac315a94a",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: lib/generic-radix-tree.c: Don't overflow in peek() When we started spreading new inode numbers throughout most of the 64 bit inode space, that triggered some corner case bugs, in particular some integer overflows related to the radix tree code. Oops.",
      "id": "CVE-2021-47432",
      "published": "2024-05-21T16:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T14:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:36Z"
      },
      "bom-ref": "ca2f7822-f27c-4cf0-81e2-732d5b579e65",
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect() Extend a critical section to prevent chan from early freeing. Also make the l2cap_connect() return type void. Nothing is using the returned value but it is ugly to return a potentially freed pointer. Making it void will help with backports because earlier kernels did use the return value. Now the compile will break for kernels where this patch is not a complete fix. Call stack summary: [use] l2cap_bredr_sig_cmd l2cap_connect + mutex_lock(&conn->chan_lock); \u00a6 chan = pchan->ops->new_connection(pchan); <- alloc chan \u00a6 __l2cap_chan_add(conn, chan); \u00a6 l2cap_chan_hold(chan); \u00a6 list_add(&chan->list, &conn->chan_l); ... (1) + mutex_unlock(&conn->chan_lock); chan->conf_state ... (4) <- use after free [free] l2cap_conn_del + mutex_lock(&conn->chan_lock); \u00a6 foreach chan in conn->chan_l: ... (2) \u00a6 l2cap_chan_put(chan); \u00a6 l2cap_chan_destroy \u00a6 kfree(chan) ... (3) <- chan freed + mutex_unlock(&conn->chan_lock); ================================================================== BUG: KASAN: slab-use-after-free in instrument_atomic_read include/linux/instrumented.h:68 [inline] BUG: KASAN: slab-use-after-free in _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline] BUG: KASAN: slab-use-after-free in l2cap_connect+0xa67/0x11a0 net/bluetooth/l2cap_core.c:4260 Read of size 8 at addr ffff88810bf040a0 by task kworker/u3:1/311",
      "id": "CVE-2024-36013",
      "published": "2024-05-23T07:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T18:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "d7e8cb9f-f696-45d0-a32d-ec47bc36df15",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: msft: fix slab-use-after-free in msft_do_close() Tying the msft->data lifetime to hdev by freeing it in hci_release_dev() to fix the following case: [use] msft_do_close() msft = hdev->msft_data; if (!msft) ...(1) <- passed. return; mutex_lock(&msft->filter_lock); ...(4) <- used after freed. [free] msft_unregister() msft = hdev->msft_data; hdev->msft_data = NULL; ...(2) kfree(msft); ...(3) <- msft is freed. ================================================================== BUG: KASAN: slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c:587 [inline] BUG: KASAN: slab-use-after-free in __mutex_lock+0x8f/0xc30 kernel/locking/mutex.c:752 Read of size 8 at addr ffff888106cbbca8 by task kworker/u5:2/309",
      "id": "CVE-2024-36012",
      "published": "2024-05-23T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T22:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:38Z"
      },
      "bom-ref": "742c5c89-f5db-4aa2-bdc4-c91de17a9d67",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Julia Lawall reported this null pointer dereference, this should fix it.",
      "id": "CVE-2024-36023",
      "published": "2024-05-30T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:39Z"
      },
      "bom-ref": "024687b5-c622-4e4a-a31d-6f8ffd81305e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: tcpm: Check for port partner validity before consuming it typec_register_partner() does not guarantee partner registration to always succeed. In the event of failure, port->partner is set to the error value or NULL. Given that port->partner validity is not checked, this results in the following crash: Unable to handle kernel NULL pointer dereference at virtual address xx pc : run_state_machine+0x1bc8/0x1c08 lr : run_state_machine+0x1b90/0x1c08 .. Call trace: run_state_machine+0x1bc8/0x1c08 tcpm_state_machine_work+0x94/0xe4 kthread_worker_fn+0x118/0x328 kthread+0x1d0/0x23c ret_from_fork+0x10/0x20 To prevent the crash, check for port->partner validity before derefencing it in all the call sites.",
      "id": "CVE-2024-36893",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "5a60fb84-ef84-4e83-a9fd-88fb87586cbb",
      "cwes": [
        362,
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gpiolib: cdev: Fix use after free in lineinfo_changed_notify The use-after-free issue occurs as follows: when the GPIO chip device file is being closed by invoking gpio_chrdev_release(), watched_lines is freed by bitmap_free(), but the unregistration of lineinfo_changed_nb notifier chain failed due to waiting write rwsem. Additionally, one of the GPIO chip's lines is also in the release process and holds the notifier chain's read rwsem. Consequently, a race condition leads to the use-after-free of watched_lines. Here is the typical stack when issue happened: [free] gpio_chrdev_release() --> bitmap_free(cdev->watched_lines) <-- freed --> blocking_notifier_chain_unregister() --> down_write(&nh->rwsem) <-- waiting rwsem --> __down_write_common() --> rwsem_down_write_slowpath() --> schedule_preempt_disabled() --> schedule() [use] st54spi_gpio_dev_release() --> gpio_free() --> gpiod_free() --> gpiod_free_commit() --> gpiod_line_state_notify() --> blocking_notifier_call_chain() --> down_read(&nh->rwsem); <-- held rwsem --> notifier_call_chain() --> lineinfo_changed_notify() --> test_bit(xxxx, cdev->watched_lines) <-- use after free The side effect of the use-after-free issue is that a GPIO line event is being generated for userspace where it shouldn't. However, since the chrdev is being closed, userspace won't have the chance to read that event anyway. To fix the issue, call the bitmap_free() function after the unregistration of lineinfo_changed_nb notifier chain.",
      "id": "CVE-2024-36899",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:41Z"
      },
      "bom-ref": "1890e815-6016-4065-a2b9-78b9c9f29658",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: prevent NULL dereference in ip6_output() According to syzbot, there is a chance that ip6_dst_idev() returns NULL in ip6_output(). Most places in IPv6 stack deal with a NULL idev just fine, but not here. syzbot reported: general protection fault, probably for non-canonical address 0xdffffc00000000bc: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x00000000000005e0-0x00000000000005e7] CPU: 0 PID: 9775 Comm: syz-executor.4 Not tainted 6.9.0-rc5-syzkaller-00157-g6a30653b604a #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 RIP: 0010:ip6_output+0x231/0x3f0 net/ipv6/ip6_output.c:237 Code: 3c 1e 00 49 89 df 74 08 4c 89 ef e8 19 58 db f7 48 8b 44 24 20 49 89 45 00 49 89 c5 48 8d 9d e0 05 00 00 48 89 d8 48 c1 e8 03 <42> 0f b6 04 38 84 c0 4c 8b 74 24 28 0f 85 61 01 00 00 8b 1b 31 ff RSP: 0018:ffffc9000927f0d8 EFLAGS: 00010202 RAX: 00000000000000bc RBX: 00000000000005e0 RCX: 0000000000040000 RDX: ffffc900131f9000 RSI: 0000000000004f47 RDI: 0000000000004f48 RBP: 0000000000000000 R08: ffffffff8a1f0b9a R09: 1ffffffff1f51fad R10: dffffc0000000000 R11: fffffbfff1f51fae R12: ffff8880293ec8c0 R13: ffff88805d7fc000 R14: 1ffff1100527d91a R15: dffffc0000000000 FS: 00007f135c6856c0(0000) GS:ffff8880b9400000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000080 CR3: 0000000064096000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> NF_HOOK include/linux/netfilter.h:314 [inline] ip6_xmit+0xefe/0x17f0 net/ipv6/ip6_output.c:358 sctp_v6_xmit+0x9f2/0x13f0 net/sctp/ipv6.c:248 sctp_packet_transmit+0x26ad/0x2ca0 net/sctp/output.c:653 sctp_packet_singleton+0x22c/0x320 net/sctp/outqueue.c:783 sctp_outq_flush_ctrl net/sctp/outqueue.c:914 [inline] sctp_outq_flush+0x6d5/0x3e20 net/sctp/outqueue.c:1212 sctp_side_effects net/sctp/sm_sideeffect.c:1198 [inline] sctp_do_sm+0x59cc/0x60c0 net/sctp/sm_sideeffect.c:1169 sctp_primitive_ASSOCIATE+0x95/0xc0 net/sctp/primitive.c:73 __sctp_connect+0x9cd/0xe30 net/sctp/socket.c:1234 sctp_connect net/sctp/socket.c:4819 [inline] sctp_inet_connect+0x149/0x1f0 net/sctp/socket.c:4834 __sys_connect_file net/socket.c:2048 [inline] __sys_connect+0x2df/0x310 net/socket.c:2065 __do_sys_connect net/socket.c:2075 [inline] __se_sys_connect net/socket.c:2072 [inline] __x64_sys_connect+0x7a/0x90 net/socket.c:2072 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-36901",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:42Z"
      },
      "bom-ref": "25df523d-9a85-4247-b460-a6a5c0a86442",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: fib6_rules: avoid possible NULL dereference in fib6_rule_action() syzbot is able to trigger the following crash [1], caused by unsafe ip6_dst_idev() use. Indeed ip6_dst_idev() can return NULL, and must always be checked. [1] Oops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 0 PID: 31648 Comm: syz-executor.0 Not tainted 6.9.0-rc4-next-20240417-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 RIP: 0010:__fib6_rule_action net/ipv6/fib6_rules.c:237 [inline] RIP: 0010:fib6_rule_action+0x241/0x7b0 net/ipv6/fib6_rules.c:267 Code: 02 00 00 49 8d 9f d8 00 00 00 48 89 d8 48 c1 e8 03 42 80 3c 20 00 74 08 48 89 df e8 f9 32 bf f7 48 8b 1b 48 89 d8 48 c1 e8 03 <42> 80 3c 20 00 74 08 48 89 df e8 e0 32 bf f7 4c 8b 03 48 89 ef 4c RSP: 0018:ffffc9000fc1f2f0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 1a772f98c8186700 RDX: 0000000000000003 RSI: ffffffff8bcac4e0 RDI: ffffffff8c1f9760 RBP: ffff8880673fb980 R08: ffffffff8fac15ef R09: 1ffffffff1f582bd R10: dffffc0000000000 R11: fffffbfff1f582be R12: dffffc0000000000 R13: 0000000000000080 R14: ffff888076509000 R15: ffff88807a029a00 FS: 00007f55e82ca6c0(0000) GS:ffff8880b9400000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000001b31d23000 CR3: 0000000022b66000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> fib_rules_lookup+0x62c/0xdb0 net/core/fib_rules.c:317 fib6_rule_lookup+0x1fd/0x790 net/ipv6/fib6_rules.c:108 ip6_route_output_flags_noref net/ipv6/route.c:2637 [inline] ip6_route_output_flags+0x38e/0x610 net/ipv6/route.c:2649 ip6_route_output include/net/ip6_route.h:93 [inline] ip6_dst_lookup_tail+0x189/0x11a0 net/ipv6/ip6_output.c:1120 ip6_dst_lookup_flow+0xb9/0x180 net/ipv6/ip6_output.c:1250 sctp_v6_get_dst+0x792/0x1e20 net/sctp/ipv6.c:326 sctp_transport_route+0x12c/0x2e0 net/sctp/transport.c:455 sctp_assoc_add_peer+0x614/0x15c0 net/sctp/associola.c:662 sctp_connect_new_asoc+0x31d/0x6c0 net/sctp/socket.c:1099 __sctp_connect+0x66d/0xe30 net/sctp/socket.c:1197 sctp_connect net/sctp/socket.c:4819 [inline] sctp_inet_connect+0x149/0x1f0 net/sctp/socket.c:4834 __sys_connect_file net/socket.c:2048 [inline] __sys_connect+0x2df/0x310 net/socket.c:2065 __do_sys_connect net/socket.c:2075 [inline] __se_sys_connect net/socket.c:2072 [inline] __x64_sys_connect+0x7a/0x90 net/socket.c:2072 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-36902",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:44Z"
      },
      "bom-ref": "b5664402-6a27-4a66-9353-4bd1b60f8e10",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: Fix potential uninit-value access in __ip6_make_skb() As it was done in commit fc1092f51567 (\"ipv4: Fix uninit-value access in __ip_make_skb()\") for IPv4, check FLOWI_FLAG_KNOWN_NH on fl6->flowi6_flags instead of testing HDRINCL on the socket to avoid a race condition which causes uninit-value access.",
      "id": "CVE-2024-36903",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:45Z"
      },
      "bom-ref": "ed225f5a-1671-4def-a8e7-96af47b8b01d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: uio_hv_generic: Don't free decrypted memory In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues. The VMBus device UIO driver could free decrypted/shared pages if set_memory_decrypted() fails. Check the decrypted field in the gpadl to decide whether to free the memory.",
      "id": "CVE-2024-36910",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T18:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:47Z"
      },
      "bom-ref": "84a6ac11-0c19-46fa-bc13-335e7eda48c8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: Drivers: hv: vmbus: Track decrypted status in vmbus_gpadl In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues. In order to make sure callers of vmbus_establish_gpadl() and vmbus_teardown_gpadl() don't return decrypted/shared pages to allocators, add a field in struct vmbus_gpadl to keep track of the decryption status of the buffers. This will allow the callers to know if they should free or leak the pages.",
      "id": "CVE-2024-36912",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T18:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:48Z"
      },
      "bom-ref": "1df919f3-076a-4429-8d00-ffeac39090e2",
      "description": "In the Linux kernel, the following vulnerability has been resolved: Drivers: hv: vmbus: Leak pages if set_memory_encrypted() fails In CoCo VMs it is possible for the untrusted host to cause set_memory_encrypted() or set_memory_decrypted() to fail such that an error is returned and the resulting memory is shared. Callers need to take care to handle these errors to avoid returning decrypted (shared) memory to the page allocator, which could lead to functional or security issues. VMBus code could free decrypted pages if set_memory_encrypted()/decrypted() fails. Leak the pages if this happens.",
      "id": "CVE-2024-36913",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T18:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "c796abe4-31b2-4150-b20b-a8305ea82b17",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: guard against invalid STA ID on removal Guard against invalid station IDs in iwl_mvm_mld_rm_sta_id as that would result in out-of-bounds array accesses. This prevents issues should the driver get into a bad state during error handling.",
      "id": "CVE-2024-36921",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-01T02:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_9P_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "89996e3a-b180-45b2-af66-03e78f47bd2b",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/9p: fix uninitialized values during inode evict If an iget fails due to not being able to retrieve information from the server then the inode structure is only partially initialized. When the inode gets evicted, references to uninitialized structures (like fscache cookies) were being made. This patch checks for a bad_inode before doing anything other than clearing the inode from the cache. Since the inode is bad, it shouldn't have any state associated with it that needs to be written back (and there really isn't a way to complete those anyways).",
      "id": "CVE-2024-36923",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T12:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:50Z"
      },
      "bom-ref": "a2b7fb0d-136b-428a-b0d9-4d59f9ff02e0",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Release hbalock before calling lpfc_worker_wake_up() lpfc_worker_wake_up() calls the lpfc_work_done() routine, which takes the hbalock. Thus, lpfc_worker_wake_up() should not be called while holding the hbalock to avoid potential deadlock.",
      "id": "CVE-2024-36924",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-10T18:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:51Z"
      },
      "bom-ref": "fac96ec0-89af-4316-a840-7742e2c26253",
      "cwes": [
        362,
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv4: Fix uninit-value access in __ip_make_skb() KMSAN reported uninit-value access in __ip_make_skb() [1]. __ip_make_skb() tests HDRINCL to know if the skb has icmphdr. However, HDRINCL can cause a race condition. If calling setsockopt(2) with IP_HDRINCL changes HDRINCL while __ip_make_skb() is running, the function will access icmphdr in the skb even if it is not included. This causes the issue reported by KMSAN. Check FLOWI_FLAG_KNOWN_NH on fl4->flowi4_flags instead of testing HDRINCL on the socket. Also, fl4->fl4_icmp_type and fl4->fl4_icmp_code are not initialized. These are union in struct flowi4 and are implicitly initialized by flowi4_init_output(), but we should not rely on specific union layout. Initialize these explicitly in raw_sendmsg(). [1] BUG: KMSAN: uninit-value in __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481 __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481 ip_finish_skb include/net/ip.h:243 [inline] ip_push_pending_frames+0x4c/0x5c0 net/ipv4/ip_output.c:1508 raw_sendmsg+0x2381/0x2690 net/ipv4/raw.c:654 inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x274/0x3c0 net/socket.c:745 __sys_sendto+0x62c/0x7b0 net/socket.c:2191 __do_sys_sendto net/socket.c:2203 [inline] __se_sys_sendto net/socket.c:2199 [inline] __x64_sys_sendto+0x130/0x200 net/socket.c:2199 do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x6d/0x75 Uninit was created at: slab_post_alloc_hook mm/slub.c:3804 [inline] slab_alloc_node mm/slub.c:3845 [inline] kmem_cache_alloc_node+0x5f6/0xc50 mm/slub.c:3888 kmalloc_reserve+0x13c/0x4a0 net/core/skbuff.c:577 __alloc_skb+0x35a/0x7c0 net/core/skbuff.c:668 alloc_skb include/linux/skbuff.h:1318 [inline] __ip_append_data+0x49ab/0x68c0 net/ipv4/ip_output.c:1128 ip_append_data+0x1e7/0x260 net/ipv4/ip_output.c:1365 raw_sendmsg+0x22b1/0x2690 net/ipv4/raw.c:648 inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg+0x274/0x3c0 net/socket.c:745 __sys_sendto+0x62c/0x7b0 net/socket.c:2191 __do_sys_sendto net/socket.c:2203 [inline] __se_sys_sendto net/socket.c:2199 [inline] __x64_sys_sendto+0x130/0x200 net/socket.c:2199 do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x6d/0x75 CPU: 1 PID: 15709 Comm: syz-executor.7 Not tainted 6.8.0-11567-gb3603fcb79b1 #25 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-1.fc39 04/01/2014",
      "id": "CVE-2024-36927",
      "published": "2024-05-30T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:53Z"
      },
      "bom-ref": "665bc5a6-9a83-4476-89a7-54b515e5b5cf",
      "cwes": [
        369,
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix div-by-zero in l2cap_le_flowctl_init() l2cap_le_flowctl_init() can cause both div-by-zero and an integer overflow since hdev->le_mtu may not fall in the valid range. Move MTU from hci_dev to hci_conn to validate MTU and stop the connection process earlier if MTU is invalid. Also, add a missing validation in read_buffer_size() and make it return an error value if the validation fails. Now hci_conn_add() returns ERR_PTR() as it can fail due to the both a kzalloc failure and invalid MTU value. divide error: 0000 [#1] PREEMPT SMP KASAN NOPTI CPU: 0 PID: 67 Comm: kworker/u5:0 Tainted: G W 6.9.0-rc5+ #20 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Workqueue: hci0 hci_rx_work RIP: 0010:l2cap_le_flowctl_init+0x19e/0x3f0 net/bluetooth/l2cap_core.c:547 Code: e8 17 17 0c 00 66 41 89 9f 84 00 00 00 bf 01 00 00 00 41 b8 02 00 00 00 4c 89 fe 4c 89 e2 89 d9 e8 27 17 0c 00 44 89 f0 31 d2 <66> f7 f3 89 c3 ff c3 4d 8d b7 88 00 00 00 4c 89 f0 48 c1 e8 03 42 RSP: 0018:ffff88810bc0f858 EFLAGS: 00010246 RAX: 00000000000002a0 RBX: 0000000000000000 RCX: dffffc0000000000 RDX: 0000000000000000 RSI: ffff88810bc0f7c0 RDI: ffffc90002dcb66f RBP: ffff88810bc0f880 R08: aa69db2dda70ff01 R09: 0000ffaaaaaaaaaa R10: 0084000000ffaaaa R11: 0000000000000000 R12: ffff88810d65a084 R13: dffffc0000000000 R14: 00000000000002a0 R15: ffff88810d65a000 FS: 0000000000000000(0000) GS:ffff88811ac00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020000100 CR3: 0000000103268003 CR4: 0000000000770ef0 PKRU: 55555554 Call Trace: <TASK> l2cap_le_connect_req net/bluetooth/l2cap_core.c:4902 [inline] l2cap_le_sig_cmd net/bluetooth/l2cap_core.c:5420 [inline] l2cap_le_sig_channel net/bluetooth/l2cap_core.c:5486 [inline] l2cap_recv_frame+0xe59d/0x11710 net/bluetooth/l2cap_core.c:6809 l2cap_recv_acldata+0x544/0x10a0 net/bluetooth/l2cap_core.c:7506 hci_acldata_packet net/bluetooth/hci_core.c:3939 [inline] hci_rx_work+0x5e5/0xb20 net/bluetooth/hci_core.c:4176 process_one_work kernel/workqueue.c:3254 [inline] process_scheduled_works+0x90f/0x1530 kernel/workqueue.c:3335 worker_thread+0x926/0xe70 kernel/workqueue.c:3416 kthread+0x2e3/0x380 kernel/kthread.c:388 ret_from_fork+0x5c/0x90 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]---",
      "id": "CVE-2024-36968",
      "published": "2024-06-08T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:54Z"
      },
      "bom-ref": "d6fc241c-72c3-494a-92b2-c3ada6c8720f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Fix netif state handling mlx5e_suspend cleans resources only if netif_device_present() returns true. However, mlx5e_resume changes the state of netif, via mlx5e_nic_enable, only if reg_state == NETREG_REGISTERED. In the below case, the above leads to NULL-ptr Oops[1] and memory leaks: mlx5e_probe _mlx5e_resume mlx5e_attach_netdev mlx5e_nic_enable <-- netdev not reg, not calling netif_device_attach() register_netdev <-- failed for some reason. ERROR_FLOW: _mlx5e_suspend <-- netif_device_present return false, resources aren't freed :( Hence, clean resources in this case as well. [1] BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: 0010 [#1] SMP CPU: 2 PID: 9345 Comm: test-ovs-ct-gen Not tainted 6.5.0_for_upstream_min_debug_2023_09_05_16_01 #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:0x0 Code: Unable to access opcode bytes at0xffffffffffffffd6. RSP: 0018:ffff888178aaf758 EFLAGS: 00010246 Call Trace: <TASK> ? __die+0x20/0x60 ? page_fault_oops+0x14c/0x3c0 ? exc_page_fault+0x75/0x140 ? asm_exc_page_fault+0x22/0x30 notifier_call_chain+0x35/0xb0 blocking_notifier_call_chain+0x3d/0x60 mlx5_blocking_notifier_call_chain+0x22/0x30 [mlx5_core] mlx5_core_uplink_netdev_event_replay+0x3e/0x60 [mlx5_core] mlx5_mdev_netdev_track+0x53/0x60 [mlx5_ib] mlx5_ib_roce_init+0xc3/0x340 [mlx5_ib] __mlx5_ib_add+0x34/0xd0 [mlx5_ib] mlx5r_probe+0xe1/0x210 [mlx5_ib] ? auxiliary_match_id+0x6a/0x90 auxiliary_bus_probe+0x38/0x80 ? driver_sysfs_add+0x51/0x80 really_probe+0xc9/0x3e0 ? driver_probe_device+0x90/0x90 __driver_probe_device+0x80/0x160 driver_probe_device+0x1e/0x90 __device_attach_driver+0x7d/0x100 bus_for_each_drv+0x80/0xd0 __device_attach+0xbc/0x1f0 bus_probe_device+0x86/0xa0 device_add+0x637/0x840 __auxiliary_device_add+0x3b/0xa0 add_adev+0xc9/0x140 [mlx5_core] mlx5_rescan_drivers_locked+0x22a/0x310 [mlx5_core] mlx5_register_device+0x53/0xa0 [mlx5_core] mlx5_init_one_devl_locked+0x5c4/0x9c0 [mlx5_core] mlx5_init_one+0x3b/0x60 [mlx5_core] probe_one+0x44c/0x730 [mlx5_core] local_pci_probe+0x3e/0x90 pci_device_probe+0xbf/0x210 ? kernfs_create_link+0x5d/0xa0 ? sysfs_do_create_link_sd+0x60/0xc0 really_probe+0xc9/0x3e0 ? driver_probe_device+0x90/0x90 __driver_probe_device+0x80/0x160 driver_probe_device+0x1e/0x90 __device_attach_driver+0x7d/0x100 bus_for_each_drv+0x80/0xd0 __device_attach+0xbc/0x1f0 pci_bus_add_device+0x54/0x80 pci_iov_add_virtfn+0x2e6/0x320 sriov_enable+0x208/0x420 mlx5_core_sriov_configure+0x9e/0x200 [mlx5_core] sriov_numvfs_store+0xae/0x1a0 kernfs_fop_write_iter+0x10c/0x1a0 vfs_write+0x291/0x3c0 ksys_write+0x5f/0xe0 do_syscall_64+0x3d/0x90 entry_SYSCALL_64_after_hwframe+0x46/0xb0 CR2: 0000000000000000 ---[ end trace 0000000000000000 ]---",
      "id": "CVE-2024-38608",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "9a24f6c5-fa05-4663-b2d8-1e236b064770",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix possible use-after-free issue in ftrace_location() KASAN reports a bug: BUG: KASAN: use-after-free in ftrace_location+0x90/0x120 Read of size 8 at addr ffff888141d40010 by task insmod/424 CPU: 8 PID: 424 Comm: insmod Tainted: G W 6.9.0-rc2+ [...] Call Trace: <TASK> dump_stack_lvl+0x68/0xa0 print_report+0xcf/0x610 kasan_report+0xb5/0xe0 ftrace_location+0x90/0x120 register_kprobe+0x14b/0xa40 kprobe_init+0x2d/0xff0 [kprobe_example] do_one_initcall+0x8f/0x2d0 do_init_module+0x13a/0x3c0 load_module+0x3082/0x33d0 init_module_from_file+0xd2/0x130 __x64_sys_finit_module+0x306/0x440 do_syscall_64+0x68/0x140 entry_SYSCALL_64_after_hwframe+0x71/0x79 The root cause is that, in lookup_rec(), ftrace record of some address is being searched in ftrace pages of some module, but those ftrace pages at the same time is being freed in ftrace_release_mod() as the corresponding module is being deleted: CPU1 | CPU2 register_kprobes() { | delete_module() { check_kprobe_address_safe() { | arch_check_ftrace_location() { | ftrace_location() { | lookup_rec() // USE! | ftrace_release_mod() // Free! To fix this issue: 1. Hold rcu lock as accessing ftrace pages in ftrace_location_range(); 2. Use ftrace_location_range() instead of lookup_rec() in ftrace_location(); 3. Call synchronize_rcu() before freeing any ftrace pages both in ftrace_process_locs()/ftrace_release_mod()/ftrace_free_mem().",
      "id": "CVE-2024-38588",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "cddaa5f8-accf-438b-a05e-495e9a34fafd",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu/mes: fix use-after-free issue Delete fence fallback timer to fix the ramdom use-after-free issue. v2: move to amdgpu_mes.c",
      "id": "CVE-2024-38581",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-27T18:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_GFS2_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5889ca24-83d0-4798-91bc-30e9451ed6d9",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gfs2: Fix potential glock use-after-free on unmount When a DLM lockspace is released and there ares still locks in that lockspace, DLM will unlock those locks automatically. Commit fb6791d100d1b started exploiting this behavior to speed up filesystem unmount: gfs2 would simply free glocks it didn't want to unlock and then release the lockspace. This didn't take the bast callbacks for asynchronous lock contention notifications into account, which remain active until until a lock is unlocked or its lockspace is released. To prevent those callbacks from accessing deallocated objects, put the glocks that should not be unlocked on the sd_dead_glocks list, release the lockspace, and only then free those glocks. As an additional measure, ignore unexpected ast and bast callbacks if the receiving glock is dead.",
      "id": "CVE-2024-38570",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:56Z"
      },
      "bom-ref": "7b4d75fb-b77e-4483-90f2-54c2c5838ee3",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Reload only IB representors upon lag disable/enable On lag disable, the bond IB device along with all of its representors are destroyed, and then the slaves' representors get reloaded. In case the slave IB representor load fails, the eswitch error flow unloads all representors, including ethernet representors, where the netdevs get detached and removed from lag bond. Such flow is inaccurate as the lag driver is not responsible for loading/unloading ethernet representors. Furthermore, the flow described above begins by holding lag lock to prevent bond changes during disable flow. However, when reaching the ethernet representors detachment from lag, the lag lock is required again, triggering the following deadlock: Call trace: __switch_to+0xf4/0x148 __schedule+0x2c8/0x7d0 schedule+0x50/0xe0 schedule_preempt_disabled+0x18/0x28 __mutex_lock.isra.13+0x2b8/0x570 __mutex_lock_slowpath+0x1c/0x28 mutex_lock+0x4c/0x68 mlx5_lag_remove_netdev+0x3c/0x1a0 [mlx5_core] mlx5e_uplink_rep_disable+0x70/0xa0 [mlx5_core] mlx5e_detach_netdev+0x6c/0xb0 [mlx5_core] mlx5e_netdev_change_profile+0x44/0x138 [mlx5_core] mlx5e_netdev_attach_nic_profile+0x28/0x38 [mlx5_core] mlx5e_vport_rep_unload+0x184/0x1b8 [mlx5_core] mlx5_esw_offloads_rep_load+0xd8/0xe0 [mlx5_core] mlx5_eswitch_reload_reps+0x74/0xd0 [mlx5_core] mlx5_disable_lag+0x130/0x138 [mlx5_core] mlx5_lag_disable_change+0x6c/0x70 [mlx5_core] // hold ldev->lock mlx5_devlink_eswitch_mode_set+0xc0/0x410 [mlx5_core] devlink_nl_cmd_eswitch_set_doit+0xdc/0x180 genl_family_rcv_msg_doit.isra.17+0xe8/0x138 genl_rcv_msg+0xe4/0x220 netlink_rcv_skb+0x44/0x108 genl_rcv+0x40/0x58 netlink_unicast+0x198/0x268 netlink_sendmsg+0x1d4/0x418 sock_sendmsg+0x54/0x60 __sys_sendto+0xf4/0x120 __arm64_sys_sendto+0x30/0x40 el0_svc_common+0x8c/0x120 do_el0_svc+0x30/0xa0 el0_svc+0x20/0x30 el0_sync_handler+0x90/0xb8 el0_sync+0x160/0x180 Thus, upon lag enable/disable, load and unload only the IB representors of the slaves preventing the deadlock mentioned above. While at it, refactor the mlx5_esw_offloads_rep_load() function to have a static helper method for its internal logic, in symmetry with the representor unload design.",
      "id": "CVE-2024-38557",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "bca37651-90ac-4745-8c15-dc7e9a5e2a82",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Add a timeout to acquire the command queue semaphore Prevent forced completion handling on an entry that has not yet been assigned an index, causing an out of bounds access on idx = -22. Instead of waiting indefinitely for the sem, blocking flow now waits for index to be allocated or a sem acquisition timeout before beginning the timer for FW completion. Kernel log example: mlx5_core 0000:06:00.0: wait_func_handle_exec_timeout:1128:(pid 185911): cmd[-22]: CREATE_UCTX(0xa04) No done completion",
      "id": "CVE-2024-38556",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T12:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:57Z"
      },
      "bom-ref": "86e8eed8-9ba1-4f1a-b49d-1c8fc689e690",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: fec: remove .ndo_poll_controller to avoid deadlocks There is a deadlock issue found in sungem driver, please refer to the commit ac0a230f719b (\"eth: sungem: remove .ndo_poll_controller to avoid deadlocks\"). The root cause of the issue is that netpoll is in atomic context and disable_irq() is called by .ndo_poll_controller interface of sungem driver, however, disable_irq() might sleep. After analyzing the implementation of fec_poll_controller(), the fec driver should have the same issue. Due to the fec driver uses NAPI for TX completions, the .ndo_poll_controller is unnecessary to be implemented in the fec driver, so fec_poll_controller() can be safely removed.",
      "id": "CVE-2024-38553",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-02T08:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_INFINIBAND_HNS not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "4ac0b526-bf58-41a9-b8a8-9f6238c0e7af",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix UAF for cq async event The refcount of CQ is not protected by locks. When CQ asynchronous events and CQ destruction are concurrent, CQ may have been released, which will cause UAF. Use the xa_lock() to protect the CQ refcount.",
      "id": "CVE-2024-38545",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:50:59Z"
      },
      "bom-ref": "58e7b820-ed27-45d2-928a-b3ef5d3446e4",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: lib/test_hmm.c: handle src_pfns and dst_pfns allocation failure The kcalloc() in dmirror_device_evict_chunk() will return null if the physical memory has run out. As a result, if src_pfns or dst_pfns is dereferenced, the null pointer dereference bug will happen. Moreover, the device is going away. If the kcalloc() fails, the pages mapping a chunk could not be evicted. So add a __GFP_NOFAIL flag in kcalloc(). Finally, as there is no need to have physically contiguous memory, Switch kcalloc() to kvcalloc() in order to avoid failing allocations.",
      "id": "CVE-2024-38543",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:00Z"
      },
      "bom-ref": "82411712-e75d-4a05-a78b-59c2b85e73ec",
      "description": "In the Linux kernel, the following vulnerability has been resolved: of: module: add buffer overflow check in of_modalias() In of_modalias(), if the buffer happens to be too small even for the 1st snprintf() call, the len parameter will become negative and str parameter (if not NULL initially) will point beyond the buffer's end. Add the buffer overflow check after the 1st snprintf() call and fix such check after the strlen() call (accounting for the terminating NUL char).",
      "id": "CVE-2024-38541",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:02Z"
      },
      "bom-ref": "d75822c2-2391-4fbc-b3e2-380d851dd25b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bnxt_re: avoid shift undefined behavior in bnxt_qplib_alloc_init_hwq Undefined behavior is triggered when bnxt_qplib_alloc_init_hwq is called with hwq_attr->aux_depth != 0 and hwq_attr->aux_stride == 0. In that case, \"roundup_pow_of_two(hwq_attr->aux_stride)\" gets called. roundup_pow_of_two is documented as undefined for 0. Fix it in the one caller that had this combination. The undefined behavior was detected by UBSAN: UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13 shift exponent 64 is too large for 64-bit type 'long unsigned int' CPU: 24 PID: 1075 Comm: (udev-worker) Not tainted 6.9.0-rc6+ #4 Hardware name: Abacus electric, s.r.o. - servis@abacus.cz Super Server/H12SSW-iN, BIOS 2.7 10/25/2023 Call Trace: <TASK> dump_stack_lvl+0x5d/0x80 ubsan_epilogue+0x5/0x30 __ubsan_handle_shift_out_of_bounds.cold+0x61/0xec __roundup_pow_of_two+0x25/0x35 [bnxt_re] bnxt_qplib_alloc_init_hwq+0xa1/0x470 [bnxt_re] bnxt_qplib_create_qp+0x19e/0x840 [bnxt_re] bnxt_re_create_qp+0x9b1/0xcd0 [bnxt_re] ? srso_alias_return_thunk+0x5/0xfbef5 ? srso_alias_return_thunk+0x5/0xfbef5 ? __kmalloc+0x1b6/0x4f0 ? create_qp.part.0+0x128/0x1c0 [ib_core] ? __pfx_bnxt_re_create_qp+0x10/0x10 [bnxt_re] create_qp.part.0+0x128/0x1c0 [ib_core] ib_create_qp_kernel+0x50/0xd0 [ib_core] create_mad_qp+0x8e/0xe0 [ib_core] ? __pfx_qp_event_handler+0x10/0x10 [ib_core] ib_mad_init_device+0x2be/0x680 [ib_core] add_client_context+0x10d/0x1a0 [ib_core] enable_device_and_get+0xe0/0x1d0 [ib_core] ib_register_device+0x53c/0x630 [ib_core] ? srso_alias_return_thunk+0x5/0xfbef5 bnxt_re_probe+0xbd8/0xe50 [bnxt_re] ? __pfx_bnxt_re_probe+0x10/0x10 [bnxt_re] auxiliary_bus_probe+0x49/0x80 ? driver_sysfs_add+0x57/0xc0 really_probe+0xde/0x340 ? pm_runtime_barrier+0x54/0x90 ? __pfx___driver_attach+0x10/0x10 __driver_probe_device+0x78/0x110 driver_probe_device+0x1f/0xa0 __driver_attach+0xba/0x1c0 bus_for_each_dev+0x8f/0xe0 bus_add_driver+0x146/0x220 driver_register+0x72/0xd0 __auxiliary_driver_register+0x6e/0xd0 ? __pfx_bnxt_re_mod_init+0x10/0x10 [bnxt_re] bnxt_re_mod_init+0x3e/0xff0 [bnxt_re] ? __pfx_bnxt_re_mod_init+0x10/0x10 [bnxt_re] do_one_initcall+0x5b/0x310 do_init_module+0x90/0x250 init_module_from_file+0x86/0xc0 idempotent_init_module+0x121/0x2b0 __x64_sys_finit_module+0x5e/0xb0 do_syscall_64+0x82/0x160 ? srso_alias_return_thunk+0x5/0xfbef5 ? syscall_exit_to_user_mode_prepare+0x149/0x170 ? srso_alias_return_thunk+0x5/0xfbef5 ? syscall_exit_to_user_mode+0x75/0x230 ? srso_alias_return_thunk+0x5/0xfbef5 ? do_syscall_64+0x8e/0x160 ? srso_alias_return_thunk+0x5/0xfbef5 ? __count_memcg_events+0x69/0x100 ? srso_alias_return_thunk+0x5/0xfbef5 ? count_memcg_events.constprop.0+0x1a/0x30 ? srso_alias_return_thunk+0x5/0xfbef5 ? handle_mm_fault+0x1f0/0x300 ? srso_alias_return_thunk+0x5/0xfbef5 ? do_user_addr_fault+0x34e/0x640 ? srso_alias_return_thunk+0x5/0xfbef5 ? srso_alias_return_thunk+0x5/0xfbef5 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f4e5132821d Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d e3 db 0c 00 f7 d8 64 89 01 48 RSP: 002b:00007ffca9c906a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139 RAX: ffffffffffffffda RBX: 0000563ec8a8f130 RCX: 00007f4e5132821d RDX: 0000000000000000 RSI: 00007f4e518fa07d RDI: 000000000000003b RBP: 00007ffca9c90760 R08: 00007f4e513f6b20 R09: 00007ffca9c906f0 R10: 0000563ec8a8faa0 R11: 0000000000000246 R12: 00007f4e518fa07d R13: 0000000000020000 R14: 0000563ec8409e90 R15: 0000563ec8a8fa60 </TASK> ---[ end trace ]---",
      "id": "CVE-2024-38540",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "state": "not_affected"
      },
      "bom-ref": "842a3047-1c14-42ec-9564-28ea4e048601",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: bridge: xmit: make sure we have at least eth header len bytes syzbot triggered an uninit value[1] error in bridge device's xmit path by sending a short (less than ETH_HLEN bytes) skb. To fix it check if we can actually pull that amount instead of assuming. Tested with dropwatch: drop at: br_dev_xmit+0xb93/0x12d0 [bridge] (0xffffffffc06739b3) origin: software timestamp: Mon May 13 11:31:53 2024 778214037 nsec protocol: 0x88a8 length: 2 original length: 2 drop reason: PKT_TOO_SMALL [1] BUG: KMSAN: uninit-value in br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65 br_dev_xmit+0x61d/0x1cb0 net/bridge/br_device.c:65 __netdev_start_xmit include/linux/netdevice.h:4903 [inline] netdev_start_xmit include/linux/netdevice.h:4917 [inline] xmit_one net/core/dev.c:3531 [inline] dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3547 __dev_queue_xmit+0x34db/0x5350 net/core/dev.c:4341 dev_queue_xmit include/linux/netdevice.h:3091 [inline] __bpf_tx_skb net/core/filter.c:2136 [inline] __bpf_redirect_common net/core/filter.c:2180 [inline] __bpf_redirect+0x14a6/0x1620 net/core/filter.c:2187 ____bpf_clone_redirect net/core/filter.c:2460 [inline] bpf_clone_redirect+0x328/0x470 net/core/filter.c:2432 ___bpf_prog_run+0x13fe/0xe0f0 kernel/bpf/core.c:1997 __bpf_prog_run512+0xb5/0xe0 kernel/bpf/core.c:2238 bpf_dispatcher_nop_func include/linux/bpf.h:1234 [inline] __bpf_prog_run include/linux/filter.h:657 [inline] bpf_prog_run include/linux/filter.h:664 [inline] bpf_test_run+0x499/0xc30 net/bpf/test_run.c:425 bpf_prog_test_run_skb+0x14ea/0x1f20 net/bpf/test_run.c:1058 bpf_prog_test_run+0x6b7/0xad0 kernel/bpf/syscall.c:4269 __sys_bpf+0x6aa/0xd90 kernel/bpf/syscall.c:5678 __do_sys_bpf kernel/bpf/syscall.c:5767 [inline] __se_sys_bpf kernel/bpf/syscall.c:5765 [inline] __x64_sys_bpf+0xa0/0xe0 kernel/bpf/syscall.c:5765 x64_sys_call+0x96b/0x3b50 arch/x86/include/generated/asm/syscalls_64.h:322 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcf/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-38538",
      "published": "2024-06-19T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "54dcc193-2b1c-4c68-af05-ccf4b999a14a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Wrap dcn301_calculate_wm_and_dlg for FPU. Mirrors the logic for dcn30. Cue lots of WARNs and some kernel panics without this fix.",
      "id": "CVE-2022-48766",
      "published": "2024-06-20T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T21:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:03Z"
      },
      "bom-ref": "6711f5d7-a418-4ab5-a676-e9e3956c03cb",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: tracing/probes: fix error check in parse_btf_field() btf_find_struct_member() might return NULL or an error via the ERR_PTR() macro. However, its caller in parse_btf_field() only checks for the NULL condition. Fix this by using IS_ERR() and returning the error up the stack.",
      "id": "CVE-2024-36481",
      "published": "2024-06-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:05Z"
      },
      "bom-ref": "ec06840c-eb33-4812-8c56-9fc552c01aef",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: SUNRPC: Fix loop termination condition in gss_free_in_token_pages() The in_token->pages[] array is not NULL terminated. This results in the following KASAN splat: KASAN: maybe wild-memory-access in range [0x04a2013400000008-0x04a201340000000f]",
      "id": "CVE-2024-36288",
      "published": "2024-06-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_CPU5_WDT not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "43b18ea3-f126-42ad-b25a-6ebcaf001773",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: watchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_trigger When the cpu5wdt module is removing, the origin code uses del_timer() to de-activate the timer. If the timer handler is running, del_timer() could not stop it and will return directly. If the port region is released by release_region() and then the timer handler cpu5wdt_trigger() calls outb() to write into the region that is released, the use-after-free bug will happen. Change del_timer() to timer_shutdown_sync() in order that the timer handler could be finished before the port region is released.",
      "id": "CVE-2024-38630",
      "published": "2024-06-21T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:06Z"
      },
      "bom-ref": "0c314a44-8e47-45dd-bef7-468cef95c0bc",
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: u_audio: Fix race condition use of controls after free during gadget unbind. Hang on to the control IDs instead of pointers since those are correctly handled with locks.",
      "id": "CVE-2024-38628",
      "published": "2024-06-21T11:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T18:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:08Z"
      },
      "bom-ref": "9db4c28c-5254-49d6-95a0-fa4712c33990",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Check 'folio' pointer for NULL It can be NULL if bmap is called.",
      "id": "CVE-2024-38625",
      "published": "2024-06-21T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T16:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:09Z"
      },
      "bom-ref": "7813268b-02b1-4acf-b69f-b9608c261f8b",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: null_blk: fix null-ptr-dereference while configuring 'power' and 'submit_queues' Writing 'power' and 'submit_queues' concurrently will trigger kernel panic: Test script: modprobe null_blk nr_devices=0 mkdir -p /sys/kernel/config/nullb/nullb0 while true; do echo 1 > submit_queues; echo 4 > submit_queues; done & while true; do echo 1 > power; echo 0 > power; done Test result: BUG: kernel NULL pointer dereference, address: 0000000000000148 Oops: 0000 [#1] PREEMPT SMP RIP: 0010:__lock_acquire+0x41d/0x28f0 Call Trace: <TASK> lock_acquire+0x121/0x450 down_write+0x5f/0x1d0 simple_recursive_removal+0x12f/0x5c0 blk_mq_debugfs_unregister_hctxs+0x7c/0x100 blk_mq_update_nr_hw_queues+0x4a3/0x720 nullb_update_nr_hw_queues+0x71/0xf0 [null_blk] nullb_device_submit_queues_store+0x79/0xf0 [null_blk] configfs_write_iter+0x119/0x1e0 vfs_write+0x326/0x730 ksys_write+0x74/0x150 This is because del_gendisk() can concurrent with blk_mq_update_nr_hw_queues(): nullb_device_power_store nullb_apply_submit_queues null_del_dev del_gendisk nullb_update_nr_hw_queues if (!dev->nullb) // still set while gendisk is deleted return 0 blk_mq_update_nr_hw_queues dev->nullb = NULL Fix this problem by resuing the global mutex to protect nullb_device_power_store() and nullb_update_nr_hw_queues() from configfs.",
      "id": "CVE-2024-36478",
      "published": "2024-06-21T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-02T08:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "9c349dab-97ef-430c-9fd3-afb7e7cd0885",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: riscv: prevent pt_regs corruption for secondary idle threads Top of the kernel thread stack should be reserved for pt_regs. However this is not the case for the idle threads of the secondary boot harts. Their stacks overlap with their pt_regs, so both may get corrupted. Similar issue has been fixed for the primary hart, see c7cdd96eca28 (\"riscv: prevent stack corruption by reserving task_pt_regs(p) early\"). However that fix was not propagated to the secondary harts. The problem has been noticed in some CPU hotplug tests with V enabled. The function smp_callin stored several registers on stack, corrupting top of pt_regs structure including status field. As a result, kernel attempted to save or restore inexistent V context.",
      "id": "CVE-2024-38667",
      "published": "2024-06-24T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-30T19:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:11Z"
      },
      "bom-ref": "52abe325-5d08-43ab-bf10-5aefb2fb0b05",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fpga: manager: add owner module and take its refcount The current implementation of the fpga manager assumes that the low-level module registers a driver for the parent device and uses its owner pointer to take the module's refcount. This approach is problematic since it can lead to a null pointer dereference while attempting to get the manager if the parent device does not have a driver. To address this problem, add a module owner pointer to the fpga_manager struct and use it to take the module's refcount. Modify the functions for registering the manager to take an additional owner module parameter and rename them to avoid conflicts. Use the old function names for helper macros that automatically set the module that registers the manager as the owner. This ensures compatibility with existing low-level control modules and reduces the chances of registering a manager without setting the owner. Also, update the documentation to keep it consistent with the new interface for registering an fpga manager. Other changes: opportunistically move put_device() from __fpga_mgr_get() to fpga_mgr_get() and of_fpga_mgr_get() to improve code clarity since the manager device is taken in these functions.",
      "id": "CVE-2024-37021",
      "published": "2024-06-24T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T15:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:12Z"
      },
      "bom-ref": "04c4751c-748e-4b5e-b059-2b7dd1c9d878",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fpga: bridge: add owner module and take its refcount The current implementation of the fpga bridge assumes that the low-level module registers a driver for the parent device and uses its owner pointer to take the module's refcount. This approach is problematic since it can lead to a null pointer dereference while attempting to get the bridge if the parent device does not have a driver. To address this problem, add a module owner pointer to the fpga_bridge struct and use it to take the module's refcount. Modify the function for registering a bridge to take an additional owner module parameter and rename it to avoid conflicts. Use the old function name for a helper macro that automatically sets the module that registers the bridge as the owner. This ensures compatibility with existing low-level control modules and reduces the chances of registering a bridge without setting the owner. Also, update the documentation to keep it consistent with the new interface for registering an fpga bridge. Other changes: opportunistically move put_device() from __fpga_bridge_get() to fpga_bridge_get() and of_fpga_bridge_get() to improve code clarity since the bridge device is taken in these functions.",
      "id": "CVE-2024-36479",
      "published": "2024-06-24T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T15:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "ad663aea-8f0e-4fe4-80fd-51497030de87",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: 9p: add missing locking around taking dentry fid list Fix a use-after-free on dentry's d_fsdata fid list when a thread looks up a fid through dentry while another thread unlinks it: UAF thread: refcount_t: addition on 0; use-after-free. p9_fid_get linux/./include/net/9p/client.h:262 v9fs_fid_find+0x236/0x280 linux/fs/9p/fid.c:129 v9fs_fid_lookup_with_uid linux/fs/9p/fid.c:181 v9fs_fid_lookup+0xbf/0xc20 linux/fs/9p/fid.c:314 v9fs_vfs_getattr_dotl+0xf9/0x360 linux/fs/9p/vfs_inode_dotl.c:400 vfs_statx+0xdd/0x4d0 linux/fs/stat.c:248 Freed by: p9_fid_destroy (inlined) p9_client_clunk+0xb0/0xe0 linux/net/9p/client.c:1456 p9_fid_put linux/./include/net/9p/client.h:278 v9fs_dentry_release+0xb5/0x140 linux/fs/9p/vfs_dentry.c:55 v9fs_remove+0x38f/0x620 linux/fs/9p/vfs_inode.c:518 vfs_unlink+0x29a/0x810 linux/fs/namei.c:4335 The problem is that d_fsdata was not accessed under d_lock, because d_release() normally is only called once the dentry is otherwise no longer accessible but since we also call it explicitly in v9fs_remove that lock is required: move the hlist out of the dentry under lock then unref its fids once they are no longer accessible.",
      "id": "CVE-2024-39463",
      "published": "2024-06-25T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:51:11Z"
      },
      "bom-ref": "f479034c-1207-46d5-87f8-f990672a196a",
      "description": "The IPv6 implementation in the Linux kernel before 6.3 has a net/ipv6/route.c max_size threshold that can be consumed easily, e.g., leading to a denial of service (network is unreachable errors) when IPv6 packets are sent in a loop via a raw socket.",
      "id": "CVE-2023-52340",
      "published": "2024-07-05T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:14Z"
      },
      "bom-ref": "b9991649-158e-4d22-baab-d509c0242fde",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: xfs: fix log recovery buffer allocation for the legacy h_size fixup Commit a70f9fe52daa (\"xfs: detect and handle invalid iclog size set by mkfs\") added a fixup for incorrect h_size values used for the initial umount record in old xfsprogs versions. Later commit 0c771b99d6c9 (\"xfs: clean up calculation of LR header blocks\") cleaned up the log reover buffer calculation, but stoped using the fixed up h_size value to size the log recovery buffer, which can lead to an out of bounds access when the incorrect h_size does not come from the old mkfs tool, but a fuzzer. Fix this by open coding xlog_logrec_hblks and taking the fixed h_size into account for this calculation.",
      "id": "CVE-2024-39472",
      "published": "2024-07-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:15Z"
      },
      "bom-ref": "e9cf731b-d29f-4871-b226-eaddfede4699",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: ipc4-topology: Fix input format query of process modules without base extension If a process module does not have base config extension then the same format applies to all of it's inputs and the process->base_config_ext is NULL, causing NULL dereference when specifically crafted topology and sequences used.",
      "id": "CVE-2024-39473",
      "published": "2024-07-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:17Z"
      },
      "bom-ref": "0dfd0400-455f-4fd5-b8b8-c880b318768d",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm/vmalloc: fix vmalloc which may return null if called with __GFP_NOFAIL commit a421ef303008 (\"mm: allow !GFP_KERNEL allocations for kvmalloc\") includes support for __GFP_NOFAIL, but it presents a conflict with commit dd544141b9eb (\"vmalloc: back off when the current task is OOM-killed\"). A possible scenario is as follows: process-a __vmalloc_node_range(GFP_KERNEL | __GFP_NOFAIL) __vmalloc_area_node() vm_area_alloc_pages() --> oom-killer send SIGKILL to process-a if (fatal_signal_pending(current)) break; --> return NULL; To fix this, do not check fatal_signal_pending() in vm_area_alloc_pages() if __GFP_NOFAIL set. This issue occurred during OPLUS KASAN TEST. Below is part of the log -> oom-killer sends signal to process [65731.222840] [ T1308] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/apps/uid_10198,task=gs.intelligence,pid=32454,uid=10198 [65731.259685] [T32454] Call trace: [65731.259698] [T32454] dump_backtrace+0xf4/0x118 [65731.259734] [T32454] show_stack+0x18/0x24 [65731.259756] [T32454] dump_stack_lvl+0x60/0x7c [65731.259781] [T32454] dump_stack+0x18/0x38 [65731.259800] [T32454] mrdump_common_die+0x250/0x39c [mrdump] [65731.259936] [T32454] ipanic_die+0x20/0x34 [mrdump] [65731.260019] [T32454] atomic_notifier_call_chain+0xb4/0xfc [65731.260047] [T32454] notify_die+0x114/0x198 [65731.260073] [T32454] die+0xf4/0x5b4 [65731.260098] [T32454] die_kernel_fault+0x80/0x98 [65731.260124] [T32454] __do_kernel_fault+0x160/0x2a8 [65731.260146] [T32454] do_bad_area+0x68/0x148 [65731.260174] [T32454] do_mem_abort+0x151c/0x1b34 [65731.260204] [T32454] el1_abort+0x3c/0x5c [65731.260227] [T32454] el1h_64_sync_handler+0x54/0x90 [65731.260248] [T32454] el1h_64_sync+0x68/0x6c [65731.260269] [T32454] z_erofs_decompress_queue+0x7f0/0x2258 --> be->decompressed_pages = kvcalloc(be->nr_pages, sizeof(struct page *), GFP_KERNEL | __GFP_NOFAIL); kernel panic by NULL pointer dereference. erofs assume kvmalloc with __GFP_NOFAIL never return NULL. [65731.260293] [T32454] z_erofs_runqueue+0xf30/0x104c [65731.260314] [T32454] z_erofs_readahead+0x4f0/0x968 [65731.260339] [T32454] read_pages+0x170/0xadc [65731.260364] [T32454] page_cache_ra_unbounded+0x874/0xf30 [65731.260388] [T32454] page_cache_ra_order+0x24c/0x714 [65731.260411] [T32454] filemap_fault+0xbf0/0x1a74 [65731.260437] [T32454] __do_fault+0xd0/0x33c [65731.260462] [T32454] handle_mm_fault+0xf74/0x3fe0 [65731.260486] [T32454] do_mem_abort+0x54c/0x1b34 [65731.260509] [T32454] el0_da+0x44/0x94 [65731.260531] [T32454] el0t_64_sync_handler+0x98/0xb4 [65731.260553] [T32454] el0t_64_sync+0x198/0x19c",
      "id": "CVE-2024-39474",
      "published": "2024-07-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:18Z"
      },
      "bom-ref": "8a2c166f-1a11-4c16-934f-3fdb7d9239c7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: SVM: WARN on vNMI + NMI window iff NMIs are outright masked When requesting an NMI window, WARN on vNMI support being enabled if and only if NMIs are actually masked, i.e. if the vCPU is already handling an NMI. KVM's ABI for NMIs that arrive simultanesouly (from KVM's point of view) is to inject one NMI and pend the other. When using vNMI, KVM pends the second NMI simply by setting V_NMI_PENDING, and lets the CPU do the rest (hardware automatically sets V_NMI_BLOCKING when an NMI is injected). However, if KVM can't immediately inject an NMI, e.g. because the vCPU is in an STI shadow or is running with GIF=0, then KVM will request an NMI window and trigger the WARN (but still function correctly). Whether or not the GIF=0 case makes sense is debatable, as the intent of KVM's behavior is to provide functionality that is as close to real hardware as possible. E.g. if two NMIs are sent in quick succession, the probability of both NMIs arriving in an STI shadow is infinitesimally low on real hardware, but significantly larger in a virtual environment, e.g. if the vCPU is preempted in the STI shadow. For GIF=0, the argument isn't as clear cut, because the window where two NMIs can collide is much larger in bare metal (though still small). That said, KVM should not have divergent behavior for the GIF=0 case based on whether or not vNMI support is enabled. And KVM has allowed simultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400 (\"KVM: Fix simultaneous NMIs\"). I.e. KVM's GIF=0 handling shouldn't be modified without a *really* good reason to do so, and if KVM's behavior were to be modified, it should be done irrespective of vNMI support.",
      "id": "CVE-2024-39483",
      "published": "2024-07-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:20Z"
      },
      "bom-ref": "269476f5-676d-492c-b8bf-b0e16789053d",
      "cwes": [
        665
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: v4l: async: Properly re-initialise notifier entry in unregister The notifier_entry of a notifier is not re-initialised after unregistering the notifier. This leads to dangling pointers being left there so use list_del_init() to return the notifier_entry an empty list.",
      "id": "CVE-2024-39485",
      "published": "2024-07-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:21Z"
      },
      "bom-ref": "7577b42d-f2e2-4450-87ec-49866d2c3ce5",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring/sqpoll: work around a potential audit memory leak kmemleak complains that there's a memory leak related to connect handling: unreferenced object 0xffff0001093bdf00 (size 128): comm \"iou-sqp-455\", pid 457, jiffies 4294894164 hex dump (first 32 bytes): 02 00 fa ea 7f 00 00 01 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc 2e481b1a): [<00000000c0a26af4>] kmemleak_alloc+0x30/0x38 [<000000009c30bb45>] kmalloc_trace+0x228/0x358 [<000000009da9d39f>] __audit_sockaddr+0xd0/0x138 [<0000000089a93e34>] move_addr_to_kernel+0x1a0/0x1f8 [<000000000b4e80e6>] io_connect_prep+0x1ec/0x2d4 [<00000000abfbcd99>] io_submit_sqes+0x588/0x1e48 [<00000000e7c25e07>] io_sq_thread+0x8a4/0x10e4 [<00000000d999b491>] ret_from_fork+0x10/0x20 which can can happen if: 1) The command type does something on the prep side that triggers an audit call. 2) The thread hasn't done any operations before this that triggered an audit call inside ->issue(), where we have audit_uring_entry() and audit_uring_exit(). Work around this by issuing a blanket NOP operation before the SQPOLL does anything.",
      "id": "CVE-2024-41001",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:23Z"
      },
      "bom-ref": "0396bbd1-2258-4a7f-9f2c-d1f2384d3b82",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cpufreq: amd-pstate: fix memory leak on CPU EPP exit The cpudata memory from kzalloc() in amd_pstate_epp_cpu_init() is not freed in the analogous exit function, so fix that. [ rjw: Subject and changelog edits ]",
      "id": "CVE-2024-40997",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_MT76_CORE not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "3a46417a-20c7-4ff3-a1b0-efeeb740ef70",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7921s: fix potential hung tasks during chip recovery During chip recovery (e.g. chip reset), there is a possible situation that kernel worker reset_work is holding the lock and waiting for kernel thread stat_worker to be parked, while stat_worker is waiting for the release of the same lock. It causes a deadlock resulting in the dumping of hung tasks messages and possible rebooting of the device. This patch prevents the execution of stat_worker during the chip recovery.",
      "id": "CVE-2024-40977",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_VIDEO_MEDIATEK_VCODEC is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1745aae5-9ae5-4e1a-8c26-9a25d4cc35ab",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: mtk-vcodec: potential null pointer deference in SCP The return value of devm_kzalloc() needs to be checked to avoid NULL pointer deference. This is similar to CVE-2022-3113.",
      "id": "CVE-2024-40973",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:24Z"
      },
      "bom-ref": "e78f9eb3-b4cc-4f68-93cb-83dd0811bd76",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: do not create EA inode under buffer lock ext4_xattr_set_entry() creates new EA inodes while holding buffer lock on the external xattr block. This is problematic as it nests all the allocation locking (which acquires locks on other buffers) under the buffer lock. This can even deadlock when the filesystem is corrupted and e.g. quota file is setup to contain xattr block as data block. Move the allocation of EA inode out of ext4_xattr_set_entry() into the callers.",
      "id": "CVE-2024-40972",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T15:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:26Z"
      },
      "bom-ref": "9fceee7b-67ec-42d8-b436-021c76f41bba",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: don't set RO when shutting down f2fs Shutdown does not check the error of thaw_super due to readonly, which causes a deadlock like below. f2fs_ioc_shutdown(F2FS_GOING_DOWN_FULLSYNC) issue_discard_thread - bdev_freeze - freeze_super - f2fs_stop_checkpoint() - f2fs_handle_critical_error - sb_start_write - set RO - waiting - bdev_thaw - thaw_super_locked - return -EINVAL, if sb_rdonly() - f2fs_stop_discard_thread -> wait for kthread_stop(discard_thread);",
      "id": "CVE-2024-40969",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:27Z"
      },
      "bom-ref": "3c1e8edf-2bb4-42aa-a78f-804f12b3944d",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: i2c: lpi2c: Avoid calling clk_get_rate during transfer Instead of repeatedly calling clk_get_rate for each transfer, lock the clock rate and cache the value. A deadlock has been observed while adding tlv320aic32x4 audio codec to the system. When this clock provider adds its clock, the clk mutex is locked already, it needs to access i2c, which in return needs the mutex for clk_get_rate as well.",
      "id": "CVE-2024-40965",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T13:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_BTRFS_FS is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "c2d08e18-d986-469c-bcdf-0ebc720b9481",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: zoned: fix use-after-free due to race with dev replace While loading a zone's info during creation of a block group, we can race with a device replace operation and then trigger a use-after-free on the device that was just replaced (source device of the replace operation). This happens because at btrfs_load_zone_info() we extract a device from the chunk map into a local variable and then use the device while not under the protection of the device replace rwsem. So if there's a device replace operation happening when we extract the device and that device is the source of the replace operation, we will trigger a use-after-free if before we finish using the device the replace operation finishes and frees the device. Fix this by enlarging the critical section under the protection of the device replace rwsem so that all uses of the device are done inside the critical section.",
      "id": "CVE-2024-39496",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_IMA is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "fd736d98-4487-4ead-95f7-e9775db93bc7",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ima: Fix use-after-free on a dentry's dname.name ->d_name.name can change on rename and the earlier value can be freed; there are conditions sufficient to stabilize it (->d_lock on dentry, ->d_lock on its parent, ->i_rwsem exclusive on the parent's inode, rename_lock), but none of those are met at any of the sites. Take a stable snapshot of the name instead.",
      "id": "CVE-2024-39494",
      "published": "2024-07-12T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:29Z"
      },
      "bom-ref": "d51c7954-98eb-4f78-8a66-10213b2b0db1",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: fix NULL pointer dereference in ice_update_vsi_tx_ring_stats() It is possible to do NULL pointer dereference in routine that updates Tx ring stats. Currently only stats and bytes are updated when ring pointer is valid, but later on ring is accessed to propagate gathered Tx stats onto VSI stats. Change the existing logic to move to next ring when ring is NULL.",
      "id": "CVE-2022-48841",
      "published": "2024-07-16T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:30Z"
      },
      "bom-ref": "ad9dcff9-1e27-492d-9d97-5828dbd75329",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix overrunning reservations in ringbuf The BPF ring buffer internally is implemented as a power-of-2 sized circular buffer, with two logical and ever-increasing counters: consumer_pos is the consumer counter to show which logical position the consumer consumed the data, and producer_pos which is the producer counter denoting the amount of data reserved by all producers. Each time a record is reserved, the producer that \"owns\" the record will successfully advance producer counter. In user space each time a record is read, the consumer of the data advanced the consumer counter once it finished processing. Both counters are stored in separate pages so that from user space, the producer counter is read-only and the consumer counter is read-write. One aspect that simplifies and thus speeds up the implementation of both producers and consumers is how the data area is mapped twice contiguously back-to-back in the virtual memory, allowing to not take any special measures for samples that have to wrap around at the end of the circular buffer data area, because the next page after the last data page would be first data page again, and thus the sample will still appear completely contiguous in virtual memory. Each record has a struct bpf_ringbuf_hdr { u32 len; u32 pg_off; } header for book-keeping the length and offset, and is inaccessible to the BPF program. Helpers like bpf_ringbuf_reserve() return `(void *)hdr + BPF_RINGBUF_HDR_SZ` for the BPF program to use. Bing-Jhong and Muhammad reported that it is however possible to make a second allocated memory chunk overlapping with the first chunk and as a result, the BPF program is now able to edit first chunk's header. For example, consider the creation of a BPF_MAP_TYPE_RINGBUF map with size of 0x4000. Next, the consumer_pos is modified to 0x3000 /before/ a call to bpf_ringbuf_reserve() is made. This will allocate a chunk A, which is in [0x0,0x3008], and the BPF program is able to edit [0x8,0x3008]. Now, lets allocate a chunk B with size 0x3000. This will succeed because consumer_pos was edited ahead of time to pass the `new_prod_pos - cons_pos > rb->mask` check. Chunk B will be in range [0x3008,0x6010], and the BPF program is able to edit [0x3010,0x6010]. Due to the ring buffer memory layout mentioned earlier, the ranges [0x0,0x4000] and [0x4000,0x8000] point to the same data pages. This means that chunk B at [0x4000,0x4008] is chunk A's header. bpf_ringbuf_submit() / bpf_ringbuf_discard() use the header's pg_off to then locate the bpf_ringbuf itself via bpf_ringbuf_restore_from_rec(). Once chunk B modified chunk A's header, then bpf_ringbuf_commit() refers to the wrong page and could cause a crash. Fix it by calculating the oldest pending_pos and check whether the range from the oldest outstanding record to the newest would span beyond the ring buffer size. If that is the case, then reject the request. We've tested with the ring buffer benchmark in BPF selftests (./benchs/run_bench_ringbufs.sh) before/after the fix and while it seems a bit slower on some benchmarks, it is still not significantly enough to matter.",
      "id": "CVE-2024-41009",
      "published": "2024-07-17T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:32Z"
      },
      "bom-ref": "4b49415a-656f-4367-b60d-e5b5d9462099",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ionic: fix kernel panic due to multi-buffer handling Currently, the ionic_run_xdp() doesn't handle multi-buffer packets properly for XDP_TX and XDP_REDIRECT. When a jumbo frame is received, the ionic_run_xdp() first makes xdp frame with all necessary pages in the rx descriptor. And if the action is either XDP_TX or XDP_REDIRECT, it should unmap dma-mapping and reset page pointer to NULL for all pages, not only the first page. But it doesn't for SG pages. So, SG pages unexpectedly will be reused. It eventually causes kernel panic. Oops: general protection fault, probably for non-canonical address 0x504f4e4dbebc64ff: 0000 [#1] PREEMPT SMP NOPTI CPU: 3 PID: 0 Comm: swapper/3 Not tainted 6.10.0-rc3+ #25 RIP: 0010:xdp_return_frame+0x42/0x90 Code: 01 75 12 5b 4c 89 e6 5d 31 c9 41 5c 31 d2 41 5d e9 73 fd ff ff 44 8b 6b 20 0f b7 43 0a 49 81 ed 68 01 00 00 49 29 c5 49 01 fd <41> 80 7d0 RSP: 0018:ffff99d00122ce08 EFLAGS: 00010202 RAX: 0000000000005453 RBX: ffff8d325f904000 RCX: 0000000000000001 RDX: 00000000670e1000 RSI: 000000011f90d000 RDI: 504f4e4d4c4b4a49 RBP: ffff99d003907740 R08: 0000000000000000 R09: 0000000000000000 R10: 000000011f90d000 R11: 0000000000000000 R12: ffff8d325f904010 R13: 504f4e4dbebc64fd R14: ffff8d3242b070c8 R15: ffff99d0039077c0 FS: 0000000000000000(0000) GS:ffff8d399f780000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f41f6c85e38 CR3: 000000037ac30000 CR4: 00000000007506f0 PKRU: 55555554 Call Trace: <IRQ> ? die_addr+0x33/0x90 ? exc_general_protection+0x251/0x2f0 ? asm_exc_general_protection+0x22/0x30 ? xdp_return_frame+0x42/0x90 ionic_tx_clean+0x211/0x280 [ionic 15881354510e6a9c655c59c54812b319ed2cd015] ionic_tx_cq_service+0xd3/0x210 [ionic 15881354510e6a9c655c59c54812b319ed2cd015] ionic_txrx_napi+0x41/0x1b0 [ionic 15881354510e6a9c655c59c54812b319ed2cd015] __napi_poll.constprop.0+0x29/0x1b0 net_rx_action+0x2c4/0x350 handle_softirqs+0xf4/0x320 irq_exit_rcu+0x78/0xa0 common_interrupt+0x77/0x90",
      "id": "CVE-2024-42083",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:33Z"
      },
      "bom-ref": "b6d33e0d-18ca-4e9b-b034-5a9619091692",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/xe_devcoredump: Check NULL before assignments Assign 'xe_devcoredump_snapshot *' and 'xe_device *' only if 'coredump' is not NULL. v2 - Fix commit messages. v3 - Define variables before code.(Ashutosh/Jose) v4 - Drop return check for coredump_to_xe. (Jose/Rodrigo) v5 - Modify misleading commit message. (Matt)",
      "id": "CVE-2024-42081",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:35Z"
      },
      "bom-ref": "6699cecb-ae79-4fc3-8d8c-ceaf586082b4",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gfs2: Fix NULL pointer dereference in gfs2_log_flush In gfs2_jindex_free(), set sdp->sd_jdesc to NULL under the log flush lock to provide exclusion against gfs2_log_flush(). In gfs2_log_flush(), check if sdp->sd_jdesc is non-NULL before dereferencing it. Otherwise, we could run into a NULL pointer dereference when outstanding glock work races with an unmount (glock_work_func -> run_queue -> do_xmote -> inode_go_sync -> gfs2_log_flush).",
      "id": "CVE-2024-42079",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:36Z"
      },
      "bom-ref": "c5914bac-c290-41c6-abdd-0dd151fc2653",
      "cwes": [
        665
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: initialise nfsd_info.mutex early. nfsd_info.mutex can be dereferenced by svc_pool_stats_start() immediately after the new netns is created. Currently this can trigger an oops. Move the initialisation earlier before it can possibly be dereferenced.",
      "id": "CVE-2024-42078",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:38Z"
      },
      "bom-ref": "67f66201-c272-4974-94dd-2df4be7487f8",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix remap of arena. The bpf arena logic didn't account for mremap operation. Add a refcnt for multiple mmap events to prevent use-after-free in arena_vm_close.",
      "id": "CVE-2024-42075",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:39Z"
      },
      "bom-ref": "2e915142-45f1-4e0d-b772-b0b2ef5e7ccf",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: amd: acp: add a null check for chip_pdev structure When acp platform device creation is skipped, chip->chip_pdev value will remain NULL. Add NULL check for chip->chip_pdev structure in snd_acp_resume() function to avoid null pointer dereference.",
      "id": "CVE-2024-42074",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:41Z"
      },
      "bom-ref": "9762a9be-d52e-4240-b7e0-345eac96a8d3",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: spectrum_buffers: Fix memory corruptions on Spectrum-4 systems The following two shared buffer operations make use of the Shared Buffer Status Register (SBSR): # devlink sb occupancy snapshot pci/0000:01:00.0 # devlink sb occupancy clearmax pci/0000:01:00.0 The register has two masks of 256 bits to denote on which ingress / egress ports the register should operate on. Spectrum-4 has more than 256 ports, so the register was extended by cited commit with a new 'port_page' field. However, when filling the register's payload, the driver specifies the ports as absolute numbers and not relative to the first port of the port page, resulting in memory corruptions [1]. Fix by specifying the ports relative to the first port of the port page. [1] BUG: KASAN: slab-use-after-free in mlxsw_sp_sb_occ_snapshot+0xb6d/0xbc0 Read of size 1 at addr ffff8881068cb00f by task devlink/1566 [...] Call Trace: <TASK> dump_stack_lvl+0xc6/0x120 print_report+0xce/0x670 kasan_report+0xd7/0x110 mlxsw_sp_sb_occ_snapshot+0xb6d/0xbc0 mlxsw_devlink_sb_occ_snapshot+0x75/0xb0 devlink_nl_sb_occ_snapshot_doit+0x1f9/0x2a0 genl_family_rcv_msg_doit+0x20c/0x300 genl_rcv_msg+0x567/0x800 netlink_rcv_skb+0x170/0x450 genl_rcv+0x2d/0x40 netlink_unicast+0x547/0x830 netlink_sendmsg+0x8d4/0xdb0 __sys_sendto+0x49b/0x510 __x64_sys_sendto+0xe5/0x1c0 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f [...] Allocated by task 1: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 copy_verifier_state+0xbc2/0xfb0 do_check_common+0x2c51/0xc7e0 bpf_check+0x5107/0x9960 bpf_prog_load+0xf0e/0x2690 __sys_bpf+0x1a61/0x49d0 __x64_sys_bpf+0x7d/0xc0 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 1: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 poison_slab_object+0x109/0x170 __kasan_slab_free+0x14/0x30 kfree+0xca/0x2b0 free_verifier_state+0xce/0x270 do_check_common+0x4828/0xc7e0 bpf_check+0x5107/0x9960 bpf_prog_load+0xf0e/0x2690 __sys_bpf+0x1a61/0x49d0 __x64_sys_bpf+0x7d/0xc0 do_syscall_64+0xc1/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-42073",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:42Z"
      },
      "bom-ref": "4855c340-5b69-4484-a445-9d6f7731a90e",
      "cwes": [
        834
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ionic: use dev_consume_skb_any outside of napi If we're not in a NAPI softirq context, we need to be careful about how we call napi_consume_skb(), specifically we need to call it with budget==0 to signal to it that we're not in a safe context. This was found while running some configuration stress testing of traffic and a change queue config loop running, and this curious note popped out: [ 4371.402645] BUG: using smp_processor_id() in preemptible [00000000] code: ethtool/20545 [ 4371.402897] caller is napi_skb_cache_put+0x16/0x80 [ 4371.403120] CPU: 25 PID: 20545 Comm: ethtool Kdump: loaded Tainted: G OE 6.10.0-rc3-netnext+ #8 [ 4371.403302] Hardware name: HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 01/23/2021 [ 4371.403460] Call Trace: [ 4371.403613] <TASK> [ 4371.403758] dump_stack_lvl+0x4f/0x70 [ 4371.403904] check_preemption_disabled+0xc1/0xe0 [ 4371.404051] napi_skb_cache_put+0x16/0x80 [ 4371.404199] ionic_tx_clean+0x18a/0x240 [ionic] [ 4371.404354] ionic_tx_cq_service+0xc4/0x200 [ionic] [ 4371.404505] ionic_tx_flush+0x15/0x70 [ionic] [ 4371.404653] ? ionic_lif_qcq_deinit.isra.23+0x5b/0x70 [ionic] [ 4371.404805] ionic_txrx_deinit+0x71/0x190 [ionic] [ 4371.404956] ionic_reconfigure_queues+0x5f5/0xff0 [ionic] [ 4371.405111] ionic_set_ringparam+0x2e8/0x3e0 [ionic] [ 4371.405265] ethnl_set_rings+0x1f1/0x300 [ 4371.405418] ethnl_default_set_doit+0xbb/0x160 [ 4371.405571] genl_family_rcv_msg_doit+0xff/0x130 [...] I found that ionic_tx_clean() calls napi_consume_skb() which calls napi_skb_cache_put(), but before that last call is the note /* Zero budget indicate non-NAPI context called us, like netpoll */ and DEBUG_NET_WARN_ON_ONCE(!in_softirq()); Those are pretty big hints that we're doing it wrong. We can pass a context hint down through the calls to let ionic_tx_clean() know what we're doing so it can call napi_consume_skb() correctly.",
      "id": "CVE-2024-42071",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:44Z"
      },
      "bom-ref": "252f2631-9e08-4471-afe1-cdd8d0f04463",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: mana: Fix possible double free in error handling path When auxiliary_device_add() returns error and then calls auxiliary_device_uninit(), callback function adev_release calls kfree(madev). We shouldn't call kfree(madev) again in the error handling path. Set 'madev' to NULL.",
      "id": "CVE-2024-42069",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:45Z"
      },
      "bom-ref": "c4215a96-ea07-46e0-844f-e5bd70205dc8",
      "cwes": [
        252
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Take return from set_memory_rox() into account with bpf_jit_binary_lock_ro() set_memory_rox() can fail, leaving memory unprotected. Check return and bail out when bpf_jit_binary_lock_ro() returns an error.",
      "id": "CVE-2024-42067",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-24T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:47Z"
      },
      "bom-ref": "12a75751-ac50-4df1-bb38-f334ea341f4d",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe: Fix potential integer overflow in page size calculation Explicitly cast tbo->page_alignment to u64 before bit-shifting to prevent overflow when assigning to min_page_size.",
      "id": "CVE-2024-42066",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:48Z"
      },
      "bom-ref": "b6d68c0b-128b-4ceb-8675-146f405b3cf8",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe: Add a NULL check in xe_ttm_stolen_mgr_init Add an explicit check to ensure that the mgr is not NULL.",
      "id": "CVE-2024-42065",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "cfdcc37c-ca20-4131-8a5e-c76afd336c76",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Skip pipe if the pipe idx not set properly [why] Driver crashes when pipe idx not set properly [how] Add code to skip the pipe that idx not set properly",
      "id": "CVE-2024-42064",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:50Z"
      },
      "bom-ref": "ba465a36-cbee-4061-8023-c154f5e83669",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Mark bpf prog stack with kmsan_unposion_memory in interpreter mode syzbot reported uninit memory usages during map_{lookup,delete}_elem. ========== BUG: KMSAN: uninit-value in __dev_map_lookup_elem kernel/bpf/devmap.c:441 [inline] BUG: KMSAN: uninit-value in dev_map_lookup_elem+0xf3/0x170 kernel/bpf/devmap.c:796 __dev_map_lookup_elem kernel/bpf/devmap.c:441 [inline] dev_map_lookup_elem+0xf3/0x170 kernel/bpf/devmap.c:796 ____bpf_map_lookup_elem kernel/bpf/helpers.c:42 [inline] bpf_map_lookup_elem+0x5c/0x80 kernel/bpf/helpers.c:38 ___bpf_prog_run+0x13fe/0xe0f0 kernel/bpf/core.c:1997 __bpf_prog_run256+0xb5/0xe0 kernel/bpf/core.c:2237 ========== The reproducer should be in the interpreter mode. The C reproducer is trying to run the following bpf prog: 0: (18) r0 = 0x0 2: (18) r1 = map[id:49] 4: (b7) r8 = 16777216 5: (7b) *(u64 *)(r10 -8) = r8 6: (bf) r2 = r10 7: (07) r2 += -229 ^^^^^^^^^^ 8: (b7) r3 = 8 9: (b7) r4 = 0 10: (85) call dev_map_lookup_elem#1543472 11: (95) exit It is due to the \"void *key\" (r2) passed to the helper. bpf allows uninit stack memory access for bpf prog with the right privileges. This patch uses kmsan_unpoison_memory() to mark the stack as initialized. This should address different syzbot reports on the uninit \"void *key\" argument during map_{lookup,delete}_elem.",
      "id": "CVE-2024-42063",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:51Z"
      },
      "bom-ref": "04875d61-f08f-4e00-ae84-73a368ca386b",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ata: libata-core: Fix null pointer dereference on error If the ata_port_alloc() call in ata_host_alloc() fails, ata_host_release() will get called. However, the code in ata_host_release() tries to free ata_port struct members unconditionally, which can lead to the following: BUG: unable to handle page fault for address: 0000000000003990 PGD 0 P4D 0 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 10 PID: 594 Comm: (udev-worker) Not tainted 6.10.0-rc5 #44 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:ata_host_release.cold+0x2f/0x6e [libata] Code: e4 4d 63 f4 44 89 e2 48 c7 c6 90 ad 32 c0 48 c7 c7 d0 70 33 c0 49 83 c6 0e 41 RSP: 0018:ffffc90000ebb968 EFLAGS: 00010246 RAX: 0000000000000041 RBX: ffff88810fb52e78 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffff88813b3218c0 RDI: ffff88813b3218c0 RBP: ffff88810fb52e40 R08: 0000000000000000 R09: 6c65725f74736f68 R10: ffffc90000ebb738 R11: 73692033203a746e R12: 0000000000000004 R13: 0000000000000000 R14: 0000000000000011 R15: 0000000000000006 FS: 00007f6cc55b9980(0000) GS:ffff88813b300000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000003990 CR3: 00000001122a2000 CR4: 0000000000750ef0 PKRU: 55555554 Call Trace: <TASK> ? __die_body.cold+0x19/0x27 ? page_fault_oops+0x15a/0x2f0 ? exc_page_fault+0x7e/0x180 ? asm_exc_page_fault+0x26/0x30 ? ata_host_release.cold+0x2f/0x6e [libata] ? ata_host_release.cold+0x2f/0x6e [libata] release_nodes+0x35/0xb0 devres_release_group+0x113/0x140 ata_host_alloc+0xed/0x120 [libata] ata_host_alloc_pinfo+0x14/0xa0 [libata] ahci_init_one+0x6c9/0xd20 [ahci] Do not access ata_port struct members unconditionally.",
      "id": "CVE-2024-41098",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_CAN_MCP251XFD is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "ca174198-0378-4995-9532-788a89da3ad5",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: can: mcp251xfd: fix infinite loop when xmit fails When the mcp251xfd_start_xmit() function fails, the driver stops processing messages, and the interrupt routine does not return, running indefinitely even after killing the running application. Error messages: [ 441.298819] mcp251xfd spi2.0 can0: ERROR in mcp251xfd_start_xmit: -16 [ 441.306498] mcp251xfd spi2.0 can0: Transmit Event FIFO buffer not empty. (seq=0x000017c7, tef_tail=0x000017cf, tef_head=0x000017d0, tx_head=0x000017d3). ... and repeat forever. The issue can be triggered when multiple devices share the same SPI interface. And there is concurrent access to the bus. The problem occurs because tx_ring->head increments even if mcp251xfd_start_xmit() fails. Consequently, the driver skips one TX package while still expecting a response in mcp251xfd_handle_tefif_one(). Resolve the issue by starting a workqueue to write the tx obj synchronously if err = -EBUSY. In case of another error, decrement tx_ring->head, remove skb from the echo stack, and drop the message. [mkl: use more imperative wording in patch description]",
      "id": "CVE-2024-41088",
      "published": "2024-07-29T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:53Z"
      },
      "bom-ref": "a581f29b-c59e-4fec-bc92-a12859432000",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring: fix possible deadlock in io_register_iowq_max_workers() The io_register_iowq_max_workers() function calls io_put_sq_data(), which acquires the sqd->lock without releasing the uring_lock. Similar to the commit 009ad9f0c6ee (\"io_uring: drop ctx->uring_lock before acquiring sqd->lock\"), this can lead to a potential deadlock situation. To resolve this issue, the uring_lock is released before calling io_put_sq_data(), and then it is re-acquired after the function call. This change ensures that the locks are acquired in the correct order, preventing the possibility of a deadlock.",
      "id": "CVE-2024-41080",
      "published": "2024-07-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:54Z"
      },
      "bom-ref": "8f3c4d9c-47b6-4b9e-b2b0-70df100f267a",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: NFSv4: Fix memory leak in nfs4_set_security_label We leak nfs_fattr and nfs4_label every time we set a security xattr.",
      "id": "CVE-2024-41076",
      "published": "2024-07-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:56Z"
      },
      "bom-ref": "b9c814bc-d0ee-49f0-af68-39df97d1727f",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ibmvnic: Add tx check to prevent skb leak Below is a summary of how the driver stores a reference to an skb during transmit: tx_buff[free_map[consumer_index]]->skb = new_skb; free_map[consumer_index] = IBMVNIC_INVALID_MAP; consumer_index ++; Where variable data looks like this: free_map == [4, IBMVNIC_INVALID_MAP, IBMVNIC_INVALID_MAP, 0, 3] consumer_index^ tx_buff == [skb=null, skb=<ptr>, skb=<ptr>, skb=null, skb=null] The driver has checks to ensure that free_map[consumer_index] pointed to a valid index but there was no check to ensure that this index pointed to an unused/null skb address. So, if, by some chance, our free_map and tx_buff lists become out of sync then we were previously risking an skb memory leak. This could then cause tcp congestion control to stop sending packets, eventually leading to ETIMEDOUT. Therefore, add a conditional to ensure that the skb address is null. If not then warn the user (because this is still a bug that should be patched) and free the old pointer to prevent memleak/tcp problems.",
      "id": "CVE-2024-41066",
      "published": "2024-07-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "83310438-e66f-43bf-8e6d-20bf0f867875",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix array-index-out-of-bounds in dml2/FCLKChangeSupport [Why] Potential out of bounds access in dml2_calculate_rq_and_dlg_params() because the value of out_lowest_state_idx used as an index for FCLKChangeSupport array can be greater than 1. [How] Currently dml2 core specifies identical values for all FCLKChangeSupport elements. Always use index 0 in the condition to avoid out of bounds access.",
      "id": "CVE-2024-41061",
      "published": "2024-07-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:57Z"
      },
      "bom-ref": "dee9d49e-9685-487e-bcd6-d5de5786c3e0",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: sched/deadline: Fix task_struct reference leak During the execution of the following stress test with linux-rt: stress-ng --cyclic 30 --timeout 30 --minimize --quiet kmemleak frequently reported a memory leak concerning the task_struct: unreferenced object 0xffff8881305b8000 (size 16136): comm \"stress-ng\", pid 614, jiffies 4294883961 (age 286.412s) object hex dump (first 32 bytes): 02 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 .@.............. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ debug hex dump (first 16 bytes): 53 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00 S............... backtrace: [<00000000046b6790>] dup_task_struct+0x30/0x540 [<00000000c5ca0f0b>] copy_process+0x3d9/0x50e0 [<00000000ced59777>] kernel_clone+0xb0/0x770 [<00000000a50befdc>] __do_sys_clone+0xb6/0xf0 [<000000001dbf2008>] do_syscall_64+0x5d/0xf0 [<00000000552900ff>] entry_SYSCALL_64_after_hwframe+0x6e/0x76 The issue occurs in start_dl_timer(), which increments the task_struct reference count and sets a timer. The timer callback, dl_task_timer, is supposed to decrement the reference count upon expiration. However, if enqueue_task_dl() is called before the timer expires and cancels it, the reference count is not decremented, leading to the leak. This patch fixes the reference leak by ensuring the task_struct reference count is properly decremented when the timer is canceled.",
      "id": "CVE-2024-41023",
      "published": "2024-07-29T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-04T16:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "52e12c59-5288-48e8-9e55-286b933e9a5f",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: xfs: add bounds checking to xlog_recover_process_data There is a lack of verification of the space occupied by fixed members of xlog_op_header in the xlog_recover_process_data. We can create a crafted image to trigger an out of bounds read by following these steps: 1) Mount an image of xfs, and do some file operations to leave records 2) Before umounting, copy the image for subsequent steps to simulate abnormal exit. Because umount will ensure that tail_blk and head_blk are the same, which will result in the inability to enter xlog_recover_process_data 3) Write a tool to parse and modify the copied image in step 2 4) Make the end of the xlog_op_header entries only 1 byte away from xlog_rec_header->h_size 5) xlog_rec_header->h_num_logops++ 6) Modify xlog_rec_header->h_crc Fix: Add a check to make sure there is sufficient space to access fixed members of xlog_op_header.",
      "id": "CVE-2024-41014",
      "published": "2024-07-29T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-05T19:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:51:59Z"
      },
      "bom-ref": "0fa1287e-3126-4665-9c96-558d0306ba84",
      "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/pseries: Fix scv instruction crash with kexec kexec on pseries disables AIL (reloc_on_exc), required for scv instruction support, before other CPUs have been shut down. This means they can execute scv instructions after AIL is disabled, which causes an interrupt at an unexpected entry location that crashes the kernel. Change the kexec sequence to disable AIL after other CPUs have been brought down. As a refresher, the real-mode scv interrupt vector is 0x17000, and the fixed-location head code probably couldn't easily deal with implementing such high addresses so it was just decided not to support that interrupt at all.",
      "id": "CVE-2024-42230",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "234f03ba-249d-40c4-834d-d331c682983e",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Using uninitialized value *size when calling amdgpu_vce_cs_reloc Initialize the size before calling amdgpu_vce_cs_reloc, such as case 0x03000001. V2: To really improve the handling we would actually need to have a separate value of 0xffffffff.(Christian)",
      "id": "CVE-2024-42228",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b0a4b1f5-b4fe-4aa9-83df-4f2d8c3b46cd",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix overlapping copy within dml_core_mode_programming [WHY] &mode_lib->mp.Watermark and &locals->Watermark are the same address. memcpy may lead to unexpected behavior. [HOW] memmove should be used.",
      "id": "CVE-2024-42227",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as NET_VENDOR_GOOGLE not enabled in kernel,",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "d4f9ce6f-668c-463c-b25c-4291ea6615c1",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gve: Account for stopped queues when reading NIC stats We now account for the fact that the NIC might send us stats for a subset of queues. Without this change, gve_get_ethtool_stats might make an invalid access on the priv->stats_report->stats array.",
      "id": "CVE-2024-42162",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_F2FS_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c0096b87-0cba-4556-b4c6-947f245e45c3",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: check validation of fault attrs in f2fs_build_fault_attr() - It missed to check validation of fault attrs in parse_options(), let's fix to add check condition in f2fs_build_fault_attr(). - Use f2fs_build_fault_attr() in __sbi_store() to clean up code.",
      "id": "CVE-2024-42160",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SCSI_MPI3MR not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e50501e6-88dd-41e0-abfe-3eca1caac75e",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: mpi3mr: Sanitise num_phys Information is stored in mr_sas_port->phy_mask, values larger then size of this field shouldn't be allowed.",
      "id": "CVE-2024-42159",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "S390 architecture not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1fdcda76-b5bf-4dd9-b150-1747daa52786",
      "cwes": [
        669
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: s390/pkey: Use kfree_sensitive() to fix Coccinelle warnings Replace memzero_explicit() and kfree() with kfree_sensitive() to fix warnings reported by Coccinelle: WARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1506) WARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1643) WARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1770)",
      "id": "CVE-2024-42158",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.1,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "S390 architecture not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "28c3bad2-ffbc-48e6-9d5b-7d1d5d5735a1",
      "description": "In the Linux kernel, the following vulnerability has been resolved: s390/pkey: Wipe copies of clear-key structures on failure Wipe all sensitive data from stack for all IOCTLs, which convert a clear-key into a protected- or secure-key.",
      "id": "CVE-2024-42156",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.1,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T13:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "S390 architecture not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "d3fe0edf-173a-4610-a6a8-9526d6a764db",
      "description": "In the Linux kernel, the following vulnerability has been resolved: s390/pkey: Wipe copies of protected- and secure-keys Although the clear-key of neither protected- nor secure-keys is accessible, this key material should only be visible to the calling process. So wipe all copies of protected- or secure-keys from stack, even in case of an error.",
      "id": "CVE-2024-42155",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 1.9,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:00Z"
      },
      "bom-ref": "8296c50b-26ae-4c01-b271-41367e7b2847",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: mark bpf_dummy_struct_ops.test_1 parameter as nullable Test case dummy_st_ops/dummy_init_ret_value passes NULL as the first parameter of the test_1() function. Mark this parameter as nullable to make verifier aware of such possibility. Otherwise, NULL check in the test_1() code: SEC(\"struct_ops/test_1\") int BPF_PROG(test_1, struct bpf_dummy_ops_state *state) { if (!state) return ...; ... access state ... } Might be removed by verifier, thus triggering NULL pointer dereference under certain conditions.",
      "id": "CVE-2024-42151",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T23:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as devices are not using hisillicon/huawai SoCs",
        "justification": "requires_environment",
        "state": "not_affected"
      },
      "bom-ref": "f2619099-bb06-442e-90b5-09b54c7c7d66",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: hisilicon/debugfs - Fix debugfs uninit process issue During the zip probe process, the debugfs failure does not stop the probe. When debugfs initialization fails, jumping to the error branch will also release regs, in addition to its own rollback operation. As a result, it may be released repeatedly during the regs uninit process. Therefore, the null check needs to be added to the regs uninit process.",
      "id": "CVE-2024-42147",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T15:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ARCH_MEDIATEK is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "000c3056-12cf-4e80-929f-dc8bc2c41c22",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: thermal/drivers/mediatek/lvts_thermal: Check NULL ptr on lvts_data Verify that lvts_data is not NULL before using it.",
      "id": "CVE-2024-42144",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:02Z"
      },
      "bom-ref": "1eaab273-839d-4e8c-9bc6-5be74de2c559",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: Fix improper extts handling Extts events are disabled and enabled by the application ts2phc. However, in case where the driver is removed when the application is running, a specific extts event remains enabled and can cause a kernel crash. As a side effect, when the driver is reloaded and application is started again, remaining extts event for the channel from a previous run will keep firing and the message \"extts on unexpected channel\" might be printed to the user. To avoid that, extts events shall be disabled when PTP is released.",
      "id": "CVE-2024-42139",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T15:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as not using cdrom",
        "state": "not_affected"
      },
      "bom-ref": "669a9e12-339d-4ee0-96ec-9b70c4a1ed51",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cdrom: rearrange last_media_change check to avoid unintentional overflow When running syzkaller with the newly reintroduced signed integer wrap sanitizer we encounter this splat: [ 366.015950] UBSAN: signed-integer-overflow in ../drivers/cdrom/cdrom.c:2361:33 [ 366.021089] -9223372036854775808 - 346321 cannot be represented in type '__s64' (aka 'long long') [ 366.025894] program syz-executor.4 is using a deprecated SCSI ioctl, please convert it to SG_IO [ 366.027502] CPU: 5 PID: 28472 Comm: syz-executor.7 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1 [ 366.027512] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014 [ 366.027518] Call Trace: [ 366.027523] <TASK> [ 366.027533] dump_stack_lvl+0x93/0xd0 [ 366.027899] handle_overflow+0x171/0x1b0 [ 366.038787] ata1.00: invalid multi_count 32 ignored [ 366.043924] cdrom_ioctl+0x2c3f/0x2d10 [ 366.063932] ? __pm_runtime_resume+0xe6/0x130 [ 366.071923] sr_block_ioctl+0x15d/0x1d0 [ 366.074624] ? __pfx_sr_block_ioctl+0x10/0x10 [ 366.077642] blkdev_ioctl+0x419/0x500 [ 366.080231] ? __pfx_blkdev_ioctl+0x10/0x10 ... Historically, the signed integer overflow sanitizer did not work in the kernel due to its interaction with `-fwrapv` but this has since been changed [1] in the newest version of Clang. It was re-enabled in the kernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow sanitizer\"). Let's rearrange the check to not perform any arithmetic, thus not tripping the sanitizer.",
      "id": "CVE-2024-42136",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:03Z"
      },
      "bom-ref": "3a2a8262-abe4-47c1-900d-619df95afcd3",
      "description": "In the Linux kernel, the following vulnerability has been resolved: vhost_task: Handle SIGKILL by flushing work and exiting Instead of lingering until the device is closed, this has us handle SIGKILL by: 1. marking the worker as killed so we no longer try to use it with new virtqueues and new flush operations. 2. setting the virtqueue to worker mapping so no new works are queued. 3. running all the exiting works.",
      "id": "CVE-2024-42135",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T14:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:05Z"
      },
      "bom-ref": "323a261e-7e76-44f3-a2a1-b1b061ea1eca",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: virtio-pci: Check if is_avq is NULL [bug] In the virtio_pci_common.c function vp_del_vqs, vp_dev->is_avq is involved to determine whether it is admin virtqueue, but this function vp_dev->is_avq may be empty. For installations, virtio_pci_legacy does not assign a value to vp_dev->is_avq. [fix] Check whether it is vp_dev->is_avq before use. [test] Test with virsh Attach device Before this patch, the following command would crash the guest system After applying the patch, everything seems to be working fine.",
      "id": "CVE-2024-42134",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T17:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "54e40c16-fbe3-4a2d-80ab-c5eb5ae83b21",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix double free err_addr pointer warnings In amdgpu_umc_bad_page_polling_timeout, the amdgpu_umc_handle_bad_pages will be run many times so that double free err_addr in some special case. So set the err_addr to NULL to avoid the warnings.",
      "id": "CVE-2024-42123",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "824acfb2-3dd1-4394-b1f3-cd4486a62ab7",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL pointer check for kzalloc [Why & How] Check return pointer of kzalloc before using it.",
      "id": "CVE-2024-42122",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-21T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:06Z"
      },
      "bom-ref": "a6f9f4b7-ae0c-445f-9b8c-2617dc40f9de",
      "cwes": [
        476,
        367
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: Don't process extts if PTP is disabled The ice_ptp_extts_event() function can race with ice_ptp_release() and result in a NULL pointer dereference which leads to a kernel panic. Panic occurs because the ice_ptp_extts_event() function calls ptp_clock_event() with a NULL pointer. The ice driver has already released the PTP clock by the time the interrupt for the next external timestamp event occurs. To fix this, modify the ice_ptp_extts_event() function to check the PTP state and bail early if PTP is not ready.",
      "id": "CVE-2024-42107",
      "published": "2024-07-30T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-08T21:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:08Z"
      },
      "bom-ref": "7ab82d00-3a3a-4eb2-9ff8-41441fa784c2",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net, sunrpc: Remap EPERM in case of connection failure in xs_tcp_setup_socket When using a BPF program on kernel_connect(), the call can return -EPERM. This causes xs_tcp_setup_socket() to loop forever, filling up the syslog and causing the kernel to potentially freeze up. Neil suggested: This will propagate -EPERM up into other layers which might not be ready to handle it. It might be safer to map EPERM to an error we would be more likely to expect from the network system - such as ECONNREFUSED or ENETDOWN. ECONNREFUSED as error seems reasonable. For programs setting a different error can be out of reach (see handling in 4fbac77d2d09) in particular on kernels which do not have f10d05966196 (\"bpf: Make BPF_PROG_RUN_ARRAY return -err instead of allow boolean\"), thus given that it is better to simply remap for consistent behavior. UDP does handle EPERM in xs_udp_send_request().",
      "id": "CVE-2024-42246",
      "published": "2024-08-07T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:09Z"
      },
      "bom-ref": "c33bc4ac-9d6e-4514-bb45-245ba81c350e",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/bhi: Avoid warning in #DB handler due to BHI mitigation When BHI mitigation is enabled, if SYSENTER is invoked with the TF flag set then entry_SYSENTER_compat() uses CLEAR_BRANCH_HISTORY and calls the clear_bhb_loop() before the TF flag is cleared. This causes the #DB handler (exc_debug_kernel()) to issue a warning because single-step is used outside the entry_SYSENTER_compat() function. To address this issue, entry_SYSENTER_compat() should use CLEAR_BRANCH_HISTORY after making sure the TF flag is cleared. The problem can be reproduced with the following sequence: $ cat sysenter_step.c int main() { asm(\"pushf; pop %ax; bts $8,%ax; push %ax; popf; sysenter\"); } $ gcc -o sysenter_step sysenter_step.c $ ./sysenter_step Segmentation fault (core dumped) The program is expected to crash, and the #DB handler will issue a warning. Kernel log: WARNING: CPU: 27 PID: 7000 at arch/x86/kernel/traps.c:1009 exc_debug_kernel+0xd2/0x160 ... RIP: 0010:exc_debug_kernel+0xd2/0x160 ... Call Trace: <#DB> ? show_regs+0x68/0x80 ? __warn+0x8c/0x140 ? exc_debug_kernel+0xd2/0x160 ? report_bug+0x175/0x1a0 ? handle_bug+0x44/0x90 ? exc_invalid_op+0x1c/0x70 ? asm_exc_invalid_op+0x1f/0x30 ? exc_debug_kernel+0xd2/0x160 exc_debug+0x43/0x50 asm_exc_debug+0x1e/0x40 RIP: 0010:clear_bhb_loop+0x0/0xb0 ... </#DB> <TASK> ? entry_SYSENTER_compat_after_hwframe+0x6e/0x8d </TASK> [ bp: Massage commit message. ]",
      "id": "CVE-2024-42240",
      "published": "2024-08-07T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-08T14:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:11Z"
      },
      "bom-ref": "7ac9c3e1-7a13-4ca0-b54f-62c2136be999",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fail bpf_timer_cancel when callback is being cancelled Given a schedule: timer1 cb timer2 cb bpf_timer_cancel(timer2); bpf_timer_cancel(timer1); Both bpf_timer_cancel calls would wait for the other callback to finish executing, introducing a lockup. Add an atomic_t count named 'cancelling' in bpf_hrtimer. This keeps track of all in-flight cancellation requests for a given BPF timer. Whenever cancelling a BPF timer, we must check if we have outstanding cancellation requests, and if so, we must fail the operation with an error (-EDEADLK) since cancellation is synchronous and waits for the callback to finish executing. This implies that we can enter a deadlock situation involving two or more timer callbacks executing in parallel and attempting to cancel one another. Note that we avoid incrementing the cancelling counter for the target timer (the one being cancelled) if bpf_timer_cancel is not invoked from a callback, to avoid spurious errors. The whole point of detecting cur->cancelling and returning -EDEADLK is to not enter a busy wait loop (which may or may not lead to a lockup). This does not apply in case the caller is in a non-callback context, the other side can continue to cancel as it sees fit without running into errors. Background on prior attempts: Earlier versions of this patch used a bool 'cancelling' bit and used the following pattern under timer->lock to publish cancellation status. lock(t->lock); t->cancelling = true; mb(); if (cur->cancelling) return -EDEADLK; unlock(t->lock); hrtimer_cancel(t->timer); t->cancelling = false; The store outside the critical section could overwrite a parallel requests t->cancelling assignment to true, to ensure the parallely executing callback observes its cancellation status. It would be necessary to clear this cancelling bit once hrtimer_cancel is done, but lack of serialization introduced races. Another option was explored where bpf_timer_start would clear the bit when (re)starting the timer under timer->lock. This would ensure serialized access to the cancelling bit, but may allow it to be cleared before in-flight hrtimer_cancel has finished executing, such that lockups can occur again. Thus, we choose an atomic counter to keep track of all outstanding cancellation requests and use it to prevent lockups in case callbacks attempt to cancel each other while executing in parallel.",
      "id": "CVE-2024-42239",
      "published": "2024-08-07T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-08T14:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:12Z"
      },
      "bom-ref": "2b986e2b-839d-44ea-9c81-5fe7a9b5d037",
      "cwes": [
        834
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Validate payload length before processing block Move the payload length check in cs_dsp_load() and cs_dsp_coeff_load() to be done before the block is processed. The check that the length of a block payload does not exceed the number of remaining bytes in the firwmware file buffer was being done near the end of the loop iteration. However, some code before that check used the length field without validating it.",
      "id": "CVE-2024-42237",
      "published": "2024-08-07T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-08T14:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:14Z"
      },
      "bom-ref": "a77ae83e-1f24-42b2-a583-dcb58117d451",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gpio: pca953x: fix pca953x_irq_bus_sync_unlock race Ensure that `i2c_lock' is held when setting interrupt latch and mask in pca953x_irq_bus_sync_unlock() in order to avoid races. The other (non-probe) call site pca953x_gpio_set_multiple() ensures the lock is held before calling pca953x_write_regs(). The problem occurred when a request raced against irq_bus_sync_unlock() approximately once per thousand reboots on an i.MX8MP based system. * Normal case 0-0022: write register AI|3a {03,02,00,00,01} Input latch P0 0-0022: write register AI|49 {fc,fd,ff,ff,fe} Interrupt mask P0 0-0022: write register AI|08 {ff,00,00,00,00} Output P3 0-0022: write register AI|12 {fc,00,00,00,00} Config P3 * Race case 0-0022: write register AI|08 {ff,00,00,00,00} Output P3 0-0022: write register AI|08 {03,02,00,00,01} *** Wrong register *** 0-0022: write register AI|12 {fc,00,00,00,00} Config P3 0-0022: write register AI|49 {fc,fd,ff,ff,fe} Interrupt mask P0",
      "id": "CVE-2024-42253",
      "published": "2024-08-08T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-06T13:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:15Z"
      },
      "bom-ref": "448d36ae-aa4c-4f17-ba99-dceb60b24765",
      "cwes": [
        617
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: closures: Change BUG_ON() to WARN_ON() If a BUG_ON() can be hit in the wild, it shouldn't be a BUG_ON() For reference, this has popped up once in the CI, and we'll need more info to debug it: 03240 ------------[ cut here ]------------ 03240 kernel BUG at lib/closure.c:21! 03240 kernel BUG at lib/closure.c:21! 03240 Internal error: Oops - BUG: 00000000f2000800 [#1] SMP 03240 Modules linked in: 03240 CPU: 15 PID: 40534 Comm: kworker/u80:1 Not tainted 6.10.0-rc4-ktest-ga56da69799bd #25570 03240 Hardware name: linux,dummy-virt (DT) 03240 Workqueue: btree_update btree_interior_update_work 03240 pstate: 00001005 (nzcv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--) 03240 pc : closure_put+0x224/0x2a0 03240 lr : closure_put+0x24/0x2a0 03240 sp : ffff0000d12071c0 03240 x29: ffff0000d12071c0 x28: dfff800000000000 x27: ffff0000d1207360 03240 x26: 0000000000000040 x25: 0000000000000040 x24: 0000000000000040 03240 x23: ffff0000c1f20180 x22: 0000000000000000 x21: ffff0000c1f20168 03240 x20: 0000000040000000 x19: ffff0000c1f20140 x18: 0000000000000001 03240 x17: 0000000000003aa0 x16: 0000000000003ad0 x15: 1fffe0001c326974 03240 x14: 0000000000000a1e x13: 0000000000000000 x12: 1fffe000183e402d 03240 x11: ffff6000183e402d x10: dfff800000000000 x9 : ffff6000183e402e 03240 x8 : 0000000000000001 x7 : 00009fffe7c1bfd3 x6 : ffff0000c1f2016b 03240 x5 : ffff0000c1f20168 x4 : ffff6000183e402e x3 : ffff800081391954 03240 x2 : 0000000000000001 x1 : 0000000000000000 x0 : 00000000a8000000 03240 Call trace: 03240 closure_put+0x224/0x2a0 03240 bch2_check_for_deadlock+0x910/0x1028 03240 bch2_six_check_for_deadlock+0x1c/0x30 03240 six_lock_slowpath.isra.0+0x29c/0xed0 03240 six_lock_ip_waiter+0xa8/0xf8 03240 __bch2_btree_node_lock_write+0x14c/0x298 03240 bch2_trans_lock_write+0x6d4/0xb10 03240 __bch2_trans_commit+0x135c/0x5520 03240 btree_interior_update_work+0x1248/0x1c10 03240 process_scheduled_works+0x53c/0xd90 03240 worker_thread+0x370/0x8c8 03240 kthread+0x258/0x2e8 03240 ret_from_fork+0x10/0x20 03240 Code: aa1303e0 d63f0020 a94363f7 17ffff8c (d4210000) 03240 ---[ end trace 0000000000000000 ]--- 03240 Kernel panic - not syncing: Oops - BUG: Fatal exception 03240 SMP: stopping secondary CPUs 03241 SMP: failed to stop secondary CPUs 13,15 03241 Kernel Offset: disabled 03241 CPU features: 0x00,00000003,80000008,4240500b 03241 Memory Limit: none 03241 ---[ end Kernel panic - not syncing: Oops - BUG: Fatal exception ]--- 03246 ========= FAILED TIMEOUT copygc_torture_no_checksum in 7200s",
      "id": "CVE-2024-42252",
      "published": "2024-08-08T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:17Z"
      },
      "bom-ref": "b03061b4-8f14-4712-961b-33e22497a758",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: md: fix deadlock between mddev_suspend and flush bio Deadlock occurs when mddev is being suspended while some flush bio is in progress. It is a complex issue. T1. the first flush is at the ending stage, it clears 'mddev->flush_bio' and tries to submit data, but is blocked because mddev is suspended by T4. T2. the second flush sets 'mddev->flush_bio', and attempts to queue md_submit_flush_data(), which is already running (T1) and won't execute again if on the same CPU as T1. T3. the third flush inc active_io and tries to flush, but is blocked because 'mddev->flush_bio' is not NULL (set by T2). T4. mddev_suspend() is called and waits for active_io dec to 0 which is inc by T3. T1 T2 T3 T4 (flush 1) (flush 2) (third 3) (suspend) md_submit_flush_data mddev->flush_bio = NULL; . . md_flush_request . mddev->flush_bio = bio . queue submit_flushes . . . . md_handle_request . . active_io + 1 . . md_flush_request . . wait !mddev->flush_bio . . . . mddev_suspend . . wait !active_io . . . submit_flushes . queue_work md_submit_flush_data . //md_submit_flush_data is already running (T1) . md_handle_request wait resume The root issue is non-atomic inc/dec of active_io during flush process. active_io is dec before md_submit_flush_data is queued, and inc soon after md_submit_flush_data() run. md_flush_request active_io + 1 submit_flushes active_io - 1 md_submit_flush_data md_handle_request active_io + 1 make_request active_io - 1 If active_io is dec after md_handle_request() instead of within submit_flushes(), make_request() can be called directly intead of md_handle_request() in md_submit_flush_data(), and active_io will only inc and dec once in the whole flush process. Deadlock will be fixed. Additionally, the only difference between fixing the issue and before is that there is no return error handling of make_request(). But after previous patch cleaned md_write_start(), make_requst() only return error in raid5_make_request() by dm-raid, see commit 41425f96d7aa (\"dm-raid456, md/raid456: fix a deadlock for dm-raid456 while io concurrent with reshape)\". Since dm always splits data and flush operation into two separate io, io size of flush submitted by dm always is 0, make_request() will not be called in md_submit_flush_data(). To prevent future modifications from introducing issues, add WARN_ON to ensure make_request() no error is returned in this context.",
      "id": "CVE-2024-43855",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-22T17:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:18Z"
      },
      "bom-ref": "686eed8d-1f53-44b5-a649-e48ee5dbf89b",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cgroup/cpuset: Prevent UAF in proc_cpuset_show() An UAF can happen when /proc/cpuset is read as reported in [1]. This can be reproduced by the following methods: 1.add an mdelay(1000) before acquiring the cgroup_lock In the cgroup_path_ns function. 2.$cat /proc/<pid>/cpuset repeatly. 3.$mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset/ $umount /sys/fs/cgroup/cpuset/ repeatly. The race that cause this bug can be shown as below: (umount) | (cat /proc/<pid>/cpuset) css_release | proc_cpuset_show css_release_work_fn | css = task_get_css(tsk, cpuset_cgrp_id); css_free_rwork_fn | cgroup_path_ns(css->cgroup, ...); cgroup_destroy_root | mutex_lock(&cgroup_mutex); rebind_subsystems | cgroup_free_root | | // cgrp was freed, UAF | cgroup_path_ns_locked(cgrp,..); When the cpuset is initialized, the root node top_cpuset.css.cgrp will point to &cgrp_dfl_root.cgrp. In cgroup v1, the mount operation will allocate cgroup_root, and top_cpuset.css.cgrp will point to the allocated &cgroup_root.cgrp. When the umount operation is executed, top_cpuset.css.cgrp will be rebound to &cgrp_dfl_root.cgrp. The problem is that when rebinding to cgrp_dfl_root, there are cases where the cgroup_root allocated by setting up the root for cgroup v1 is cached. This could lead to a Use-After-Free (UAF) if it is subsequently freed. The descendant cgroups of cgroup v1 can only be freed after the css is released. However, the css of the root will never be released, yet the cgroup_root should be freed when it is unmounted. This means that obtaining a reference to the css of the root does not guarantee that css.cgrp->root will not be freed. Fix this problem by using rcu_read_lock in proc_cpuset_show(). As cgroup_root is kfree_rcu after commit d23b5c577715 (\"cgroup: Make operations on the cgroup root_list RCU safe\"), css->cgroup won't be freed during the critical section. To call cgroup_path_ns_locked, css_set_lock is needed, so it is safe to replace task_get_css with task_css. [1] https://syzkaller.appspot.com/bug?extid=9b1ff7be974a403aa4cd",
      "id": "CVE-2024-43853",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-04T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:20Z"
      },
      "bom-ref": "cfdbae48-1224-4bf0-8f85-5f3e82cf4e0c",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: soc: qcom: pdr: protect locator_addr with the main mutex If the service locator server is restarted fast enough, the PDR can rewrite locator_addr fields concurrently. Protect them by placing modification of those fields under the main pdr->lock.",
      "id": "CVE-2024-43849",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T16:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:21Z"
      },
      "bom-ref": "fd8e8e38-1994-4fc6-9c9b-2fc3f3636889",
      "description": "In the Linux kernel, the following vulnerability has been resolved: lib: objagg: Fix general protection fault The library supports aggregation of objects into other objects only if the parent object does not have a parent itself. That is, nesting is not supported. Aggregation happens in two cases: Without and with hints, where hints are a pre-computed recommendation on how to aggregate the provided objects. Nesting is not possible in the first case due to a check that prevents it, but in the second case there is no check because the assumption is that nesting cannot happen when creating objects based on hints. The violation of this assumption leads to various warnings and eventually to a general protection fault [1]. Before fixing the root cause, error out when nesting happens and warn. [1] general protection fault, probably for non-canonical address 0xdead000000000d90: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 1083 Comm: kworker/1:9 Tainted: G W 6.9.0-rc6-custom-gd9b4f1cca7fb #7 Hardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019 Workqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work RIP: 0010:mlxsw_sp_acl_erp_bf_insert+0x25/0x80 [...] Call Trace: <TASK> mlxsw_sp_acl_atcam_entry_add+0x256/0x3c0 mlxsw_sp_acl_tcam_entry_create+0x5e/0xa0 mlxsw_sp_acl_tcam_vchunk_migrate_one+0x16b/0x270 mlxsw_sp_acl_tcam_vregion_rehash_work+0xbe/0x510 process_one_work+0x151/0x370 worker_thread+0x2cb/0x3e0 kthread+0xd0/0x100 ret_from_fork+0x34/0x50 ret_from_fork_asm+0x1a/0x30 </TASK>",
      "id": "CVE-2024-43846",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T19:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:23Z"
      },
      "bom-ref": "01c16fe1-3c44-4942-be2a-436a8d801f31",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: virt_wifi: avoid reporting connection success with wrong SSID When user issues a connection with a different SSID than the one virt_wifi has advertised, the __cfg80211_connect_result() will trigger the warning: WARN_ON(bss_not_found). The issue is because the connection code in virt_wifi does not check the SSID from user space (it only checks the BSSID), and virt_wifi will call cfg80211_connect_result() with WLAN_STATUS_SUCCESS even if the SSID is different from the one virt_wifi has advertised. Eventually cfg80211 won't be able to find the cfg80211_bss and generate the warning. Fixed it by checking the SSID (from user space) in the connection code.",
      "id": "CVE-2024-43841",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-29T16:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as NET_VENDOR_BROCADE not enabled in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "9dd38735-1508-4a9c-9f64-0495fa3a4281",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bna: adjust 'name' buf size of bna_tcb and bna_ccb structures To have enough space to write all possible sprintf() args. Currently 'name' size is 16, but the first '%s' specifier may already need at least 16 characters, since 'bnad->netdev->name' is used there. For '%d' specifiers, assume that they require: * 1 char for 'tx_id + tx_info->tcb[i]->id' sum, BNAD_MAX_TXQ_PER_TX is 8 * 2 chars for 'rx_id + rx_info->rx_ctrl[i].ccb->id', BNAD_MAX_RXP_PER_RX is 16 And replace sprintf with snprintf. Detected using the static analysis tool - Svace.",
      "id": "CVE-2024-43839",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-30T21:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:24Z"
      },
      "bom-ref": "82779dab-1255-4324-b140-a617cf4f7860",
      "description": "In the Linux kernel, the following vulnerability has been resolved: virtio_net: Fix napi_skb_cache_put warning After the commit bdacf3e34945 (\"net: Use nested-BH locking for napi_alloc_cache.\") was merged, the following warning began to appear: WARNING: CPU: 5 PID: 1 at net/core/skbuff.c:1451 napi_skb_cache_put+0x82/0x4b0 __warn+0x12f/0x340 napi_skb_cache_put+0x82/0x4b0 napi_skb_cache_put+0x82/0x4b0 report_bug+0x165/0x370 handle_bug+0x3d/0x80 exc_invalid_op+0x1a/0x50 asm_exc_invalid_op+0x1a/0x20 __free_old_xmit+0x1c8/0x510 napi_skb_cache_put+0x82/0x4b0 __free_old_xmit+0x1c8/0x510 __free_old_xmit+0x1c8/0x510 __pfx___free_old_xmit+0x10/0x10 The issue arises because virtio is assuming it's running in NAPI context even when it's not, such as in the netpoll case. To resolve this, modify virtnet_poll_tx() to only set NAPI when budget is available. Same for virtnet_poll_cleantx(), which always assumed that it was in a NAPI context.",
      "id": "CVE-2024-43835",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:26Z"
      },
      "bom-ref": "8d7de570-d719-440f-8997-f87ed7e8fdbf",
      "description": "In the Linux kernel, the following vulnerability has been resolved: xdp: fix invalid wait context of page_pool_destroy() If the driver uses a page pool, it creates a page pool with page_pool_create(). The reference count of page pool is 1 as default. A page pool will be destroyed only when a reference count reaches 0. page_pool_destroy() is used to destroy page pool, it decreases a reference count. When a page pool is destroyed, ->disconnect() is called, which is mem_allocator_disconnect(). This function internally acquires mutex_lock(). If the driver uses XDP, it registers a memory model with xdp_rxq_info_reg_mem_model(). The xdp_rxq_info_reg_mem_model() internally increases a page pool reference count if a memory model is a page pool. Now the reference count is 2. To destroy a page pool, the driver should call both page_pool_destroy() and xdp_unreg_mem_model(). The xdp_unreg_mem_model() internally calls page_pool_destroy(). Only page_pool_destroy() decreases a reference count. If a driver calls page_pool_destroy() then xdp_unreg_mem_model(), we will face an invalid wait context warning. Because xdp_unreg_mem_model() calls page_pool_destroy() with rcu_read_lock(). The page_pool_destroy() internally acquires mutex_lock(). Splat looks like: ============================= [ BUG: Invalid wait context ] 6.10.0-rc6+ #4 Tainted: G W ----------------------------- ethtool/1806 is trying to lock: ffffffff90387b90 (mem_id_lock){+.+.}-{4:4}, at: mem_allocator_disconnect+0x73/0x150 other info that might help us debug this: context-{5:5} 3 locks held by ethtool/1806: stack backtrace: CPU: 0 PID: 1806 Comm: ethtool Tainted: G W 6.10.0-rc6+ #4 f916f41f172891c800f2fed Hardware name: ASUS System Product Name/PRIME Z690-P D4, BIOS 0603 11/01/2021 Call Trace: <TASK> dump_stack_lvl+0x7e/0xc0 __lock_acquire+0x1681/0x4de0 ? _printk+0x64/0xe0 ? __pfx_mark_lock.part.0+0x10/0x10 ? __pfx___lock_acquire+0x10/0x10 lock_acquire+0x1b3/0x580 ? mem_allocator_disconnect+0x73/0x150 ? __wake_up_klogd.part.0+0x16/0xc0 ? __pfx_lock_acquire+0x10/0x10 ? dump_stack_lvl+0x91/0xc0 __mutex_lock+0x15c/0x1690 ? mem_allocator_disconnect+0x73/0x150 ? __pfx_prb_read_valid+0x10/0x10 ? mem_allocator_disconnect+0x73/0x150 ? __pfx_llist_add_batch+0x10/0x10 ? console_unlock+0x193/0x1b0 ? lockdep_hardirqs_on+0xbe/0x140 ? __pfx___mutex_lock+0x10/0x10 ? tick_nohz_tick_stopped+0x16/0x90 ? __irq_work_queue_local+0x1e5/0x330 ? irq_work_queue+0x39/0x50 ? __wake_up_klogd.part.0+0x79/0xc0 ? mem_allocator_disconnect+0x73/0x150 mem_allocator_disconnect+0x73/0x150 ? __pfx_mem_allocator_disconnect+0x10/0x10 ? mark_held_locks+0xa5/0xf0 ? rcu_is_watching+0x11/0xb0 page_pool_release+0x36e/0x6d0 page_pool_destroy+0xd7/0x440 xdp_unreg_mem_model+0x1a7/0x2a0 ? __pfx_xdp_unreg_mem_model+0x10/0x10 ? kfree+0x125/0x370 ? bnxt_free_ring.isra.0+0x2eb/0x500 ? bnxt_free_mem+0x5ac/0x2500 xdp_rxq_info_unreg+0x4a/0xd0 bnxt_free_mem+0x1356/0x2500 bnxt_close_nic+0xf0/0x3b0 ? __pfx_bnxt_close_nic+0x10/0x10 ? ethnl_parse_bit+0x2c6/0x6d0 ? __pfx___nla_validate_parse+0x10/0x10 ? __pfx_ethnl_parse_bit+0x10/0x10 bnxt_set_features+0x2a8/0x3e0 __netdev_update_features+0x4dc/0x1370 ? ethnl_parse_bitset+0x4ff/0x750 ? __pfx_ethnl_parse_bitset+0x10/0x10 ? __pfx___netdev_update_features+0x10/0x10 ? mark_held_locks+0xa5/0xf0 ? _raw_spin_unlock_irqrestore+0x42/0x70 ? __pm_runtime_resume+0x7d/0x110 ethnl_set_features+0x32d/0xa20 To fix this problem, it uses rhashtable_lookup_fast() instead of rhashtable_lookup() with rcu_read_lock(). Using xa without rcu_read_lock() here is safe. xa is freed by __xdp_mem_allocator_rcu_free() and this is called by call_rcu() of mem_xa_remove(). The mem_xa_remove() is called by page_pool_destroy() if a reference count reaches 0. The xa is already protected by the reference count mechanism well in the control plane. So removing rcu_read_lock() for page_pool_destroy() is safe.",
      "id": "CVE-2024-43834",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-30T21:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:27Z"
      },
      "bom-ref": "c1c129bc-8159-492f-8e43-f86da7944852",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/qxl: Add check for drm_cvt_mode Add check for the return value of drm_cvt_mode() and return the error if it fails in order to avoid NULL pointer dereference.",
      "id": "CVE-2024-43829",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-30T12:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:29Z"
      },
      "bom-ref": "60653ba2-bfc3-45c2-b04b-9a2b0f67ba4a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: PCI: endpoint: pci-epf-test: Make use of cached 'epc_features' in pci_epf_test_core_init() Instead of getting the epc_features from pci_epc_get_features() API, use the cached pci_epf_test::epc_features value to avoid the NULL check. Since the NULL check is already performed in pci_epf_test_bind(), having one more check in pci_epf_test_core_init() is redundant and it is not possible to hit the NULL pointer dereference. Also with commit a01e7214bef9 (\"PCI: endpoint: Remove \"core_init_notifier\" flag\"), 'epc_features' got dereferenced without the NULL check, leading to the following false positive Smatch warning: drivers/pci/endpoint/functions/pci-epf-test.c:784 pci_epf_test_core_init() error: we previously assumed 'epc_features' could be null (see line 747) Thus, remove the redundant NULL check and also use the epc_features:: {msix_capable/msi_capable} flags directly to avoid local variables. [kwilczynski: commit log]",
      "id": "CVE-2024-43824",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-03T17:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:30Z"
      },
      "bom-ref": "4f9995fd-2436-4f35-95a5-483221b57516",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: PCI: keystone: Fix NULL pointer dereference in case of DT error in ks_pcie_setup_rc_app_regs() If IORESOURCE_MEM is not provided in Device Tree due to any error, resource_list_first_type() will return NULL and pci_parse_request_of_pci_ranges() will just emit a warning. This will cause a NULL pointer dereference. Fix this bug by adding NULL return check. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
      "id": "CVE-2024-43823",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-03T17:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "S390 architecture not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b5a717e3-1898-4f16-be97-b8ae5d0e2f4d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: kvm: s390: Reject memory region operations for ucontrol VMs This change rejects the KVM_SET_USER_MEMORY_REGION and KVM_SET_USER_MEMORY_REGION2 ioctls when called on a ucontrol VM. This is necessary since ucontrol VMs have kvm->arch.gmap set to 0 and would thus result in a null pointer dereference further in. Memory management needs to be performed in userspace and using the ioctls KVM_S390_UCAS_MAP and KVM_S390_UCAS_UNMAP. Also improve s390 specific documentation for KVM_SET_USER_MEMORY_REGION and KVM_SET_USER_MEMORY_REGION2. [frankja@linux.ibm.com: commit message spelling fix, subject prefix fix]",
      "id": "CVE-2024-43819",
      "published": "2024-08-17T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-03T17:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:32Z"
      },
      "bom-ref": "e484dd34-3a0a-4610-97a8-cac2ef3559a8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to don't dirty inode for readonly filesystem syzbot reports f2fs bug as below: kernel BUG at fs/f2fs/inode.c:933! RIP: 0010:f2fs_evict_inode+0x1576/0x1590 fs/f2fs/inode.c:933 Call Trace: evict+0x2a4/0x620 fs/inode.c:664 dispose_list fs/inode.c:697 [inline] evict_inodes+0x5f8/0x690 fs/inode.c:747 generic_shutdown_super+0x9d/0x2c0 fs/super.c:675 kill_block_super+0x44/0x90 fs/super.c:1667 kill_f2fs_super+0x303/0x3b0 fs/f2fs/super.c:4894 deactivate_locked_super+0xc1/0x130 fs/super.c:484 cleanup_mnt+0x426/0x4c0 fs/namespace.c:1256 task_work_run+0x24a/0x300 kernel/task_work.c:180 ptrace_notify+0x2cd/0x380 kernel/signal.c:2399 ptrace_report_syscall include/linux/ptrace.h:411 [inline] ptrace_report_syscall_exit include/linux/ptrace.h:473 [inline] syscall_exit_work kernel/entry/common.c:251 [inline] syscall_exit_to_user_mode_prepare kernel/entry/common.c:278 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c:283 [inline] syscall_exit_to_user_mode+0x15c/0x280 kernel/entry/common.c:296 do_syscall_64+0x50/0x110 arch/x86/entry/common.c:88 entry_SYSCALL_64_after_hwframe+0x63/0x6b The root cause is: - do_sys_open - f2fs_lookup - __f2fs_find_entry - f2fs_i_depth_write - f2fs_mark_inode_dirty_sync - f2fs_dirty_inode - set_inode_flag(inode, FI_DIRTY_INODE) - umount - kill_f2fs_super - kill_block_super - generic_shutdown_super - sync_filesystem : sb is readonly, skip sync_filesystem() - evict_inodes - iput - f2fs_evict_inode - f2fs_bug_on(sbi, is_inode_flag_set(inode, FI_DIRTY_INODE)) : trigger kernel panic When we try to repair i_current_depth in readonly filesystem, let's skip dirty inode to avoid panic in later f2fs_evict_inode().",
      "id": "CVE-2024-42297",
      "published": "2024-08-17T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-30T13:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:33Z"
      },
      "bom-ref": "8d5d77a0-8515-45e8-8878-23e7fc3e5ad3",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: iptables: Fix null-ptr-deref in iptable_nat_table_init(). We had a report that iptables-restore sometimes triggered null-ptr-deref at boot time. [0] The problem is that iptable_nat_table_init() is exposed to user space before the kernel fully initialises netns. In the small race window, a user could call iptable_nat_table_init() that accesses net_generic(net, iptable_nat_net_id), which is available only after registering iptable_nat_net_ops. Let's call register_pernet_subsys() before xt_register_template(). [0]: bpfilter: Loaded bpfilter_umh pid 11702 Started bpfilter BUG: kernel NULL pointer dereference, address: 0000000000000013 PF: supervisor write access in kernel mode PF: error_code(0x0002) - not-present page PGD 0 P4D 0 PREEMPT SMP NOPTI CPU: 2 PID: 11879 Comm: iptables-restor Not tainted 6.1.92-99.174.amzn2023.x86_64 #1 Hardware name: Amazon EC2 c6i.4xlarge/, BIOS 1.0 10/16/2017 RIP: 0010:iptable_nat_table_init (net/ipv4/netfilter/iptable_nat.c:87 net/ipv4/netfilter/iptable_nat.c:121) iptable_nat Code: 10 4c 89 f6 48 89 ef e8 0b 19 bb ff 41 89 c4 85 c0 75 38 41 83 c7 01 49 83 c6 28 41 83 ff 04 75 dc 48 8b 44 24 08 48 8b 0c 24 <48> 89 08 4c 89 ef e8 a2 3b a2 cf 48 83 c4 10 44 89 e0 5b 5d 41 5c RSP: 0018:ffffbef902843cd0 EFLAGS: 00010246 RAX: 0000000000000013 RBX: ffff9f4b052caa20 RCX: ffff9f4b20988d80 RDX: 0000000000000000 RSI: 0000000000000064 RDI: ffffffffc04201c0 RBP: ffff9f4b29394000 R08: ffff9f4b07f77258 R09: ffff9f4b07f77240 R10: 0000000000000000 R11: ffff9f4b09635388 R12: 0000000000000000 R13: ffff9f4b1a3c6c00 R14: ffff9f4b20988e20 R15: 0000000000000004 FS: 00007f6284340000(0000) GS:ffff9f51fe280000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000013 CR3: 00000001d10a6005 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: <TASK> ? show_trace_log_lvl (arch/x86/kernel/dumpstack.c:259) ? show_trace_log_lvl (arch/x86/kernel/dumpstack.c:259) ? xt_find_table_lock (net/netfilter/x_tables.c:1259) ? __die_body.cold (arch/x86/kernel/dumpstack.c:478 arch/x86/kernel/dumpstack.c:420) ? page_fault_oops (arch/x86/mm/fault.c:727) ? exc_page_fault (./arch/x86/include/asm/irqflags.h:40 ./arch/x86/include/asm/irqflags.h:75 arch/x86/mm/fault.c:1470 arch/x86/mm/fault.c:1518) ? asm_exc_page_fault (./arch/x86/include/asm/idtentry.h:570) ? iptable_nat_table_init (net/ipv4/netfilter/iptable_nat.c:87 net/ipv4/netfilter/iptable_nat.c:121) iptable_nat xt_find_table_lock (net/netfilter/x_tables.c:1259) xt_request_find_table_lock (net/netfilter/x_tables.c:1287) get_info (net/ipv4/netfilter/ip_tables.c:965) ? security_capable (security/security.c:809 (discriminator 13)) ? ns_capable (kernel/capability.c:376 kernel/capability.c:397) ? do_ipt_get_ctl (net/ipv4/netfilter/ip_tables.c:1656) ? bpfilter_send_req (net/bpfilter/bpfilter_kern.c:52) bpfilter nf_getsockopt (net/netfilter/nf_sockopt.c:116) ip_getsockopt (net/ipv4/ip_sockglue.c:1827) __sys_getsockopt (net/socket.c:2327) __x64_sys_getsockopt (net/socket.c:2342 net/socket.c:2339 net/socket.c:2339) do_syscall_64 (arch/x86/entry/common.c:51 arch/x86/entry/common.c:81) entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:121) RIP: 0033:0x7f62844685ee Code: 48 8b 0d 45 28 0f 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 49 89 ca b8 37 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 0a c3 66 0f 1f 84 00 00 00 00 00 48 8b 15 09 RSP: 002b:00007ffd1f83d638 EFLAGS: 00000246 ORIG_RAX: 0000000000000037 RAX: ffffffffffffffda RBX: 00007ffd1f83d680 RCX: 00007f62844685ee RDX: 0000000000000040 RSI: 0000000000000000 RDI: 0000000000000004 RBP: 0000000000000004 R08: 00007ffd1f83d670 R09: 0000558798ffa2a0 R10: 00007ffd1f83d680 R11: 0000000000000246 R12: 00007ffd1f83e3b2 R13: 00007f6284 ---truncated---",
      "id": "CVE-2024-42270",
      "published": "2024-08-17T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-19T20:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:35Z"
      },
      "bom-ref": "1d59fa32-3328-4b24-b14b-504d1386a7d8",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: iptables: Fix potential null-ptr-deref in ip6table_nat_table_init(). ip6table_nat_table_init() accesses net->gen->ptr[ip6table_nat_net_ops.id], but the function is exposed to user space before the entry is allocated via register_pernet_subsys(). Let's call register_pernet_subsys() before xt_register_template().",
      "id": "CVE-2024-42269",
      "published": "2024-08-17T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-19T20:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:36Z"
      },
      "bom-ref": "4eecf42f-2e28-48ce-92a3-c7a957d3ea59",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix soft lockup under heavy CEQE load CEQEs are handled in interrupt handler currently. This may cause the CPU core staying in interrupt context too long and lead to soft lockup under heavy load. Handle CEQEs in BH workqueue and set an upper limit for the number of CEQE handled by a single call of work handler.",
      "id": "CVE-2024-43872",
      "published": "2024-08-21T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-03T13:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:38Z"
      },
      "bom-ref": "15343f02-e939-4522-9efc-b2d0062059b0",
      "cwes": [
        362,
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Always drain health in shutdown callback There is no point in recovery during device shutdown. if health work started need to wait for it to avoid races and NULL pointer access. Hence, drain health WQ on shutdown callback.",
      "id": "CVE-2024-43866",
      "published": "2024-08-21T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-31T16:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:39Z"
      },
      "bom-ref": "3a73493b-affc-4413-b8d9-3a0a5cbb5fc3",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915: Fix potential context UAFs gem_context_register() makes the context visible to userspace, and which point a separate thread can trigger the I915_GEM_CONTEXT_DESTROY ioctl. So we need to ensure that nothing uses the ctx ptr after this. And we need to ensure that adding the ctx to the xarray is the *last* thing that gem_context_register() does with the ctx pointer. [tursulin: Stable and fixes tags add/tidy.] (cherry picked from commit bed4b455cf5374e68879be56971c1da563bcd90c)",
      "id": "CVE-2023-52913",
      "published": "2024-08-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "2dfef273-a97d-4924-8044-349afe0c358c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fixed bug on error when unloading amdgpu Fixed bug on error when unloading amdgpu. The error message is as follows: [ 377.706202] kernel BUG at drivers/gpu/drm/drm_buddy.c:278! [ 377.706215] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI [ 377.706222] CPU: 4 PID: 8610 Comm: modprobe Tainted: G IOE 6.0.0-thomas #1 [ 377.706231] Hardware name: ASUS System Product Name/PRIME Z390-A, BIOS 2004 11/02/2021 [ 377.706238] RIP: 0010:drm_buddy_free_block+0x26/0x30 [drm_buddy] [ 377.706264] Code: 00 00 00 90 0f 1f 44 00 00 48 8b 0e 89 c8 25 00 0c 00 00 3d 00 04 00 00 75 10 48 8b 47 18 48 d3 e0 48 01 47 28 e9 fa fe ff ff <0f> 0b 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 41 54 55 48 89 f5 53 [ 377.706282] RSP: 0018:ffffad2dc4683cb8 EFLAGS: 00010287 [ 377.706289] RAX: 0000000000000000 RBX: ffff8b1743bd5138 RCX: 0000000000000000 [ 377.706297] RDX: ffff8b1743bd5160 RSI: ffff8b1743bd5c78 RDI: ffff8b16d1b25f70 [ 377.706304] RBP: ffff8b1743bd59e0 R08: 0000000000000001 R09: 0000000000000001 [ 377.706311] R10: ffff8b16c8572400 R11: ffffad2dc4683cf0 R12: ffff8b16d1b25f70 [ 377.706318] R13: ffff8b16d1b25fd0 R14: ffff8b1743bd59c0 R15: ffff8b16d1b25f70 [ 377.706325] FS: 00007fec56c72c40(0000) GS:ffff8b1836500000(0000) knlGS:0000000000000000 [ 377.706334] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 377.706340] CR2: 00007f9b88c1ba50 CR3: 0000000110450004 CR4: 00000000003706e0 [ 377.706347] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 377.706354] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 377.706361] Call Trace: [ 377.706365] <TASK> [ 377.706369] drm_buddy_free_list+0x2a/0x60 [drm_buddy] [ 377.706376] amdgpu_vram_mgr_fini+0xea/0x180 [amdgpu] [ 377.706572] amdgpu_ttm_fini+0x12e/0x1a0 [amdgpu] [ 377.706650] amdgpu_bo_fini+0x22/0x90 [amdgpu] [ 377.706727] gmc_v11_0_sw_fini+0x26/0x30 [amdgpu] [ 377.706821] amdgpu_device_fini_sw+0xa1/0x3c0 [amdgpu] [ 377.706897] amdgpu_driver_release_kms+0x12/0x30 [amdgpu] [ 377.706975] drm_dev_release+0x20/0x40 [drm] [ 377.707006] release_nodes+0x35/0xb0 [ 377.707014] devres_release_all+0x8b/0xc0 [ 377.707020] device_unbind_cleanup+0xe/0x70 [ 377.707027] device_release_driver_internal+0xee/0x160 [ 377.707033] driver_detach+0x44/0x90 [ 377.707039] bus_remove_driver+0x55/0xe0 [ 377.707045] pci_unregister_driver+0x3b/0x90 [ 377.707052] amdgpu_exit+0x11/0x6c [amdgpu] [ 377.707194] __x64_sys_delete_module+0x142/0x2b0 [ 377.707201] ? fpregs_assert_state_consistent+0x22/0x50 [ 377.707208] ? exit_to_user_mode_prepare+0x3e/0x190 [ 377.707215] do_syscall_64+0x38/0x90 [ 377.707221] entry_SYSCALL_64_after_hwframe+0x63/0xcd",
      "id": "CVE-2023-52912",
      "published": "2024-08-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T14:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:41Z"
      },
      "bom-ref": "743820ec-142d-4e05-ac91-ebf69305c18c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: Fix resource leakage in VF driver unbind resources allocated like mcam entries to support the Ntuple feature and hash tables for the tc feature are not getting freed in driver unbind. This patch fixes the issue.",
      "id": "CVE-2023-52905",
      "published": "2024-08-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-13T13:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:42Z"
      },
      "bom-ref": "f6c0c369-59c4-4c22-b800-9891d1824bf2",
      "cwes": [
        459
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/gt: Cleanup partial engine discovery failures If we abort driver initialisation in the middle of gt/engine discovery, some engines will be fully setup and some not. Those incompletely setup engines only have 'engine->release == NULL' and so will leak any of the common objects allocated. v2: - Drop the destroy_pinned_context() helper for now. It's not really worth it with just a single callsite at the moment. (Janusz)",
      "id": "CVE-2022-48893",
      "published": "2024-08-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:44Z"
      },
      "bom-ref": "61862856-b156-4e5f-80c7-91e5bb862bc8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vmwgfx: Remove rcu locks from user resources User resource lookups used rcu to avoid two extra atomics. Unfortunately the rcu paths were buggy and it was easy to make the driver crash by submitting command buffers from two different threads. Because the lookups never show up in performance profiles replace them with a regular spin lock which fixes the races in accesses to those shared resources. Fixes kernel oops'es in IGT's vmwgfx execution_buffer stress test and seen crashes with apps using shared resources.",
      "id": "CVE-2022-48887",
      "published": "2024-08-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-06T14:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_F2FS_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "879a7d87-a736-4ad3-b8d7-163d1c2b27a8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GC syzbot reports a f2fs bug as below: ------------[ cut here ]------------ kernel BUG at fs/f2fs/inline.c:258! CPU: 1 PID: 34 Comm: kworker/u8:2 Not tainted 6.9.0-rc6-syzkaller-00012-g9e4bc4bcae01 #0 RIP: 0010:f2fs_write_inline_data+0x781/0x790 fs/f2fs/inline.c:258 Call Trace: f2fs_write_single_data_page+0xb65/0x1d60 fs/f2fs/data.c:2834 f2fs_write_cache_pages fs/f2fs/data.c:3133 [inline] __f2fs_write_data_pages fs/f2fs/data.c:3288 [inline] f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3315 do_writepages+0x35b/0x870 mm/page-writeback.c:2612 __writeback_single_inode+0x165/0x10b0 fs/fs-writeback.c:1650 writeback_sb_inodes+0x905/0x1260 fs/fs-writeback.c:1941 wb_writeback+0x457/0xce0 fs/fs-writeback.c:2117 wb_do_writeback fs/fs-writeback.c:2264 [inline] wb_workfn+0x410/0x1090 fs/fs-writeback.c:2304 process_one_work kernel/workqueue.c:3254 [inline] process_scheduled_works+0xa12/0x17c0 kernel/workqueue.c:3335 worker_thread+0x86d/0xd70 kernel/workqueue.c:3416 kthread+0x2f2/0x390 kernel/kthread.c:388 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 The root cause is: inline_data inode can be fuzzed, so that there may be valid blkaddr in its direct node, once f2fs triggers background GC to migrate the block, it will hit f2fs_bug_on() during dirty page writeback. Let's add sanity check on F2FS_INLINE_DATA flag in inode during GC, so that, it can forbid migrating inline_data inode's data block for fixing.",
      "id": "CVE-2024-44942",
      "published": "2024-08-26T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-27T16:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_F2FS_FS is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "09d21402-12b0-4025-addb-d9ab059f601e",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to cover read extent cache access with lock syzbot reports a f2fs bug as below: BUG: KASAN: slab-use-after-free in sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46 Read of size 4 at addr ffff8880739ab220 by task syz-executor200/5097 CPU: 0 PID: 5097 Comm: syz-executor200 Not tainted 6.9.0-rc6-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46 do_read_inode fs/f2fs/inode.c:509 [inline] f2fs_iget+0x33e1/0x46e0 fs/f2fs/inode.c:560 f2fs_nfs_get_inode+0x74/0x100 fs/f2fs/super.c:3237 generic_fh_to_dentry+0x9f/0xf0 fs/libfs.c:1413 exportfs_decode_fh_raw+0x152/0x5f0 fs/exportfs/expfs.c:444 exportfs_decode_fh+0x3c/0x80 fs/exportfs/expfs.c:584 do_handle_to_path fs/fhandle.c:155 [inline] handle_to_path fs/fhandle.c:210 [inline] do_handle_open+0x495/0x650 fs/fhandle.c:226 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f We missed to cover sanity_check_extent_cache() w/ extent cache lock, so, below race case may happen, result in use after free issue. - f2fs_iget - do_read_inode - f2fs_init_read_extent_tree : add largest extent entry in to cache - shrink - f2fs_shrink_read_extent_tree - __shrink_extent_tree - __detach_extent_node : drop largest extent entry - sanity_check_extent_cache : access et->largest w/o lock let's refactor sanity_check_extent_cache() to avoid extent cache access and call it before f2fs_init_read_extent_tree() to fix this issue.",
      "id": "CVE-2024-44941",
      "published": "2024-08-26T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T20:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_NET_FOU is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "3428a896-6e31-45ff-82c3-9aa0316ffd23",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fou: remove warn in gue_gro_receive on unsupported protocol Drop the WARN_ON_ONCE inn gue_gro_receive if the encapsulated type is not known or does not have a GRO handler. Such a packet is easily constructed. Syzbot generates them and sets off this warning. Remove the warning as it is expected and not actionable. The warning was previously reduced from WARN_ON to WARN_ON_ONCE in commit 270136613bf7 (\"fou: Do WARN_ON_ONCE in gue_gro_receive for bad proto callbacks\").",
      "id": "CVE-2024-44940",
      "published": "2024-08-26T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:45Z"
      },
      "bom-ref": "5842868c-729f-4c8b-9282-4e2779462922",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: fix null ptr deref in dtInsertEntry [syzbot reported] general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 0 PID: 5061 Comm: syz-executor404 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024 RIP: 0010:dtInsertEntry+0xd0c/0x1780 fs/jfs/jfs_dtree.c:3713 ... [Analyze] In dtInsertEntry(), when the pointer h has the same value as p, after writing name in UniStrncpy_to_le(), p->header.flag will be cleared. This will cause the previously true judgment \"p->header.flag & BT-LEAF\" to change to no after writing the name operation, this leads to entering an incorrect branch and accessing the uninitialized object ih when judging this condition for the second time. [Fix] After got the page, check freelist first, if freelist == 0 then exit dtInsert() and return -EINVAL.",
      "id": "CVE-2024-44939",
      "published": "2024-08-26T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T20:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:47Z"
      },
      "bom-ref": "bfb09713-964a-40d0-8423-26051f0caf13",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: Fix shift-out-of-bounds in dbDiscardAG When searching for the next smaller log2 block, BLKSTOL2() returned 0, causing shift exponent -1 to be negative. This patch fixes the issue by exiting the loop directly when negative shift is found.",
      "id": "CVE-2024-44938",
      "published": "2024-08-26T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:48Z"
      },
      "bom-ref": "b57c0d2a-5c15-491a-8ab8-83d358ae02a0",
      "description": "In the Linux kernel, the following vulnerability has been resolved: gpio: prevent potential speculation leaks in gpio_device_get_desc() Userspace may trigger a speculative read of an address outside the gpio descriptor array. Users can do that by calling gpio_ioctl() with an offset out of range. Offset is copied from user and then used as an array index to get the gpio descriptor without sanitization in gpio_device_get_desc(). This change ensures that the offset is sanitized by using array_index_nospec() to mitigate any possibility of speculative information leaks. This bug was discovered and resolved using Coverity Static Analysis Security Testing (SAST) by Synopsys, Inc.",
      "id": "CVE-2024-44931",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:50Z"
      },
      "bom-ref": "b1b742e0-f400-4839-a367-afa8c25b9212",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nvme: apple: fix device reference counting Drivers must call nvme_uninit_ctrl after a successful nvme_init_ctrl. Split the allocation side out to make the error handling boundary easier to navigate. The apple driver had been doing this wrong, leaking the controller device memory on a tagset failure.",
      "id": "CVE-2024-43913",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T13:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:51Z"
      },
      "bom-ref": "e5bbccb2-7e29-4dde-80f7-b4778004f653",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: nl80211: disallow setting special AP channel widths Setting the AP channel width is meant for use with the normal 20/40/... MHz channel width progression, and switching around in S1G or narrow channels isn't supported. Disallow that.",
      "id": "CVE-2024-43912",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-05T18:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:53Z"
      },
      "bom-ref": "4b459dae-542d-4175-b35d-486a2120f43e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: fix NULL dereference at band check in starting tx ba session In MLD connection, link_data/link_conf are dynamically allocated. They don't point to vif->bss_conf. So, there will be no chanreq assigned to vif->bss_conf and then the chan will be NULL. Tweak the code to check ht_supported/vht_supported/has_he/has_eht on sta deflink. Crash log (with rtw89 version under MLO development): [ 9890.526087] BUG: kernel NULL pointer dereference, address: 0000000000000000 [ 9890.526102] #PF: supervisor read access in kernel mode [ 9890.526105] #PF: error_code(0x0000) - not-present page [ 9890.526109] PGD 0 P4D 0 [ 9890.526114] Oops: 0000 [#1] PREEMPT SMP PTI [ 9890.526119] CPU: 2 PID: 6367 Comm: kworker/u16:2 Kdump: loaded Tainted: G OE 6.9.0 #1 [ 9890.526123] Hardware name: LENOVO 2356AD1/2356AD1, BIOS G7ETB3WW (2.73 ) 11/28/2018 [ 9890.526126] Workqueue: phy2 rtw89_core_ba_work [rtw89_core] [ 9890.526203] RIP: 0010:ieee80211_start_tx_ba_session (net/mac80211/agg-tx.c:618 (discriminator 1)) mac80211 [ 9890.526279] Code: f7 e8 d5 93 3e ea 48 83 c4 28 89 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 49 8b 84 24 e0 f1 ff ff 48 8b 80 90 1b 00 00 <83> 38 03 0f 84 37 fe ff ff bb ea ff ff ff eb cc 49 8b 84 24 10 f3 All code ======== 0: f7 e8 imul %eax 2: d5 (bad) 3: 93 xchg %eax,%ebx 4: 3e ea ds (bad) 6: 48 83 c4 28 add $0x28,%rsp a: 89 d8 mov %ebx,%eax c: 5b pop %rbx d: 41 5c pop %r12 f: 41 5d pop %r13 11: 41 5e pop %r14 13: 41 5f pop %r15 15: 5d pop %rbp 16: c3 retq 17: cc int3 18: cc int3 19: cc int3 1a: cc int3 1b: 49 8b 84 24 e0 f1 ff mov -0xe20(%r12),%rax 22: ff 23: 48 8b 80 90 1b 00 00 mov 0x1b90(%rax),%rax 2a:* 83 38 03 cmpl $0x3,(%rax) <-- trapping instruction 2d: 0f 84 37 fe ff ff je 0xfffffffffffffe6a 33: bb ea ff ff ff mov $0xffffffea,%ebx 38: eb cc jmp 0x6 3a: 49 rex.WB 3b: 8b .byte 0x8b 3c: 84 24 10 test %ah,(%rax,%rdx,1) 3f: f3 repz Code starting with the faulting instruction =========================================== 0: 83 38 03 cmpl $0x3,(%rax) 3: 0f 84 37 fe ff ff je 0xfffffffffffffe40 9: bb ea ff ff ff mov $0xffffffea,%ebx e: eb cc jmp 0xffffffffffffffdc 10: 49 rex.WB 11: 8b .byte 0x8b 12: 84 24 10 test %ah,(%rax,%rdx,1) 15: f3 repz [ 9890.526285] RSP: 0018:ffffb8db09013d68 EFLAGS: 00010246 [ 9890.526291] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff9308e0d656c8 [ 9890.526295] RDX: 0000000000000000 RSI: ffffffffab99460b RDI: ffffffffab9a7685 [ 9890.526300] RBP: ffffb8db09013db8 R08: 0000000000000000 R09: 0000000000000873 [ 9890.526304] R10: ffff9308e0d64800 R11: 0000000000000002 R12: ffff9308e5ff6e70 [ 9890.526308] R13: ffff930952500e20 R14: ffff9309192a8c00 R15: 0000000000000000 [ 9890.526313] FS: 0000000000000000(0000) GS:ffff930b4e700000(0000) knlGS:0000000000000000 [ 9890.526316] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 9890.526318] CR2: 0000000000000000 CR3: 0000000391c58005 CR4: 00000000001706f0 [ 9890.526321] Call Trace: [ 9890.526324] <TASK> [ 9890.526327] ? show_regs (arch/x86/kernel/dumpstack.c:479) [ 9890.526335] ? __die (arch/x86/kernel/dumpstack.c:421 arch/x86/kernel/dumpstack.c:434) [ 9890.526340] ? page_fault_oops (arch/x86/mm/fault.c:713) [ 9890.526347] ? search_module_extables (kernel/module/main.c:3256 (discriminator ---truncated---",
      "id": "CVE-2024-43911",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:54Z"
      },
      "bom-ref": "7eb078e6-87e1-4b06-9839-4dc81bfabd33",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/admgpu: fix dereferencing null pointer context When user space sets an invalid ta type, the pointer context will be empty. So it need to check the pointer context before using it",
      "id": "CVE-2024-43906",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-27T13:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:56Z"
      },
      "bom-ref": "cf2c96fd-33d8-41c0-8d84-a8a98835cd63",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Fix the null pointer dereference for vega10_hwmgr Check return value and conduct null pointer handling to avoid null pointer dereference.",
      "id": "CVE-2024-43905",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "38b4f19f-bc97-40b9-99a8-c210f4520c03",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null checks for 'stream' and 'plane' before dereferencing This commit adds null checks for the 'stream' and 'plane' variables in the dcn30_apply_idle_power_optimizations function. These variables were previously assumed to be null at line 922, but they were used later in the code without checking if they were null. This could potentially lead to a null pointer dereference, which would cause a crash. The null checks ensure that 'stream' and 'plane' are not null before they are used, preventing potential crashes. Fixes the below static smatch checker: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:938 dcn30_apply_idle_power_optimizations() error: we previously assumed 'stream' could be null (see line 922) drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:940 dcn30_apply_idle_power_optimizations() error: we previously assumed 'plane' could be null (see line 922)",
      "id": "CVE-2024-43904",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "8a6eff77-eb42-4553-b2bf-ca430a7cf367",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix NULL pointer dereference for DTN log in DCN401 When users run the command: cat /sys/kernel/debug/dri/0/amdgpu_dm_dtn_log The following NULL pointer dereference happens: [ +0.000003] BUG: kernel NULL pointer dereference, address: NULL [ +0.000005] #PF: supervisor instruction fetch in kernel mode [ +0.000002] #PF: error_code(0x0010) - not-present page [ +0.000002] PGD 0 P4D 0 [ +0.000004] Oops: 0010 [#1] PREEMPT SMP NOPTI [ +0.000003] RIP: 0010:0x0 [ +0.000008] Code: Unable to access opcode bytes at 0xffffffffffffffd6. [...] [ +0.000002] PKRU: 55555554 [ +0.000002] Call Trace: [ +0.000002] <TASK> [ +0.000003] ? show_regs+0x65/0x70 [ +0.000006] ? __die+0x24/0x70 [ +0.000004] ? page_fault_oops+0x160/0x470 [ +0.000006] ? do_user_addr_fault+0x2b5/0x690 [ +0.000003] ? prb_read_valid+0x1c/0x30 [ +0.000005] ? exc_page_fault+0x8c/0x1a0 [ +0.000005] ? asm_exc_page_fault+0x27/0x30 [ +0.000012] dcn10_log_color_state+0xf9/0x510 [amdgpu] [ +0.000306] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000003] ? vsnprintf+0x2fb/0x600 [ +0.000009] dcn10_log_hw_state+0xfd0/0xfe0 [amdgpu] [ +0.000218] ? __mod_memcg_lruvec_state+0xe8/0x170 [ +0.000008] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000002] ? debug_smp_processor_id+0x17/0x20 [ +0.000003] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000002] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000002] ? set_ptes.isra.0+0x2b/0x90 [ +0.000004] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000002] ? _raw_spin_unlock+0x19/0x40 [ +0.000004] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000002] ? do_anonymous_page+0x337/0x700 [ +0.000004] dtn_log_read+0x82/0x120 [amdgpu] [ +0.000207] full_proxy_read+0x66/0x90 [ +0.000007] vfs_read+0xb0/0x340 [ +0.000005] ? __count_memcg_events+0x79/0xe0 [ +0.000002] ? srso_alias_return_thunk+0x5/0xfbef5 [ +0.000003] ? count_memcg_events.constprop.0+0x1e/0x40 [ +0.000003] ? handle_mm_fault+0xb2/0x370 [ +0.000003] ksys_read+0x6b/0xf0 [ +0.000004] __x64_sys_read+0x19/0x20 [ +0.000003] do_syscall_64+0x60/0x130 [ +0.000004] entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ +0.000003] RIP: 0033:0x7fdf32f147e2 [...] This error happens when the color log tries to read the gamut remap information from DCN401 which is not initialized in the dcn401_dpp_funcs which leads to a null pointer dereference. This commit addresses this issue by adding a proper guard to access the gamut_remap callback in case the specific ASIC did not implement this function.",
      "id": "CVE-2024-43901",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-27T14:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_MEDIA_TUNER_XC2028 is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "305cbf4c-8774-4b32-8abb-21ee5b6f857b",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: xc2028: avoid use-after-free in load_firmware_cb() syzkaller reported use-after-free in load_firmware_cb() [1]. The reason is because the module allocated a struct tuner in tuner_probe(), and then the module initialization failed, the struct tuner was released. A worker which created during module initialization accesses this struct tuner later, it caused use-after-free. The process is as follows: task-6504 worker_thread tuner_probe <= alloc dvb_frontend [2] ... request_firmware_nowait <= create a worker ... tuner_remove <= free dvb_frontend ... request_firmware_work_func <= the firmware is ready load_firmware_cb <= but now the dvb_frontend has been freed To fix the issue, check the dvd_frontend in load_firmware_cb(), if it is null, report a warning and just return. [1]: ================================================================== BUG: KASAN: use-after-free in load_firmware_cb+0x1310/0x17a0 Read of size 8 at addr ffff8000d7ca2308 by task kworker/2:3/6504 Call trace: load_firmware_cb+0x1310/0x17a0 request_firmware_work_func+0x128/0x220 process_one_work+0x770/0x1824 worker_thread+0x488/0xea0 kthread+0x300/0x430 ret_from_fork+0x10/0x20 Allocated by task 6504: kzalloc tuner_probe+0xb0/0x1430 i2c_device_probe+0x92c/0xaf0 really_probe+0x678/0xcd0 driver_probe_device+0x280/0x370 __device_attach_driver+0x220/0x330 bus_for_each_drv+0x134/0x1c0 __device_attach+0x1f4/0x410 device_initial_probe+0x20/0x30 bus_probe_device+0x184/0x200 device_add+0x924/0x12c0 device_register+0x24/0x30 i2c_new_device+0x4e0/0xc44 v4l2_i2c_new_subdev_board+0xbc/0x290 v4l2_i2c_new_subdev+0xc8/0x104 em28xx_v4l2_init+0x1dd0/0x3770 Freed by task 6504: kfree+0x238/0x4e4 tuner_remove+0x144/0x1c0 i2c_device_remove+0xc8/0x290 __device_release_driver+0x314/0x5fc device_release_driver+0x30/0x44 bus_remove_device+0x244/0x490 device_del+0x350/0x900 device_unregister+0x28/0xd0 i2c_unregister_device+0x174/0x1d0 v4l2_device_unregister+0x224/0x380 em28xx_v4l2_init+0x1d90/0x3770 The buggy address belongs to the object at ffff8000d7ca2000 which belongs to the cache kmalloc-2k of size 2048 The buggy address is located 776 bytes inside of 2048-byte region [ffff8000d7ca2000, ffff8000d7ca2800) The buggy address belongs to the page: page:ffff7fe00035f280 count:1 mapcount:0 mapping:ffff8000c001f000 index:0x0 flags: 0x7ff800000000100(slab) raw: 07ff800000000100 ffff7fe00049d880 0000000300000003 ffff8000c001f000 raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected Memory state around the buggy address: ffff8000d7ca2200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8000d7ca2280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb >ffff8000d7ca2300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ^ ffff8000d7ca2380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ffff8000d7ca2400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb ================================================================== [2] Actually, it is allocated for struct tuner, and dvb_frontend is inside.",
      "id": "CVE-2024-43900",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-27T14:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "7417c3a4-841f-4736-a77e-aa904c3260a4",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix null pointer deref in dcn20_resource.c Fixes a hang thats triggered when MPV is run on a DCN401 dGPU: mpv --hwdec=vaapi --vo=gpu --hwdec-codecs=all and then enabling fullscreen playback (double click on the video) The following calltrace will be seen: [ 181.843989] BUG: kernel NULL pointer dereference, address: 0000000000000000 [ 181.843997] #PF: supervisor instruction fetch in kernel mode [ 181.844003] #PF: error_code(0x0010) - not-present page [ 181.844009] PGD 0 P4D 0 [ 181.844020] Oops: 0010 [#1] PREEMPT SMP NOPTI [ 181.844028] CPU: 6 PID: 1892 Comm: gnome-shell Tainted: G W OE 6.5.0-41-generic #41~22.04.2-Ubuntu [ 181.844038] Hardware name: System manufacturer System Product Name/CROSSHAIR VI HERO, BIOS 6302 10/23/2018 [ 181.844044] RIP: 0010:0x0 [ 181.844079] Code: Unable to access opcode bytes at 0xffffffffffffffd6. [ 181.844084] RSP: 0018:ffffb593c2b8f7b0 EFLAGS: 00010246 [ 181.844093] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000004 [ 181.844099] RDX: ffffb593c2b8f804 RSI: ffffb593c2b8f7e0 RDI: ffff9e3c8e758400 [ 181.844105] RBP: ffffb593c2b8f7b8 R08: ffffb593c2b8f9c8 R09: ffffb593c2b8f96c [ 181.844110] R10: 0000000000000000 R11: 0000000000000000 R12: ffffb593c2b8f9c8 [ 181.844115] R13: 0000000000000001 R14: ffff9e3c88000000 R15: 0000000000000005 [ 181.844121] FS: 00007c6e323bb5c0(0000) GS:ffff9e3f85f80000(0000) knlGS:0000000000000000 [ 181.844128] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 181.844134] CR2: ffffffffffffffd6 CR3: 0000000140fbe000 CR4: 00000000003506e0 [ 181.844141] Call Trace: [ 181.844146] <TASK> [ 181.844153] ? show_regs+0x6d/0x80 [ 181.844167] ? __die+0x24/0x80 [ 181.844179] ? page_fault_oops+0x99/0x1b0 [ 181.844192] ? do_user_addr_fault+0x31d/0x6b0 [ 181.844204] ? exc_page_fault+0x83/0x1b0 [ 181.844216] ? asm_exc_page_fault+0x27/0x30 [ 181.844237] dcn20_get_dcc_compression_cap+0x23/0x30 [amdgpu] [ 181.845115] amdgpu_dm_plane_validate_dcc.constprop.0+0xe5/0x180 [amdgpu] [ 181.845985] amdgpu_dm_plane_fill_plane_buffer_attributes+0x300/0x580 [amdgpu] [ 181.846848] fill_dc_plane_info_and_addr+0x258/0x350 [amdgpu] [ 181.847734] fill_dc_plane_attributes+0x162/0x350 [amdgpu] [ 181.848748] dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu] [ 181.849791] ? dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu] [ 181.850840] amdgpu_dm_atomic_check+0xdfe/0x1760 [amdgpu]",
      "id": "CVE-2024-43899",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-27T14:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:57Z"
      },
      "bom-ref": "d4ca1a59-103a-4390-84d3-9a0e5379dd48",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: drop bad gso csum_start and offset in virtio_net_hdr Tighten csum_start and csum_offset checks in virtio_net_hdr_to_skb for GSO packets. The function already checks that a checksum requested with VIRTIO_NET_HDR_F_NEEDS_CSUM is in skb linear. But for GSO packets this might not hold for segs after segmentation. Syzkaller demonstrated to reach this warning in skb_checksum_help offset = skb_checksum_start_offset(skb); ret = -EINVAL; if (WARN_ON_ONCE(offset >= skb_headlen(skb))) By injecting a TSO packet: WARNING: CPU: 1 PID: 3539 at net/core/dev.c:3284 skb_checksum_help+0x3d0/0x5b0 ip_do_fragment+0x209/0x1b20 net/ipv4/ip_output.c:774 ip_finish_output_gso net/ipv4/ip_output.c:279 [inline] __ip_finish_output+0x2bd/0x4b0 net/ipv4/ip_output.c:301 iptunnel_xmit+0x50c/0x930 net/ipv4/ip_tunnel_core.c:82 ip_tunnel_xmit+0x2296/0x2c70 net/ipv4/ip_tunnel.c:813 __gre_xmit net/ipv4/ip_gre.c:469 [inline] ipgre_xmit+0x759/0xa60 net/ipv4/ip_gre.c:661 __netdev_start_xmit include/linux/netdevice.h:4850 [inline] netdev_start_xmit include/linux/netdevice.h:4864 [inline] xmit_one net/core/dev.c:3595 [inline] dev_hard_start_xmit+0x261/0x8c0 net/core/dev.c:3611 __dev_queue_xmit+0x1b97/0x3c90 net/core/dev.c:4261 packet_snd net/packet/af_packet.c:3073 [inline] The geometry of the bad input packet at tcp_gso_segment: [ 52.003050][ T8403] skb len=12202 headroom=244 headlen=12093 tailroom=0 [ 52.003050][ T8403] mac=(168,24) mac_len=24 net=(192,52) trans=244 [ 52.003050][ T8403] shinfo(txflags=0 nr_frags=1 gso(size=1552 type=3 segs=0)) [ 52.003050][ T8403] csum(0x60000c7 start=199 offset=1536 ip_summed=3 complete_sw=0 valid=0 level=0) Mitigate with stricter input validation. csum_offset: for GSO packets, deduce the correct value from gso_type. This is already done for USO. Extend it to TSO. Let UFO be: udp[46]_ufo_fragment ignores these fields and always computes the checksum in software. csum_start: finding the real offset requires parsing to the transport header. Do not add a parser, use existing segmentation parsing. Thanks to SKB_GSO_DODGY, that also catches bad packets that are hw offloaded. Again test both TSO and USO. Do not test UFO for the above reason, and do not test UDP tunnel offload. GSO packet are almost always CHECKSUM_PARTIAL. USO packets may be CHECKSUM_NONE since commit 10154dbded6d6 (\"udp: Allow GSO transmit from devices with no checksum offload\"), but then still these fields are initialized correctly in udp4_hwcsum/udp6_hwcsum_outgoing. So no need to test for ip_summed == CHECKSUM_PARTIAL first. This revises an existing fix mentioned in the Fixes tag, which broke small packets with GSO offload, as detected by kselftests.",
      "id": "CVE-2024-43897",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5b7e9593-5dfd-4c1c-be9a-aff00b589002",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Skip Recompute DSC Params if no Stream on Link [why] Encounter NULL pointer dereference uner mst + dsc setup. BUG: kernel NULL pointer dereference, address: 0000000000000008 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2 Hardware name: LENOVO 20NKS01Y00/20NKS01Y00, BIOS R12ET61W(1.31 ) 07/28/2022 RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper] Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8> RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224 RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280 RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850 R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000 R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224 FS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x171/0x4e0 ? plist_add+0xbe/0x100 ? exc_page_fault+0x7c/0x180 ? asm_exc_page_fault+0x26/0x30 ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] drm_atomic_check_only+0x5c5/0xa40 drm_mode_atomic_ioctl+0x76e/0xbc0 [how] dsc recompute should be skipped if no mode change detected on the new request. If detected, keep checking whether the stream is already on current state or not. (cherry picked from commit 8151a6c13111b465dbabe07c19f572f7cbd16fef)",
      "id": "CVE-2024-43895",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-27T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:52:59Z"
      },
      "bom-ref": "b40b1858-78e0-49f0-b9a2-1d0939cee95a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: memcg: protect concurrent access to mem_cgroup_idr Commit 73f576c04b94 (\"mm: memcontrol: fix cgroup creation failure after many small jobs\") decoupled the memcg IDs from the CSS ID space to fix the cgroup creation failures. It introduced IDR to maintain the memcg ID space. The IDR depends on external synchronization mechanisms for modifications. For the mem_cgroup_idr, the idr_alloc() and idr_replace() happen within css callback and thus are protected through cgroup_mutex from concurrent modifications. However idr_remove() for mem_cgroup_idr was not protected against concurrency and can be run concurrently for different memcgs when they hit their refcnt to zero. Fix that. We have been seeing list_lru based kernel crashes at a low frequency in our fleet for a long time. These crashes were in different part of list_lru code including list_lru_add(), list_lru_del() and reparenting code. Upon further inspection, it looked like for a given object (dentry and inode), the super_block's list_lru didn't have list_lru_one for the memcg of that object. The initial suspicions were either the object is not allocated through kmem_cache_alloc_lru() or somehow memcg_list_lru_alloc() failed to allocate list_lru_one() for a memcg but returned success. No evidence were found for these cases. Looking more deeply, we started seeing situations where valid memcg's id is not present in mem_cgroup_idr and in some cases multiple valid memcgs have same id and mem_cgroup_idr is pointing to one of them. So, the most reasonable explanation is that these situations can happen due to race between multiple idr_remove() calls or race between idr_alloc()/idr_replace() and idr_remove(). These races are causing multiple memcgs to acquire the same ID and then offlining of one of them would cleanup list_lrus on the system for all of them. Later access from other memcgs to the list_lru cause crashes due to missing list_lru_one.",
      "id": "CVE-2024-43892",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "dd5c1e5f-b973-4855-8ba2-44594b7b3cce",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null check in resource_log_pipe_topology_update [WHY] When switching from \"Extend\" to \"Second Display Only\" we sometimes call resource_get_otg_master_for_stream on a stream for the eDP, which is disconnected. This leads to a null pointer dereference. [HOW] Added a null check in dc_resource.c/resource_log_pipe_topology_update.",
      "id": "CVE-2024-43886",
      "published": "2024-08-26T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-08-27T14:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:00Z"
      },
      "bom-ref": "47ed9cfd-680e-45b2-b3b2-5a073dffeacd",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: Add error handling to pair_device() hci_conn_params_add() never checks for a NULL value and could lead to a NULL pointer dereference causing a crash. Fixed by adding error handling in the function.",
      "id": "CVE-2024-43884",
      "published": "2024-08-26T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-04T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:02Z"
      },
      "bom-ref": "c30e0e1c-c2f4-4a82-bbc2-8e7475ff44c6",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: kcm: Serialise kcm_sendmsg() for the same socket. syzkaller reported UAF in kcm_release(). [0] The scenario is 1. Thread A builds a skb with MSG_MORE and sets kcm->seq_skb. 2. Thread A resumes building skb from kcm->seq_skb but is blocked by sk_stream_wait_memory() 3. Thread B calls sendmsg() concurrently, finishes building kcm->seq_skb and puts the skb to the write queue 4. Thread A faces an error and finally frees skb that is already in the write queue 5. kcm_release() does double-free the skb in the write queue When a thread is building a MSG_MORE skb, another thread must not touch it. Let's add a per-sk mutex and serialise kcm_sendmsg(). [0]: BUG: KASAN: slab-use-after-free in __skb_unlink include/linux/skbuff.h:2366 [inline] BUG: KASAN: slab-use-after-free in __skb_dequeue include/linux/skbuff.h:2385 [inline] BUG: KASAN: slab-use-after-free in __skb_queue_purge_reason include/linux/skbuff.h:3175 [inline] BUG: KASAN: slab-use-after-free in __skb_queue_purge include/linux/skbuff.h:3181 [inline] BUG: KASAN: slab-use-after-free in kcm_release+0x170/0x4c8 net/kcm/kcmsock.c:1691 Read of size 8 at addr ffff0000ced0fc80 by task syz-executor329/6167 CPU: 1 PID: 6167 Comm: syz-executor329 Tainted: G B 6.8.0-rc5-syzkaller-g9abbc24128bc #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024 Call trace: dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c:291 show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:298 __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0xd0/0x124 lib/dump_stack.c:106 print_address_description mm/kasan/report.c:377 [inline] print_report+0x178/0x518 mm/kasan/report.c:488 kasan_report+0xd8/0x138 mm/kasan/report.c:601 __asan_report_load8_noabort+0x20/0x2c mm/kasan/report_generic.c:381 __skb_unlink include/linux/skbuff.h:2366 [inline] __skb_dequeue include/linux/skbuff.h:2385 [inline] __skb_queue_purge_reason include/linux/skbuff.h:3175 [inline] __skb_queue_purge include/linux/skbuff.h:3181 [inline] kcm_release+0x170/0x4c8 net/kcm/kcmsock.c:1691 __sock_release net/socket.c:659 [inline] sock_close+0xa4/0x1e8 net/socket.c:1421 __fput+0x30c/0x738 fs/file_table.c:376 ____fput+0x20/0x30 fs/file_table.c:404 task_work_run+0x230/0x2e0 kernel/task_work.c:180 exit_task_work include/linux/task_work.h:38 [inline] do_exit+0x618/0x1f64 kernel/exit.c:871 do_group_exit+0x194/0x22c kernel/exit.c:1020 get_signal+0x1500/0x15ec kernel/signal.c:2893 do_signal+0x23c/0x3b44 arch/arm64/kernel/signal.c:1249 do_notify_resume+0x74/0x1f4 arch/arm64/kernel/entry-common.c:148 exit_to_user_mode_prepare arch/arm64/kernel/entry-common.c:169 [inline] exit_to_user_mode arch/arm64/kernel/entry-common.c:178 [inline] el0_svc+0xac/0x168 arch/arm64/kernel/entry-common.c:713 el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:730 el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598 Allocated by task 6166: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x40/0x78 mm/kasan/common.c:68 kasan_save_alloc_info+0x70/0x84 mm/kasan/generic.c:626 unpoison_slab_object mm/kasan/common.c:314 [inline] __kasan_slab_alloc+0x74/0x8c mm/kasan/common.c:340 kasan_slab_alloc include/linux/kasan.h:201 [inline] slab_post_alloc_hook mm/slub.c:3813 [inline] slab_alloc_node mm/slub.c:3860 [inline] kmem_cache_alloc_node+0x204/0x4c0 mm/slub.c:3903 __alloc_skb+0x19c/0x3d8 net/core/skbuff.c:641 alloc_skb include/linux/skbuff.h:1296 [inline] kcm_sendmsg+0x1d3c/0x2124 net/kcm/kcmsock.c:783 sock_sendmsg_nosec net/socket.c:730 [inline] __sock_sendmsg net/socket.c:745 [inline] sock_sendmsg+0x220/0x2c0 net/socket.c:768 splice_to_socket+0x7cc/0xd58 fs/splice.c:889 do_splice_from fs/splice.c:941 [inline] direct_splice_actor+0xec/0x1d8 fs/splice.c:1164 splice_direct_to_actor+0x438/0xa0c fs/splice.c:1108 do_splice_direct_actor ---truncated---",
      "id": "CVE-2024-44946",
      "published": "2024-08-31T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-04T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "a3d4739e-38af-450b-bdcb-d9985f4473b2",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Validate TA binary size Add TA binary size validation to avoid OOB write. (cherry picked from commit c0a04e3570d72aaf090962156ad085e37c62e442)",
      "id": "CVE-2024-44977",
      "published": "2024-09-04T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-10T17:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_MPTCP is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "87e8a6f5-f82f-48f9-96a6-72b000b2852b",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: pm: avoid possible UaF when selecting endp select_local_address() and select_signal_address() both select an endpoint entry from the list inside an RCU protected section, but return a reference to it, to be read later on. If the entry is dereferenced after the RCU unlock, reading info could cause a Use-after-Free. A simple solution is to copy the required info while inside the RCU protected section to avoid any risk of UaF later. The address ID might need to be modified later to handle the ID0 case later, so a copy seems OK to deal with.",
      "id": "CVE-2024-44974",
      "published": "2024-09-04T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-12T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:03Z"
      },
      "bom-ref": "f94ee690-6e7a-46d7-a6c4-4c6172bc4feb",
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: do not clear page dirty inside extent_write_locked_range() [BUG] For subpage + zoned case, the following workload can lead to rsv data leak at unmount time: # mkfs.btrfs -f -s 4k $dev # mount $dev $mnt # fsstress -w -n 8 -d $mnt -s 1709539240 0/0: fiemap - no filename 0/1: copyrange read - no filename 0/2: write - no filename 0/3: rename - no source filename 0/4: creat f0 x:0 0 0 0/4: creat add id=0,parent=-1 0/5: writev f0[259 1 0 0 0 0] [778052,113,965] 0 0/6: ioctl(FIEMAP) f0[259 1 0 0 224 887097] [1294220,2291618343991484791,0x10000] -1 0/7: dwrite - xfsctl(XFS_IOC_DIOINFO) f0[259 1 0 0 224 887097] return 25, fallback to stat() 0/7: dwrite f0[259 1 0 0 224 887097] [696320,102400] 0 # umount $mnt The dmesg includes the following rsv leak detection warning (all call trace skipped): ------------[ cut here ]------------ WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8653 btrfs_destroy_inode+0x1e0/0x200 [btrfs] ---[ end trace 0000000000000000 ]--- ------------[ cut here ]------------ WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8654 btrfs_destroy_inode+0x1a8/0x200 [btrfs] ---[ end trace 0000000000000000 ]--- ------------[ cut here ]------------ WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8660 btrfs_destroy_inode+0x1a0/0x200 [btrfs] ---[ end trace 0000000000000000 ]--- BTRFS info (device sda): last unmount of filesystem 1b4abba9-de34-4f07-9e7f-157cf12a18d6 ------------[ cut here ]------------ WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs] ---[ end trace 0000000000000000 ]--- BTRFS info (device sda): space_info DATA has 268218368 free, is not full BTRFS info (device sda): space_info total=268435456, used=204800, pinned=0, reserved=0, may_use=12288, readonly=0 zone_unusable=0 BTRFS info (device sda): global_block_rsv: size 0 reserved 0 BTRFS info (device sda): trans_block_rsv: size 0 reserved 0 BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0 ------------[ cut here ]------------ WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs] ---[ end trace 0000000000000000 ]--- BTRFS info (device sda): space_info METADATA has 267796480 free, is not full BTRFS info (device sda): space_info total=268435456, used=131072, pinned=0, reserved=0, may_use=262144, readonly=0 zone_unusable=245760 BTRFS info (device sda): global_block_rsv: size 0 reserved 0 BTRFS info (device sda): trans_block_rsv: size 0 reserved 0 BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0 BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0 Above $dev is a tcmu-runner emulated zoned HDD, which has a max zone append size of 64K, and the system has 64K page size. [CAUSE] I have added several trace_printk() to show the events (header skipped): > btrfs_dirty_pages: r/i=5/259 dirty start=774144 len=114688 > btrfs_dirty_pages: r/i=5/259 dirty part of page=720896 off_in_page=53248 len_in_page=12288 > btrfs_dirty_pages: r/i=5/259 dirty part of page=786432 off_in_page=0 len_in_page=65536 > btrfs_dirty_pages: r/i=5/259 dirty part of page=851968 off_in_page=0 len_in_page=36864 The above lines show our buffered write has dirtied 3 pages of inode 259 of root 5: 704K 768K 832K 896K I |////I/////////////////I///////////| I 756K 868K |///| is the dirtied range using subpage bitmaps. and 'I' is the page boundary. Meanwhile all three pages (704K, 768K, 832K) have their PageDirty flag set. > btrfs_direct_write: r/i=5/259 start dio filepos=696320 len=102400 Then direct IO writ ---truncated---",
      "id": "CVE-2024-44972",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-03T16:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:05Z"
      },
      "bom-ref": "24cae157-42d5-478e-b050-a976d8f99c59",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: SHAMPO, Fix invalid WQ linked list unlink When all the strides in a WQE have been consumed, the WQE is unlinked from the WQ linked list (mlx5_wq_ll_pop()). For SHAMPO, it is possible to receive CQEs with 0 consumed strides for the same WQE even after the WQE is fully consumed and unlinked. This triggers an additional unlink for the same wqe which corrupts the linked list. Fix this scenario by accepting 0 sized consumed strides without unlinking the WQE again.",
      "id": "CVE-2024-44970",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-03T14:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:06Z"
      },
      "bom-ref": "df164b4e-d17e-45ac-8650-cfb7221b2911",
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: do not BUG_ON() when freeing tree block after error When freeing a tree block, at btrfs_free_tree_block(), if we fail to create a delayed reference we don't deal with the error and just do a BUG_ON(). The error most likely to happen is -ENOMEM, and we have a comment mentioning that only -ENOMEM can happen, but that is not true, because in case qgroups are enabled any error returned from btrfs_qgroup_trace_extent_post() (can be -EUCLEAN or anything returned from btrfs_search_slot() for example) can be propagated back to btrfs_free_tree_block(). So stop doing a BUG_ON() and return the error to the callers and make them abort the transaction to prevent leaking space. Syzbot was triggering this, likely due to memory allocation failure injection.",
      "id": "CVE-2024-44963",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T13:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:08Z"
      },
      "bom-ref": "ef9c3f04-d5bc-4d3e-a897-948601b03400",
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btnxpuart: Shutdown timer and prevent rearming when driver unloading When unload the btnxpuart driver, its associated timer will be deleted. If the timer happens to be modified at this moment, it leads to the kernel call this timer even after the driver unloaded, resulting in kernel panic. Use timer_shutdown_sync() instead of del_timer_sync() to prevent rearming. panic log: Internal error: Oops: 0000000086000007 [#1] PREEMPT SMP Modules linked in: algif_hash algif_skcipher af_alg moal(O) mlan(O) crct10dif_ce polyval_ce polyval_generic snd_soc_imx_card snd_soc_fsl_asoc_card snd_soc_imx_audmux mxc_jpeg_encdec v4l2_jpeg snd_soc_wm8962 snd_soc_fsl_micfil snd_soc_fsl_sai flexcan snd_soc_fsl_utils ap130x rpmsg_ctrl imx_pcm_dma can_dev rpmsg_char pwm_fan fuse [last unloaded: btnxpuart] CPU: 5 PID: 723 Comm: memtester Tainted: G O 6.6.23-lts-next-06207-g4aef2658ac28 #1 Hardware name: NXP i.MX95 19X19 board (DT) pstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : 0xffff80007a2cf464 lr : call_timer_fn.isra.0+0x24/0x80 ... Call trace: 0xffff80007a2cf464 __run_timers+0x234/0x280 run_timer_softirq+0x20/0x40 __do_softirq+0x100/0x26c ____do_softirq+0x10/0x1c call_on_irq_stack+0x24/0x4c do_softirq_own_stack+0x1c/0x2c irq_exit_rcu+0xc0/0xdc el0_interrupt+0x54/0xd8 __el0_irq_handler_common+0x18/0x24 el0t_64_irq_handler+0x10/0x1c el0t_64_irq+0x190/0x194 Code: ???????? ???????? ???????? ???????? (????????) ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops: Fatal exception in interrupt SMP: stopping secondary CPUs Kernel Offset: disabled CPU features: 0x0,c0000000,40028143,1000721b Memory Limit: none ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]---",
      "id": "CVE-2024-44962",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-04T16:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "7e5f58fa-a64f-4664-b762-57c298e4c2c9",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Forward soft recovery errors to userspace As we discussed before[1], soft recovery should be forwarded to userspace, or we can get into a really bad state where apps will keep submitting hanging command buffers cascading us to a hard reset. 1: https://lore.kernel.org/all/bf23d5ed-9a6b-43e7-84ee-8cbfd0d60f18@froggi.es/ (cherry picked from commit 434967aadbbbe3ad9103cc29e9a327de20fdba01)",
      "id": "CVE-2024-44961",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-04T16:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:09Z"
      },
      "bom-ref": "44718b55-1b7c-447d-a756-30971bd98db5",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: xen: privcmd: Switch from mutex to spinlock for irqfds irqfd_wakeup() gets EPOLLHUP, when it is called by eventfd_release() by way of wake_up_poll(&ctx->wqh, EPOLLHUP), which gets called under spin_lock_irqsave(). We can't use a mutex here as it will lead to a deadlock. Fix it by switching over to a spin lock.",
      "id": "CVE-2024-44957",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-06T16:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:11Z"
      },
      "bom-ref": "81ed25b5-d59f-4c5b-81aa-ff01cc63e8c3",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/preempt_fence: enlarge the fence critical section It is really easy to introduce subtle deadlocks in preempt_fence_work_func() since we operate on single global ordered-wq for signalling our preempt fences behind the scenes, so even though we signal a particular fence, everything in the callback should be in the fence critical section, since blocking in the callback will prevent other published fences from signalling. If we enlarge the fence critical section to cover the entire callback, then lockdep should be able to understand this better, and complain if we grab a sensitive lock like vm->lock, which is also held when waiting on preempt fences.",
      "id": "CVE-2024-44956",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-06T16:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:53:12Z"
      },
      "bom-ref": "d09574dd-e861-4acb-9a8c-cb4c045f689d",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "id": "CVE-2024-44955",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:14Z"
      },
      "bom-ref": "400a362f-37dc-43f6-b9cd-423cc0721f28",
      "description": "In the Linux kernel, the following vulnerability has been resolved: serial: sc16is7xx: fix invalid FIFO access with special register set When enabling access to the special register set, Receiver time-out and RHR interrupts can happen. In this case, the IRQ handler will try to read from the FIFO thru the RHR register at address 0x00, but address 0x00 is mapped to DLL register, resulting in erroneous FIFO reading. Call graph example: sc16is7xx_startup(): entry sc16is7xx_ms_proc(): entry sc16is7xx_set_termios(): entry sc16is7xx_set_baud(): DLH/DLL = $009C --> access special register set sc16is7xx_port_irq() entry --> IIR is 0x0C sc16is7xx_handle_rx() entry sc16is7xx_fifo_read(): --> unable to access FIFO (RHR) because it is mapped to DLL (LCR=LCR_CONF_MODE_A) sc16is7xx_set_baud(): exit --> Restore access to general register set Fix the problem by claiming the efr_lock mutex when accessing the Special register set.",
      "id": "CVE-2024-44950",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_PARISC is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "92f97dec-46f1-4499-9000-50823e3a45b2",
      "description": "In the Linux kernel, the following vulnerability has been resolved: parisc: fix a possible DMA corruption ARCH_DMA_MINALIGN was defined as 16 - this is too small - it may be possible that two unrelated 16-byte allocations share a cache line. If one of these allocations is written using DMA and the other is written using cached write, the value that was written with DMA may be corrupted. This commit changes ARCH_DMA_MINALIGN to be 128 on PA20 and 32 on PA1.1 - that's the largest possible cache line size. As different parisc microarchitectures have different cache line size, we define arch_slab_minalign(), cache_line_size() and dma_get_cache_alignment() so that the kernel may tune slab cache parameters dynamically, based on the detected cache line size.",
      "id": "CVE-2024-44949",
      "published": "2024-09-04T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-24T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:15Z"
      },
      "bom-ref": "1d3c32f5-eb4a-4653-bdbb-261ec5449398",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/msm/dpu: move dpu_encoder's connector assignment to atomic_enable() For cases where the crtc's connectors_changed was set without enable/active getting toggled , there is an atomic_enable() call followed by an atomic_disable() but without an atomic_mode_set(). This results in a NULL ptr access for the dpu_encoder_get_drm_fmt() call in the atomic_enable() as the dpu_encoder's connector was cleared in the atomic_disable() but not re-assigned as there was no atomic_mode_set() call. Fix the NULL ptr access by moving the assignment for atomic_enable() and also use drm_atomic_get_new_connector_for_encoder() to get the connector from the atomic_state. Patchwork: https://patchwork.freedesktop.org/patch/606729/",
      "id": "CVE-2024-45015",
      "published": "2024-09-11T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-13T16:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:17Z"
      },
      "bom-ref": "f367d621-b0c5-4cfa-9afc-7b47b17032ae",
      "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: pm: only mark 'subflow' endp as available Adding the following warning ... WARN_ON_ONCE(msk->pm.local_addr_used == 0) ... before decrementing the local_addr_used counter helped to find a bug when running the \"remove single address\" subtest from the mptcp_join.sh selftests. Removing a 'signal' endpoint will trigger the removal of all subflows linked to this endpoint via mptcp_pm_nl_rm_addr_or_subflow() with rm_type == MPTCP_MIB_RMSUBFLOW. This will decrement the local_addr_used counter, which is wrong in this case because this counter is linked to 'subflow' endpoints, and here it is a 'signal' endpoint that is being removed. Now, the counter is decremented, only if the ID is being used outside of mptcp_pm_nl_rm_addr_or_subflow(), only for 'subflow' endpoints, and if the ID is not 0 -- local_addr_used is not taking into account these ones. This marking of the ID as being available, and the decrement is done no matter if a subflow using this ID is currently available, because the subflow could have been closed before.",
      "id": "CVE-2024-45010",
      "published": "2024-09-11T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-13T16:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:18Z"
      },
      "bom-ref": "6a8855ad-4b25-4935-b983-e2260ff56c84",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe: reset mmio mappings with devm Set our various mmio mappings to NULL. This should make it easier to catch something rogue trying to mess with mmio after device removal. For example, we might unmap everything and then start hitting some mmio address which has already been unmamped by us and then remapped by something else, causing all kinds of carnage.",
      "id": "CVE-2024-46705",
      "published": "2024-09-13T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-19T13:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:53:20Z"
      },
      "bom-ref": "a2e84c7b-c280-4a6a-b23f-f0080f195434",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "id": "CVE-2024-46700",
      "published": "2024-09-13T06:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:21Z"
      },
      "bom-ref": "647955d4-5a78-4f9f-a07f-a25317372994",
      "cwes": [
        276
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: selinux,smack: don't bypass permissions check in inode_setsecctx hook Marek Gresko reports that the root user on an NFS client is able to change the security labels on files on an NFS filesystem that is exported with root squashing enabled. The end of the kerneldoc comment for __vfs_setxattr_noperm() states: * This function requires the caller to lock the inode's i_mutex before it * is executed. It also assumes that the caller will make the appropriate * permission checks. nfsd_setattr() does do permissions checking via fh_verify() and nfsd_permission(), but those don't do all the same permissions checks that are done by security_inode_setxattr() and its related LSM hooks do. Since nfsd_setattr() is the only consumer of security_inode_setsecctx(), simplest solution appears to be to replace the call to __vfs_setxattr_noperm() with a call to __vfs_setxattr_locked(). This fixes the above issue and has the added benefit of causing nfsd to recall conflicting delegations on a file when a client tries to change its security label.",
      "id": "CVE-2024-46695",
      "published": "2024-09-13T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-17T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:23Z"
      },
      "bom-ref": "dd8e2a00-210a-472a-8958-080acf6deda5",
      "description": "In the Linux kernel, the following vulnerability has been resolved: pktgen: use cpus_read_lock() in pg_net_init() I have seen the WARN_ON(smp_processor_id() != cpu) firing in pktgen_thread_worker() during tests. We must use cpus_read_lock()/cpus_read_unlock() around the for_each_online_cpu(cpu) loop. While we are at it use WARN_ON_ONCE() to avoid a possible syslog flood.",
      "id": "CVE-2024-46681",
      "published": "2024-09-13T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-19T18:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:24Z"
      },
      "bom-ref": "02213fa4-777e-485d-b7f6-31e4be2a7364",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bonding: change ipsec_lock from spin lock to mutex In the cited commit, bond->ipsec_lock is added to protect ipsec_list, hence xdo_dev_state_add and xdo_dev_state_delete are called inside this lock. As ipsec_lock is a spin lock and such xfrmdev ops may sleep, \"scheduling while atomic\" will be triggered when changing bond's active slave. [ 101.055189] BUG: scheduling while atomic: bash/902/0x00000200 [ 101.055726] Modules linked in: [ 101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1 [ 101.058760] Hardware name: [ 101.059434] Call Trace: [ 101.059436] <TASK> [ 101.060873] dump_stack_lvl+0x51/0x60 [ 101.061275] __schedule_bug+0x4e/0x60 [ 101.061682] __schedule+0x612/0x7c0 [ 101.062078] ? __mod_timer+0x25c/0x370 [ 101.062486] schedule+0x25/0xd0 [ 101.062845] schedule_timeout+0x77/0xf0 [ 101.063265] ? asm_common_interrupt+0x22/0x40 [ 101.063724] ? __bpf_trace_itimer_state+0x10/0x10 [ 101.064215] __wait_for_common+0x87/0x190 [ 101.064648] ? usleep_range_state+0x90/0x90 [ 101.065091] cmd_exec+0x437/0xb20 [mlx5_core] [ 101.065569] mlx5_cmd_do+0x1e/0x40 [mlx5_core] [ 101.066051] mlx5_cmd_exec+0x18/0x30 [mlx5_core] [ 101.066552] mlx5_crypto_create_dek_key+0xea/0x120 [mlx5_core] [ 101.067163] ? bonding_sysfs_store_option+0x4d/0x80 [bonding] [ 101.067738] ? kmalloc_trace+0x4d/0x350 [ 101.068156] mlx5_ipsec_create_sa_ctx+0x33/0x100 [mlx5_core] [ 101.068747] mlx5e_xfrm_add_state+0x47b/0xaa0 [mlx5_core] [ 101.069312] bond_change_active_slave+0x392/0x900 [bonding] [ 101.069868] bond_option_active_slave_set+0x1c2/0x240 [bonding] [ 101.070454] __bond_opt_set+0xa6/0x430 [bonding] [ 101.070935] __bond_opt_set_notify+0x2f/0x90 [bonding] [ 101.071453] bond_opt_tryset_rtnl+0x72/0xb0 [bonding] [ 101.071965] bonding_sysfs_store_option+0x4d/0x80 [bonding] [ 101.072567] kernfs_fop_write_iter+0x10c/0x1a0 [ 101.073033] vfs_write+0x2d8/0x400 [ 101.073416] ? alloc_fd+0x48/0x180 [ 101.073798] ksys_write+0x5f/0xe0 [ 101.074175] do_syscall_64+0x52/0x110 [ 101.074576] entry_SYSCALL_64_after_hwframe+0x4b/0x53 As bond_ipsec_add_sa_all and bond_ipsec_del_sa_all are only called from bond_change_active_slave, which requires holding the RTNL lock. And bond_ipsec_add_sa and bond_ipsec_del_sa are xfrm state xdo_dev_state_add and xdo_dev_state_delete APIs, which are in user context. So ipsec_lock doesn't have to be spin lock, change it to mutex, and thus the above issue can be resolved.",
      "id": "CVE-2024-46678",
      "published": "2024-09-13T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-23T14:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Architectures, x86 not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "bfafba58-ed7c-4fce-bc3b-60e4faa5d1a1",
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/tdx: Fix data leak in mmio_read() The mmio_read() function makes a TDVMCALL to retrieve MMIO data for an address from the VMM. Sean noticed that mmio_read() unintentionally exposes the value of an initialized variable (val) on the stack to the VMM. This variable is only needed as an output value. It did not need to be passed to the VMM in the first place. Do not send the original value of *val to the VMM. [ dhansen: clarify what 'val' is used for. ]",
      "id": "CVE-2024-46794",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T20:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:26Z"
      },
      "bom-ref": "94158dec-749f-488f-9a34-54e77bd1809d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: userfaultfd: fix checks for huge PMDs Patch series \"userfaultfd: fix races around pmd_trans_huge() check\", v2. The pmd_trans_huge() code in mfill_atomic() is wrong in three different ways depending on kernel version: 1. The pmd_trans_huge() check is racy and can lead to a BUG_ON() (if you hit the right two race windows) - I've tested this in a kernel build with some extra mdelay() calls. See the commit message for a description of the race scenario. On older kernels (before 6.5), I think the same bug can even theoretically lead to accessing transhuge page contents as a page table if you hit the right 5 narrow race windows (I haven't tested this case). 2. As pointed out by Qi Zheng, pmd_trans_huge() is not sufficient for detecting PMDs that don't point to page tables. On older kernels (before 6.5), you'd just have to win a single fairly wide race to hit this. I've tested this on 6.1 stable by racing migration (with a mdelay() patched into try_to_migrate()) against UFFDIO_ZEROPAGE - on my x86 VM, that causes a kernel oops in ptlock_ptr(). 3. On newer kernels (>=6.5), for shmem mappings, khugepaged is allowed to yank page tables out from under us (though I haven't tested that), so I think the BUG_ON() checks in mfill_atomic() are just wrong. I decided to write two separate fixes for these (one fix for bugs 1+2, one fix for bug 3), so that the first fix can be backported to kernels affected by bugs 1+2. This patch (of 2): This fixes two issues. I discovered that the following race can occur: mfill_atomic other thread ============ ============ <zap PMD> pmdp_get_lockless() [reads none pmd] <bail if trans_huge> <if none:> <pagefault creates transhuge zeropage> __pte_alloc [no-op] <zap PMD> <bail if pmd_trans_huge(*dst_pmd)> BUG_ON(pmd_none(*dst_pmd)) I have experimentally verified this in a kernel with extra mdelay() calls; the BUG_ON(pmd_none(*dst_pmd)) triggers. On kernels newer than commit 0d940a9b270b (\"mm/pgtable: allow pte_offset_map[_lock]() to fail\"), this can't lead to anything worse than a BUG_ON(), since the page table access helpers are actually designed to deal with page tables concurrently disappearing; but on older kernels (<=6.4), I think we could probably theoretically race past the two BUG_ON() checks and end up treating a hugepage as a page table. The second issue is that, as Qi Zheng pointed out, there are other types of huge PMDs that pmd_trans_huge() can't catch: devmap PMDs and swap PMDs (in particular, migration PMDs). On <=6.4, this is worse than the first issue: If mfill_atomic() runs on a PMD that contains a migration entry (which just requires winning a single, fairly wide race), it will pass the PMD to pte_offset_map_lock(), which assumes that the PMD points to a page table. Breakage follows: First, the kernel tries to take the PTE lock (which will crash or maybe worse if there is no \"struct page\" for the address bits in the migration entry PMD - I think at least on X86 there usually is no corresponding \"struct page\" thanks to the PTE inversion mitigation, amd64 looks different). If that didn't crash, the kernel would next try to write a PTE into what it wrongly thinks is a page table. As part of fixing these issues, get rid of the check for pmd_trans_huge() before __pte_alloc() - that's redundant, we're going to have to check for that after the __pte_alloc() anyway. Backport note: pmdp_get_lockless() is pmd_read_atomic() in older kernels.",
      "id": "CVE-2024-46787",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T15:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:27Z"
      },
      "bom-ref": "625b4143-9e9e-44dd-87b5-c2ce03407665",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: mana: Fix error handling in mana_create_txq/rxq's NAPI cleanup Currently napi_disable() gets called during rxq and txq cleanup, even before napi is enabled and hrtimer is initialized. It causes kernel panic. ? page_fault_oops+0x136/0x2b0 ? page_counter_cancel+0x2e/0x80 ? do_user_addr_fault+0x2f2/0x640 ? refill_obj_stock+0xc4/0x110 ? exc_page_fault+0x71/0x160 ? asm_exc_page_fault+0x27/0x30 ? __mmdrop+0x10/0x180 ? __mmdrop+0xec/0x180 ? hrtimer_active+0xd/0x50 hrtimer_try_to_cancel+0x2c/0xf0 hrtimer_cancel+0x15/0x30 napi_disable+0x65/0x90 mana_destroy_rxq+0x4c/0x2f0 mana_create_rxq.isra.0+0x56c/0x6d0 ? mana_uncfg_vport+0x50/0x50 mana_alloc_queues+0x21b/0x320 ? skb_dequeue+0x5f/0x80",
      "id": "CVE-2024-46784",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "50de728c-db27-4a67-bf6e-774f2418a34e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check UnboundedRequestEnabled's value CalculateSwathAndDETConfiguration_params_st's UnboundedRequestEnabled is a pointer (i.e. dml_bool_t *UnboundedRequestEnabled), and thus if (p->UnboundedRequestEnabled) checks its address, not bool value. This fixes 1 REVERSE_INULL issue reported by Coverity.",
      "id": "CVE-2024-46778",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T17:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5d176813-fc8e-4d9e-9184-6918832adc69",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Run DC_LOG_DC after checking link->link_enc [WHAT] The DC_LOG_DC should be run after link->link_enc is checked, not before. This fixes 1 REVERSE_INULL issue reported by Coverity.",
      "id": "CVE-2024-46776",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T17:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "bd56b845-5b5c-42ee-a141-7b8692ee9835",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Validate function returns [WHAT & HOW] Function return values must be checked before data can be used in subsequent functions. This fixes 4 CHECKED_RETURN issues reported by Coverity.",
      "id": "CVE-2024-46775",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T18:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as not configured in kernel since we're not using powerpc architecture",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "568741da-b8c3-4132-843a-8cbfc65bf489",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas() Smatch warns: arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potential spectre issue 'args.args' [r] (local cap) The 'nargs' and 'nret' locals come directly from a user-supplied buffer and are used as indexes into a small stack-based array and as inputs to copy_to_user() after they are subject to bounds checks. Use array_index_nospec() after the bounds checks to clamp these values for speculative execution.",
      "id": "CVE-2024-46774",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fe98b28f-39c3-42f4-9c27-71de0d79ed28",
      "cwes": [
        369
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check denominator pbn_div before used [WHAT & HOW] A denominator cannot be 0, and is checked before used. This fixes 1 DIVIDE_BY_ZERO issue reported by Coverity.",
      "id": "CVE-2024-46773",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-23T16:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "51bd41de-2c8b-4ad0-a901-46c7b88c43af",
      "cwes": [
        369
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check denominator crb_pipes before used [WHAT & HOW] A denominator cannot be 0, and is checked before used. This fixes 2 DIVIDE_BY_ZERO issues reported by Coverity.",
      "id": "CVE-2024-46772",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-07T09:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:29Z"
      },
      "bom-ref": "24f34495-9f28-4fe4-94d9-dad658430d85",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: Add netif_device_attach/detach into PF reset flow Ethtool callbacks can be executed while reset is in progress and try to access deleted resources, e.g. getting coalesce settings can result in a NULL pointer dereference seen below. Reproduction steps: Once the driver is fully initialized, trigger reset: # echo 1 > /sys/class/net/<interface>/device/reset when reset is in progress try to get coalesce settings using ethtool: # ethtool -c <interface> BUG: kernel NULL pointer dereference, address: 0000000000000020 PGD 0 P4D 0 Oops: Oops: 0000 [#1] PREEMPT SMP PTI CPU: 11 PID: 19713 Comm: ethtool Tainted: G S 6.10.0-rc7+ #7 RIP: 0010:ice_get_q_coalesce+0x2e/0xa0 [ice] RSP: 0018:ffffbab1e9bcf6a8 EFLAGS: 00010206 RAX: 000000000000000c RBX: ffff94512305b028 RCX: 0000000000000000 RDX: 0000000000000000 RSI: ffff9451c3f2e588 RDI: ffff9451c3f2e588 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: ffff9451c3f2e580 R11: 000000000000001f R12: ffff945121fa9000 R13: ffffbab1e9bcf760 R14: 0000000000000013 R15: ffffffff9e65dd40 FS: 00007faee5fbe740(0000) GS:ffff94546fd80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000020 CR3: 0000000106c2e005 CR4: 00000000001706f0 Call Trace: <TASK> ice_get_coalesce+0x17/0x30 [ice] coalesce_prepare_data+0x61/0x80 ethnl_default_doit+0xde/0x340 genl_family_rcv_msg_doit+0xf2/0x150 genl_rcv_msg+0x1b3/0x2c0 netlink_rcv_skb+0x5b/0x110 genl_rcv+0x28/0x40 netlink_unicast+0x19c/0x290 netlink_sendmsg+0x222/0x490 __sys_sendto+0x1df/0x1f0 __x64_sys_sendto+0x24/0x30 do_syscall_64+0x82/0x160 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7faee60d8e27 Calling netif_device_detach() before reset makes the net core not call the driver when ethtool command is issued, the attempt to execute an ethtool command during reset will result in the following message: netlink error: No such device instead of NULL pointer dereference. Once reset is done and ice_rebuild() is executing, the netif_device_attach() is called to allow for ethtool operations to occur again in a safe manner.",
      "id": "CVE-2024-46770",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-23T16:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:30Z"
      },
      "bom-ref": "b420f17a-dfbb-4a2d-8c10-9411183d27c2",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: protect XDP configuration with a mutex The main threat to data consistency in ice_xdp() is a possible asynchronous PF reset. It can be triggered by a user or by TX timeout handler. XDP setup and PF reset code access the same resources in the following sections: * ice_vsi_close() in ice_prepare_for_reset() - already rtnl-locked * ice_vsi_rebuild() for the PF VSI - not protected * ice_vsi_open() - already rtnl-locked With an unfortunate timing, such accesses can result in a crash such as the one below: [ +1.999878] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 14 [ +2.002992] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 18 [Mar15 18:17] ice 0000:b1:00.0 ens801f0np0: NETDEV WATCHDOG: CPU: 38: transmit queue 14 timed out 80692736 ms [ +0.000093] ice 0000:b1:00.0 ens801f0np0: tx_timeout: VSI_num: 6, Q 14, NTC: 0x0, HW_HEAD: 0x0, NTU: 0x0, INT: 0x4000001 [ +0.000012] ice 0000:b1:00.0 ens801f0np0: tx_timeout recovery level 1, txqueue 14 [ +0.394718] ice 0000:b1:00.0: PTP reset successful [ +0.006184] BUG: kernel NULL pointer dereference, address: 0000000000000098 [ +0.000045] #PF: supervisor read access in kernel mode [ +0.000023] #PF: error_code(0x0000) - not-present page [ +0.000023] PGD 0 P4D 0 [ +0.000018] Oops: 0000 [#1] PREEMPT SMP NOPTI [ +0.000023] CPU: 38 PID: 7540 Comm: kworker/38:1 Not tainted 6.8.0-rc7 #1 [ +0.000031] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021 [ +0.000036] Workqueue: ice ice_service_task [ice] [ +0.000183] RIP: 0010:ice_clean_tx_ring+0xa/0xd0 [ice] [...] [ +0.000013] Call Trace: [ +0.000016] <TASK> [ +0.000014] ? __die+0x1f/0x70 [ +0.000029] ? page_fault_oops+0x171/0x4f0 [ +0.000029] ? schedule+0x3b/0xd0 [ +0.000027] ? exc_page_fault+0x7b/0x180 [ +0.000022] ? asm_exc_page_fault+0x22/0x30 [ +0.000031] ? ice_clean_tx_ring+0xa/0xd0 [ice] [ +0.000194] ice_free_tx_ring+0xe/0x60 [ice] [ +0.000186] ice_destroy_xdp_rings+0x157/0x310 [ice] [ +0.000151] ice_vsi_decfg+0x53/0xe0 [ice] [ +0.000180] ice_vsi_rebuild+0x239/0x540 [ice] [ +0.000186] ice_vsi_rebuild_by_type+0x76/0x180 [ice] [ +0.000145] ice_rebuild+0x18c/0x840 [ice] [ +0.000145] ? delay_tsc+0x4a/0xc0 [ +0.000022] ? delay_tsc+0x92/0xc0 [ +0.000020] ice_do_reset+0x140/0x180 [ice] [ +0.000886] ice_service_task+0x404/0x1030 [ice] [ +0.000824] process_one_work+0x171/0x340 [ +0.000685] worker_thread+0x277/0x3a0 [ +0.000675] ? preempt_count_add+0x6a/0xa0 [ +0.000677] ? _raw_spin_lock_irqsave+0x23/0x50 [ +0.000679] ? __pfx_worker_thread+0x10/0x10 [ +0.000653] kthread+0xf0/0x120 [ +0.000635] ? __pfx_kthread+0x10/0x10 [ +0.000616] ret_from_fork+0x2d/0x50 [ +0.000612] ? __pfx_kthread+0x10/0x10 [ +0.000604] ret_from_fork_asm+0x1b/0x30 [ +0.000604] </TASK> The previous way of handling this through returning -EBUSY is not viable, particularly when destroying AF_XDP socket, because the kernel proceeds with removal anyway. There is plenty of code between those calls and there is no need to create a large critical section that covers all of them, same as there is no need to protect ice_vsi_rebuild() with rtnl_lock(). Add xdp_state_lock mutex to protect ice_vsi_rebuild() and ice_xdp(). Leaving unprotected sections in between would result in two states that have to be considered: 1. when the VSI is closed, but not yet rebuild 2. when VSI is already rebuild, but not yet open The latter case is actually already handled through !netif_running() case, we just need to adjust flag checking a little. The former one is not as trivial, because between ice_vsi_close() and ice_vsi_rebuild(), a lot of hardware interaction happens, this can make adding/deleting rings exit with an error. Luckily, VSI rebuild is pending and can apply new configuration for us in a managed fashion. Therefore, add an additional VSI state flag ICE_VSI_REBUILD_PENDING to indicate that ice_x ---truncated---",
      "id": "CVE-2024-46765",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-26T13:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:32Z"
      },
      "bom-ref": "33ade4db-888f-4646-a99e-92994380b617",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: xen: privcmd: Fix possible access to a freed kirqfd instance Nothing prevents simultaneous ioctl calls to privcmd_irqfd_assign() and privcmd_irqfd_deassign(). If that happens, it is possible that a kirqfd created and added to the irqfds_list by privcmd_irqfd_assign() may get removed by another thread executing privcmd_irqfd_deassign(), while the former is still using it after dropping the locks. This can lead to a situation where an already freed kirqfd instance may be accessed and cause kernel oops. Use SRCU locking to prevent the same, as is done for the KVM implementation for irqfds.",
      "id": "CVE-2024-46762",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-23T16:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:33Z"
      },
      "bom-ref": "7e9e9383-540d-4689-b0fd-1300f1f00f77",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw88: usb: schedule rx work after everything is set up Right now it's possible to hit NULL pointer dereference in rtw_rx_fill_rx_status on hw object and/or its fields because initialization routine can start getting USB replies before rtw_dev is fully setup. The stack trace looks like this: rtw_rx_fill_rx_status rtw8821c_query_rx_desc rtw_usb_rx_handler ... queue_work rtw_usb_read_port_complete ... usb_submit_urb rtw_usb_rx_resubmit rtw_usb_init_rx rtw_usb_probe So while we do the async stuff rtw_usb_probe continues and calls rtw_register_hw, which does all kinds of initialization (e.g. via ieee80211_register_hw) that rtw_rx_fill_rx_status relies on. Fix this by moving the first usb_submit_urb after everything is set up. For me, this bug manifested as: [ 8.893177] rtw_8821cu 1-1:1.2: band wrong, packet dropped [ 8.910904] rtw_8821cu 1-1:1.2: hw->conf.chandef.chan NULL in rtw_rx_fill_rx_status because I'm using Larry's backport of rtw88 driver with the NULL checks in rtw_rx_fill_rx_status.",
      "id": "CVE-2024-46760",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-23T16:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:35Z"
      },
      "bom-ref": "1ac23f10-392d-442e-bba4-46c9108e6074",
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: don't BUG_ON() when 0 reference count at btrfs_lookup_extent_info() Instead of doing a BUG_ON() handle the error by returning -EUCLEAN, aborting the transaction and logging an error message.",
      "id": "CVE-2024-46751",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:36Z"
      },
      "bom-ref": "9059a8b5-b817-4b07-8b7b-2ec32f9d7b09",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btnxpuart: Fix Null pointer dereference in btnxpuart_flush() This adds a check before freeing the rx->skb in flush and close functions to handle the kernel crash seen while removing driver after FW download fails or before FW download completes. dmesg log: [ 54.634586] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000080 [ 54.643398] Mem abort info: [ 54.646204] ESR = 0x0000000096000004 [ 54.649964] EC = 0x25: DABT (current EL), IL = 32 bits [ 54.655286] SET = 0, FnV = 0 [ 54.658348] EA = 0, S1PTW = 0 [ 54.661498] FSC = 0x04: level 0 translation fault [ 54.666391] Data abort info: [ 54.669273] ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 [ 54.674768] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [ 54.674771] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [ 54.674775] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000048860000 [ 54.674780] [0000000000000080] pgd=0000000000000000, p4d=0000000000000000 [ 54.703880] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 54.710152] Modules linked in: btnxpuart(-) overlay fsl_jr_uio caam_jr caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine authenc libdes crct10dif_ce polyval_ce polyval_generic snd_soc_imx_spdif snd_soc_imx_card snd_soc_ak5558 snd_soc_ak4458 caam secvio error snd_soc_fsl_micfil snd_soc_fsl_spdif snd_soc_fsl_sai snd_soc_fsl_utils imx_pcm_dma gpio_ir_recv rc_core sch_fq_codel fuse [ 54.744357] CPU: 3 PID: 72 Comm: kworker/u9:0 Not tainted 6.6.3-otbr-g128004619037 #2 [ 54.744364] Hardware name: FSL i.MX8MM EVK board (DT) [ 54.744368] Workqueue: hci0 hci_power_on [ 54.757244] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 54.757249] pc : kfree_skb_reason+0x18/0xb0 [ 54.772299] lr : btnxpuart_flush+0x40/0x58 [btnxpuart] [ 54.782921] sp : ffff8000805ebca0 [ 54.782923] x29: ffff8000805ebca0 x28: ffffa5c6cf1869c0 x27: ffffa5c6cf186000 [ 54.782931] x26: ffff377b84852400 x25: ffff377b848523c0 x24: ffff377b845e7230 [ 54.782938] x23: ffffa5c6ce8dbe08 x22: ffffa5c6ceb65410 x21: 00000000ffffff92 [ 54.782945] x20: ffffa5c6ce8dbe98 x19: ffffffffffffffac x18: ffffffffffffffff [ 54.807651] x17: 0000000000000000 x16: ffffa5c6ce2824ec x15: ffff8001005eb857 [ 54.821917] x14: 0000000000000000 x13: ffffa5c6cf1a02e0 x12: 0000000000000642 [ 54.821924] x11: 0000000000000040 x10: ffffa5c6cf19d690 x9 : ffffa5c6cf19d688 [ 54.821931] x8 : ffff377b86000028 x7 : 0000000000000000 x6 : 0000000000000000 [ 54.821938] x5 : ffff377b86000000 x4 : 0000000000000000 x3 : 0000000000000000 [ 54.843331] x2 : 0000000000000000 x1 : 0000000000000002 x0 : ffffffffffffffac [ 54.857599] Call trace: [ 54.857601] kfree_skb_reason+0x18/0xb0 [ 54.863878] btnxpuart_flush+0x40/0x58 [btnxpuart] [ 54.863888] hci_dev_open_sync+0x3a8/0xa04 [ 54.872773] hci_power_on+0x54/0x2e4 [ 54.881832] process_one_work+0x138/0x260 [ 54.881842] worker_thread+0x32c/0x438 [ 54.881847] kthread+0x118/0x11c [ 54.881853] ret_from_fork+0x10/0x20 [ 54.896406] Code: a9be7bfd 910003fd f9000bf3 aa0003f3 (b940d400) [ 54.896410] ---[ end trace 0000000000000000 ]---",
      "id": "CVE-2024-46749",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-20T18:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:38Z"
      },
      "bom-ref": "e1049c9c-7cf2-4c52-a5c6-68a0deedd9e4",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb/server: fix potential null-ptr-deref of lease_ctx_info in smb2_open() null-ptr-deref will occur when (req_op_level == SMB2_OPLOCK_LEVEL_LEASE) and parse_lease_state() return NULL. Fix this by check if 'lease_ctx_info' is NULL. Additionally, remove the redundant parentheses in parse_durable_handle_context().",
      "id": "CVE-2024-46742",
      "published": "2024-09-18T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1402bffa-e765-4d53-bf68-75751a6d19a6",
      "cwes": [
        191
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Ensure array index tg_inst won't be -1 [WHY & HOW] tg_inst will be a negative if timing_generator_count equals 0, which should be checked before used. This fixes 2 OVERRUN issues reported by Coverity.",
      "id": "CVE-2024-46730",
      "published": "2024-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-30T12:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b6d447d8-2bbc-468d-b708-58bfe348c0a0",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check index for aux_rd_interval before using aux_rd_interval has size of 7 and should be checked. This fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.",
      "id": "CVE-2024-46728",
      "published": "2024-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-26T13:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fc971ba2-9676-4721-a945-a5f9cbebbc52",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add otg_master NULL check within resource_log_pipe_topology_update [Why] Coverity reports NULL_RETURN warning. [How] Add otg_master NULL check.",
      "id": "CVE-2024-46727",
      "published": "2024-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-30T12:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6b661cf0-7d3c-487f-901d-41d08da0ea14",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Ensure index calculation will not overflow [WHY & HOW] Make sure vmid0p72_idx, vnom0p8_idx and vmax0p9_idx calculation will never overflow and exceess array size. This fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.",
      "id": "CVE-2024-46726",
      "published": "2024-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-20T18:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "060fb78b-1c19-4b87-999f-1695fbcb14e2",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix dereference after null check check the pointer hive before use.",
      "id": "CVE-2024-46720",
      "published": "2024-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-09-20T18:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:39Z"
      },
      "bom-ref": "2358f836-fb10-4a8a-8b56-f609083f95d4",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: driver: iio: add missing checks on iio_info's callback access Some callbacks from iio_info structure are accessed without any check, so if a driver doesn't implement them trying to access the corresponding sysfs entries produce a kernel oops such as: [ 2203.527791] Unable to handle kernel NULL pointer dereference at virtual address 00000000 when execute [...] [ 2203.783416] Call trace: [ 2203.783429] iio_read_channel_info_avail from dev_attr_show+0x18/0x48 [ 2203.789807] dev_attr_show from sysfs_kf_seq_show+0x90/0x120 [ 2203.794181] sysfs_kf_seq_show from seq_read_iter+0xd0/0x4e4 [ 2203.798555] seq_read_iter from vfs_read+0x238/0x2a0 [ 2203.802236] vfs_read from ksys_read+0xa4/0xd4 [ 2203.805385] ksys_read from ret_fast_syscall+0x0/0x54 [ 2203.809135] Exception stack(0xe0badfa8 to 0xe0badff0) [ 2203.812880] dfa0: 00000003 b6f10f80 00000003 b6eab000 00020000 00000000 [ 2203.819746] dfc0: 00000003 b6f10f80 7ff00000 00000003 00000003 00000000 00020000 00000000 [ 2203.826619] dfe0: b6e1bc88 bed80958 b6e1bc94 b6e1bcb0 [ 2203.830363] Code: bad PC value [ 2203.832695] ---[ end trace 0000000000000000 ]---",
      "id": "CVE-2024-46715",
      "published": "2024-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-08T21:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "baaf3b73-2513-4c1a-88e3-cfb20d7d749e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: added NULL check at start of dc_validate_stream [Why] prevent invalid memory access [How] check if dc and stream are NULL",
      "id": "CVE-2024-46802",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-07T14:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:41Z"
      },
      "bom-ref": "140effc8-d2f3-40f6-9260-6bc822fb085f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: Check debug trap enable before write dbg_ev_file In interrupt context, write dbg_ev_file will be run by work queue. It will cause write dbg_ev_file execution after debug_trap_disable, which will cause NULL pointer access. v2: cancel work \"debug_event_workarea\" before set dbg_ev_file as NULL.",
      "id": "CVE-2024-46803",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-04T17:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "f6a62e26-e94a-494e-83c4-203939cd18bb",
      "cwes": [
        369
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix the warning division or modulo by zero Checks the partition mode and returns an error for an invalid mode.",
      "id": "CVE-2024-46806",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-02T13:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONIG_AMD_GPU is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "025011e9-28ae-42ee-a1de-ee3398e2598c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add missing NULL pointer check within dpcd_extend_address_range [Why & How] ASSERT if return NULL from kcalloc.",
      "id": "CVE-2024-46808",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-02T14:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "7ae7159c-f711-4ad0-ac34-bf5dd4bba50c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check BIOS images before it is used BIOS images may fail to load and null checks are added before they are used. This fixes 6 NULL_RETURNS issues reported by Coverity.",
      "id": "CVE-2024-46809",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_DRM_AMDGPU is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "a1e573b7-df9d-45aa-b22d-d70cf9b8cfcd",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_box [Why] Coverity reports OVERRUN warning. soc.num_states could be 40. But array range of bw_params->clk_table.entries is 8. [How] Assert if soc.num_states greater than 8.",
      "id": "CVE-2024-46811",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-07T14:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMG_GPU not set in kernel config.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "270c0498-c82e-41f0-9caf-f5a18c6aba28",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check link_index before accessing dc->links[] [WHY & HOW] dc->links[] has max size of MAX_LINKS and NULL is return when trying to access with out-of-bound index. This fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.",
      "id": "CVE-2024-46813",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "96805878-6a59-4617-8883-c69382a61a75",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/pm: Fix negative array index read Avoid using the negative values for clk_idex as an index into an array pptable->DpmDescriptor. V2: fix clk_index return check (Tim Huang)",
      "id": "CVE-2024-46821",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:42Z"
      },
      "bom-ref": "688cb126-4372-4c15-8135-41909a9775a7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: kunit/overflow: Fix UB in overflow_allocation_test The 'device_name' array doesn't exist out of the 'overflow_allocation_test' function scope. However, it is being used as a driver name when calling 'kunit_driver_create' from 'kunit_device_register'. It produces the kernel panic with KASAN enabled. Since this variable is used in one place only, remove it and pass the device name into kunit_device_register directly as an ascii string.",
      "id": "CVE-2024-46823",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:44Z"
      },
      "bom-ref": "cc020326-f967-4ef5-b15b-8055a5eb1e8f",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ELF: fix kernel.randomize_va_space double read ELF loader uses \"randomize_va_space\" twice. It is sysctl and can change at any moment, so 2 loads could see 2 different values in theory with unpredictable consequences. Issue exactly one load for consistent value across one exec.",
      "id": "CVE-2024-46826",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T17:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ATH12K is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "f8f8ef46-f4f9-420b-827b-c39943b980e9",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix firmware crash due to invalid peer nss Currently, if the access point receives an association request containing an Extended HE Capabilities Information Element with an invalid MCS-NSS, it triggers a firmware crash. This issue arises when EHT-PHY capabilities shows support for a bandwidth and MCS-NSS set for that particular bandwidth is filled by zeros and due to this, driver obtains peer_nss as 0 and sending this value to firmware causes crash. Address this issue by implementing a validation step for the peer_nss value before passing it to the firmware. If the value is greater than zero, proceed with forwarding it to the firmware. However, if the value is invalid, reject the association request to prevent potential firmware crashes. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
      "id": "CVE-2024-46827",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T20:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_NET_VENDOR_HISILICON not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "09320015-0dbd-4cab-b402-54fcce064060",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: void array out of bound when loop tnl_num When query reg inf of SSU, it loops tnl_num times. However, tnl_num comes from hardware and the length of array is a fixed value. To void array out of bound, make sure the loop time is not greater than the length of array",
      "id": "CVE-2024-46833",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-09T15:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:45Z"
      },
      "bom-ref": "fea89270-e891-4cdf-8cbd-196b639e2c95",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ethtool: fail closed if we can't get max channel used in indirection tables Commit 0d1b7d6c9274 (\"bnxt: fix crashes when reducing ring count with active RSS contexts\") proves that allowing indirection table to contain channels with out of bounds IDs may lead to crashes. Currently the max channel check in the core gets skipped if driver can't fetch the indirection table or when we can't allocate memory. Both of those conditions should be extremely rare but if they do happen we should try to be safe and fail the channel change.",
      "id": "CVE-2024-46834",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-09T15:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e5dbd460-b05c-4a3b-9960-0d4c0d38d8c9",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: Fix smatch static checker warning adev->gfx.imu.funcs could be NULL",
      "id": "CVE-2024-46835",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-02T14:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_USB_ASPEED_UDC not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "d85adeb0-4ffc-4011-a787-30111c019b97",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: gadget: aspeed_udc: validate endpoint index for ast udc We should verify the bound of the array to assure that host may not manipulate the index to point past endpoint array. Found by static analysis.",
      "id": "CVE-2024-46836",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-09T15:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:47Z"
      },
      "bom-ref": "34a080d0-7ed4-42a0-ac93-34695b1727e4",
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: don't BUG_ON on ENOMEM from btrfs_lookup_extent_info() in walk_down_proc() We handle errors here properly, ENOMEM isn't fatal, return the error.",
      "id": "CVE-2024-46841",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:48Z"
      },
      "bom-ref": "1dbbd485-4298-47d5-916d-f95125683b40",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info The MBX_TIMEOUT return code is not handled in lpfc_get_sfp_info and the routine unconditionally frees submitted mailbox commands regardless of return status. The issue is that for MBX_TIMEOUT cases, when firmware returns SFP information at a later time, that same mailbox memory region references previously freed memory in its cmpl routine. Fix by adding checks for the MBX_TIMEOUT return code. During mailbox resource cleanup, check the mbox flag to make sure that the wait did not timeout. If the MBOX_WAKE flag is not set, then do not free the resources because it will be freed when firmware completes the mailbox at a later time in its cmpl routine. Also, increase the timeout from 30 to 60 seconds to accommodate boot scripts requiring longer timeouts.",
      "id": "CVE-2024-46842",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-08T18:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_SCSI_UFSHCD is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e9be2ce2-97ba-450c-af0a-4aa118f9505d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Remove SCSI host only if added If host tries to remove ufshcd driver from a UFS device it would cause a kernel panic if ufshcd_async_scan fails during ufshcd_probe_hba before adding a SCSI host with scsi_add_host and MCQ is enabled since SCSI host has been defered after MCQ configuration introduced by commit 0cab4023ec7b (\"scsi: ufs: core: Defer adding host to SCSI if MCQ is supported\"). To guarantee that SCSI host is removed only if it has been added, set the scsi_host_added flag to true after adding a SCSI host and check whether it is set or not before removing it.",
      "id": "CVE-2024-46843",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-08T18:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:50Z"
      },
      "bom-ref": "02636467-8fe0-4b35-a929-079d4ed6ddc6",
      "description": "In the Linux kernel, the following vulnerability has been resolved: perf/x86/intel: Limit the period on Haswell Running the ltp test cve-2015-3290 concurrently reports the following warnings. perfevents: irq loop stuck! WARNING: CPU: 31 PID: 32438 at arch/x86/events/intel/core.c:3174 intel_pmu_handle_irq+0x285/0x370 Call Trace: <NMI> ? __warn+0xa4/0x220 ? intel_pmu_handle_irq+0x285/0x370 ? __report_bug+0x123/0x130 ? intel_pmu_handle_irq+0x285/0x370 ? __report_bug+0x123/0x130 ? intel_pmu_handle_irq+0x285/0x370 ? report_bug+0x3e/0xa0 ? handle_bug+0x3c/0x70 ? exc_invalid_op+0x18/0x50 ? asm_exc_invalid_op+0x1a/0x20 ? irq_work_claim+0x1e/0x40 ? intel_pmu_handle_irq+0x285/0x370 perf_event_nmi_handler+0x3d/0x60 nmi_handle+0x104/0x330 Thanks to Thomas Gleixner's analysis, the issue is caused by the low initial period (1) of the frequency estimation algorithm, which triggers the defects of the HW, specifically erratum HSW11 and HSW143. (For the details, please refer https://lore.kernel.org/lkml/87plq9l5d2.ffs@tglx/) The HSW11 requires a period larger than 100 for the INST_RETIRED.ALL event, but the initial period in the freq mode is 1. The erratum is the same as the BDM11, which has been supported in the kernel. A minimum period of 128 is enforced as well on HSW. HSW143 is regarding that the fixed counter 1 may overcount 32 with the Hyper-Threading is enabled. However, based on the test, the hardware has more issues than it tells. Besides the fixed counter 1, the message 'interrupt took too long' can be observed on any counter which was armed with a period < 32 and two events expired in the same NMI. A minimum period of 32 is enforced for the rest of the events. The recommended workaround code of the HSW143 is not implemented. Because it only addresses the issue for the fixed counter. It brings extra overhead through extra MSR writing. No related overcounting issue has been reported so far.",
      "id": "CVE-2024-46848",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-04T15:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_ARCH_MESON not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6c55225f-5328-406b-9049-d3e00169f785",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: meson: axg-card: fix 'use-after-free' Buffer 'card->dai_link' is reallocated in 'meson_card_reallocate_links()', so move 'pad' pointer initialization after this function when memory is already reallocated. Kasan bug report: ================================================================== BUG: KASAN: slab-use-after-free in axg_card_add_link+0x76c/0x9bc Read of size 8 at addr ffff000000e8b260 by task modprobe/356 CPU: 0 PID: 356 Comm: modprobe Tainted: G O 6.9.12-sdkernel #1 Call trace: dump_backtrace+0x94/0xec show_stack+0x18/0x24 dump_stack_lvl+0x78/0x90 print_report+0xfc/0x5c0 kasan_report+0xb8/0xfc __asan_load8+0x9c/0xb8 axg_card_add_link+0x76c/0x9bc [snd_soc_meson_axg_sound_card] meson_card_probe+0x344/0x3b8 [snd_soc_meson_card_utils] platform_probe+0x8c/0xf4 really_probe+0x110/0x39c __driver_probe_device+0xb8/0x18c driver_probe_device+0x108/0x1d8 __driver_attach+0xd0/0x25c bus_for_each_dev+0xe0/0x154 driver_attach+0x34/0x44 bus_add_driver+0x134/0x294 driver_register+0xa8/0x1e8 __platform_driver_register+0x44/0x54 axg_card_pdrv_init+0x20/0x1000 [snd_soc_meson_axg_sound_card] do_one_initcall+0xdc/0x25c do_init_module+0x10c/0x334 load_module+0x24c4/0x26cc init_module_from_file+0xd4/0x128 __arm64_sys_finit_module+0x1f4/0x41c invoke_syscall+0x60/0x188 el0_svc_common.constprop.0+0x78/0x13c do_el0_svc+0x30/0x40 el0_svc+0x38/0x78 el0t_64_sync_handler+0x100/0x12c el0t_64_sync+0x190/0x194",
      "id": "CVE-2024-46849",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "state": "not_affected"
      },
      "bom-ref": "658720e7-4e71-497b-ac97-cb179dae0988",
      "cwes": [
        193
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: dma-buf: heaps: Fix off-by-one in CMA heap fault handler Until VM_DONTEXPAND was added in commit 1c1914d6e8c6 (\"dma-buf: heaps: Don't track CMA dma-buf pages under RssFile\") it was possible to obtain a mapping larger than the buffer size via mremap and bypass the overflow check in dma_buf_mmap_internal. When using such a mapping to attempt to fault past the end of the buffer, the CMA heap fault handler also checks the fault offset against the buffer size, but gets the boundary wrong by 1. Fix the boundary check so that we don't read off the end of the pages array and insert an arbitrary page in the mapping.",
      "id": "CVE-2024-46852",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SPI_NXP_FLEXSPI is not set in kernel config.",
        "justification": "code_not_present",
        "response": [
          "can_not_fix"
        ],
        "state": "not_affected"
      },
      "bom-ref": "ebc25ac0-c298-41c4-97ba-ebf1925eb7b0",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: spi: nxp-fspi: fix the KASAN report out-of-bounds bug Change the memcpy length to fix the out-of-bounds issue when writing the data that is not 4 byte aligned to TX FIFO. To reproduce the issue, write 3 bytes data to NOR chip. dd if=3b of=/dev/mtd0 [ 36.926103] ================================================================== [ 36.933409] BUG: KASAN: slab-out-of-bounds in nxp_fspi_exec_op+0x26ec/0x2838 [ 36.940514] Read of size 4 at addr ffff00081037c2a0 by task dd/455 [ 36.946721] [ 36.948235] CPU: 3 UID: 0 PID: 455 Comm: dd Not tainted 6.11.0-rc5-gc7b0e37c8434 #1070 [ 36.956185] Hardware name: Freescale i.MX8QM MEK (DT) [ 36.961260] Call trace: [ 36.963723] dump_backtrace+0x90/0xe8 [ 36.967414] show_stack+0x18/0x24 [ 36.970749] dump_stack_lvl+0x78/0x90 [ 36.974451] print_report+0x114/0x5cc [ 36.978151] kasan_report+0xa4/0xf0 [ 36.981670] __asan_report_load_n_noabort+0x1c/0x28 [ 36.986587] nxp_fspi_exec_op+0x26ec/0x2838 [ 36.990800] spi_mem_exec_op+0x8ec/0xd30 [ 36.994762] spi_mem_no_dirmap_read+0x190/0x1e0 [ 36.999323] spi_mem_dirmap_write+0x238/0x32c [ 37.003710] spi_nor_write_data+0x220/0x374 [ 37.007932] spi_nor_write+0x110/0x2e8 [ 37.011711] mtd_write_oob_std+0x154/0x1f0 [ 37.015838] mtd_write_oob+0x104/0x1d0 [ 37.019617] mtd_write+0xb8/0x12c [ 37.022953] mtdchar_write+0x224/0x47c [ 37.026732] vfs_write+0x1e4/0x8c8 [ 37.030163] ksys_write+0xec/0x1d0 [ 37.033586] __arm64_sys_write+0x6c/0x9c [ 37.037539] invoke_syscall+0x6c/0x258 [ 37.041327] el0_svc_common.constprop.0+0x160/0x22c [ 37.046244] do_el0_svc+0x44/0x5c [ 37.049589] el0_svc+0x38/0x78 [ 37.052681] el0t_64_sync_handler+0x13c/0x158 [ 37.057077] el0t_64_sync+0x190/0x194 [ 37.060775] [ 37.062274] Allocated by task 455: [ 37.065701] kasan_save_stack+0x2c/0x54 [ 37.069570] kasan_save_track+0x20/0x3c [ 37.073438] kasan_save_alloc_info+0x40/0x54 [ 37.077736] __kasan_kmalloc+0xa0/0xb8 [ 37.081515] __kmalloc_noprof+0x158/0x2f8 [ 37.085563] mtd_kmalloc_up_to+0x120/0x154 [ 37.089690] mtdchar_write+0x130/0x47c [ 37.093469] vfs_write+0x1e4/0x8c8 [ 37.096901] ksys_write+0xec/0x1d0 [ 37.100332] __arm64_sys_write+0x6c/0x9c [ 37.104287] invoke_syscall+0x6c/0x258 [ 37.108064] el0_svc_common.constprop.0+0x160/0x22c [ 37.112972] do_el0_svc+0x44/0x5c [ 37.116319] el0_svc+0x38/0x78 [ 37.119401] el0t_64_sync_handler+0x13c/0x158 [ 37.123788] el0t_64_sync+0x190/0x194 [ 37.127474] [ 37.128977] The buggy address belongs to the object at ffff00081037c2a0 [ 37.128977] which belongs to the cache kmalloc-8 of size 8 [ 37.141177] The buggy address is located 0 bytes inside of [ 37.141177] allocated 3-byte region [ffff00081037c2a0, ffff00081037c2a3) [ 37.153465] [ 37.154971] The buggy address belongs to the physical page: [ 37.160559] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x89037c [ 37.168596] flags: 0xbfffe0000000000(node=0|zone=2|lastcpupid=0x1ffff) [ 37.175149] page_type: 0xfdffffff(slab) [ 37.179021] raw: 0bfffe0000000000 ffff000800002500 dead000000000122 0000000000000000 [ 37.186788] raw: 0000000000000000 0000000080800080 00000001fdffffff 0000000000000000 [ 37.194553] page dumped because: kasan: bad access detected [ 37.200144] [ 37.201647] Memory state around the buggy address: [ 37.206460] ffff00081037c180: fa fc fc fc fa fc fc fc fa fc fc fc fa fc fc fc [ 37.213701] ffff00081037c200: fa fc fc fc 05 fc fc fc 03 fc fc fc 02 fc fc fc [ 37.220946] >ffff00081037c280: 06 fc fc fc 03 fc fc fc fc fc fc fc fc fc fc fc [ 37.228186] ^ [ 37.232473] ffff00081037c300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 37.239718] ffff00081037c380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 37.246962] ============================================================== ---truncated---",
      "id": "CVE-2024-46853",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_FSL_DPAA_ETH not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6e6b4cbf-dfce-486e-9734-e54745e32a98",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: dpaa: Pad packets to ETH_ZLEN When sending packets under 60 bytes, up to three bytes of the buffer following the data may be leaked. Avoid this by extending all packets to ETH_ZLEN, ensuring nothing is leaked in the padding. This bug can be reproduced by running $ ping -s 11 destination",
      "id": "CVE-2024-46854",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:51Z"
      },
      "bom-ref": "5478e427-6c82-48da-a275-4f6c5250e349",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nft_socket: fix sk refcount leaks We must put 'sk' reference before returning.",
      "id": "CVE-2024-46855",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-27T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:53Z"
      },
      "bom-ref": "59c235ba-91fb-4bb8-a7ab-9e49c67dc66d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: Fix bridge mode operations when there are no VFs Currently, trying to set the bridge mode attribute when numvfs=0 leads to a crash: bridge link set dev eth2 hwmode vepa [ 168.967392] BUG: kernel NULL pointer dereference, address: 0000000000000030 [...] [ 168.969989] RIP: 0010:mlx5_add_flow_rules+0x1f/0x300 [mlx5_core] [...] [ 168.976037] Call Trace: [ 168.976188] <TASK> [ 168.978620] _mlx5_eswitch_set_vepa_locked+0x113/0x230 [mlx5_core] [ 168.979074] mlx5_eswitch_set_vepa+0x7f/0xa0 [mlx5_core] [ 168.979471] rtnl_bridge_setlink+0xe9/0x1f0 [ 168.979714] rtnetlink_rcv_msg+0x159/0x400 [ 168.980451] netlink_rcv_skb+0x54/0x100 [ 168.980675] netlink_unicast+0x241/0x360 [ 168.980918] netlink_sendmsg+0x1f6/0x430 [ 168.981162] ____sys_sendmsg+0x3bb/0x3f0 [ 168.982155] ___sys_sendmsg+0x88/0xd0 [ 168.985036] __sys_sendmsg+0x59/0xa0 [ 168.985477] do_syscall_64+0x79/0x150 [ 168.987273] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 168.987773] RIP: 0033:0x7f8f7950f917 (esw->fdb_table.legacy.vepa_fdb is null) The bridge mode is only relevant when there are multiple functions per port. Therefore, prevent setting and getting this setting when there are no VFs. Note that after this change, there are no settings to change on the PF interface using `bridge link` when there are no VFs, so the interface no longer appears in the `bridge link` output.",
      "id": "CVE-2024-46857",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-01T17:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_MPTCP is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "971139f9-a564-4d56-a0c1-7fcadfb30ce0",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: pm: Fix uaf in __timer_delete_sync There are two paths to access mptcp_pm_del_add_timer, result in a race condition: CPU1 CPU2 ==== ==== net_rx_action napi_poll netlink_sendmsg __napi_poll netlink_unicast process_backlog netlink_unicast_kernel __netif_receive_skb genl_rcv __netif_receive_skb_one_core netlink_rcv_skb NF_HOOK genl_rcv_msg ip_local_deliver_finish genl_family_rcv_msg ip_protocol_deliver_rcu genl_family_rcv_msg_doit tcp_v4_rcv mptcp_pm_nl_flush_addrs_doit tcp_v4_do_rcv mptcp_nl_remove_addrs_list tcp_rcv_established mptcp_pm_remove_addrs_and_subflows tcp_data_queue remove_anno_list_by_saddr mptcp_incoming_options mptcp_pm_del_add_timer mptcp_pm_del_add_timer kfree(entry) In remove_anno_list_by_saddr(running on CPU2), after leaving the critical zone protected by \"pm.lock\", the entry will be released, which leads to the occurrence of uaf in the mptcp_pm_del_add_timer(running on CPU1). Keeping a reference to add_timer inside the lock, and calling sk_stop_timer_sync() with this reference, instead of \"entry->add_timer\". Move list_del(&entry->list) to mptcp_pm_del_add_timer and inside the pm lock, do not directly access any members of the entry outside the pm lock, which can avoid similar \"entry->x\" uaf.",
      "id": "CVE-2024-46858",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-27T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as the issue is specific to x86 and panasonic laptops",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "6099e590-297b-40ed-90cf-62d5115938f1",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: panasonic-laptop: Fix SINF array out of bounds accesses The panasonic laptop code in various places uses the SINF array with index values of 0 - SINF_CUR_BRIGHT(0x0d) without checking that the SINF array is big enough. Not all panasonic laptops have this many SINF array entries, for example the Toughbook CF-18 model only has 10 SINF array entries. So it only supports the AC+DC brightness entries and mute. Check that the SINF array has a minimum size which covers all AC+DC brightness entries and refuse to load if the SINF array is smaller. For higher SINF indexes hide the sysfs attributes when the SINF array does not contain an entry for that attribute, avoiding show()/store() accessing the array out of bounds and add bounds checking to the probe() and resume() code accessing these.",
      "id": "CVE-2024-46859",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-17T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:54Z"
      },
      "bom-ref": "c0f8eeed-1bd5-4d2e-b9d8-908064e1b4c1",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7921: fix NULL pointer access in mt7921_ipv6_addr_change When disabling wifi mt7921_ipv6_addr_change() is called as a notifier. At this point mvif->phy is already NULL so we cannot use it here.",
      "id": "CVE-2024-46860",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-02T14:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:56Z"
      },
      "bom-ref": "6ea83bab-38ec-4053-a89a-a43f7e654697",
      "description": "In the Linux kernel, the following vulnerability has been resolved: usbnet: ipheth: do not stop RX on failing RX callback RX callbacks can fail for multiple reasons: * Payload too short * Payload formatted incorrecly (e.g. bad NCM framing) * Lack of memory None of these should cause the driver to seize up. Make such failures non-critical and continue processing further incoming URBs.",
      "id": "CVE-2024-46861",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-03T15:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:57Z"
      },
      "bom-ref": "3664555e-6efb-4dd3-a290-a278809a23e1",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: soc-acpi-intel-lnl-match: add missing empty item There is no links_num in struct snd_soc_acpi_mach {}, and we test !link->num_adr as a condition to end the loop in hda_sdw_machine_select(). So an empty item in struct snd_soc_acpi_link_adr array is required.",
      "id": "CVE-2024-46863",
      "published": "2024-09-27T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-03T15:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b4174839-0799-416b-99ab-6fe144a4d773",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Disable DMCUB timeout for DCN35 [Why] DMCUB can intermittently take longer than expected to process commands. Old ASIC policy was to continue while logging a diagnostic error - which works fine for ASIC without IPS, but with IPS this could lead to a race condition where we attempt to access DCN state while it's inaccessible, leading to a system hang when the NIU port is not disabled or register accesses that timeout and the display configuration in an undefined state. [How] We need to investigate why these accesses take longer than expected, but for now we should disable the timeout on DCN35 to avoid this race condition. Since the waits happen only at lower interrupt levels the risk of taking too long at higher IRQ and causing a system watchdog timeout are minimal.",
      "id": "CVE-2024-46870",
      "published": "2024-10-09T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T14:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "331b332b-0450-4e35-afd7-cfd36e4836c7",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Correct the defined value for AMDGPU_DMUB_NOTIFICATION_MAX [Why & How] It actually exposes '6' types in enum dmub_notification_type. Not 5. Using smaller number to create array dmub_callback & dmub_thread_offload has potential to access item out of array bound. Fix it.",
      "id": "CVE-2024-46871",
      "published": "2024-10-09T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:53:59Z"
      },
      "bom-ref": "bc51006b-2e4b-4d53-bad4-c3d2fb890464",
      "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: stm32/cryp - call finalize with bh disabled The finalize operation in interrupt mode produce a produces a spinlock recursion warning. The reason is the fact that BH must be disabled during this process.",
      "id": "CVE-2024-47658",
      "published": "2024-10-09T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T16:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c60da752-145c-47c6-9cc4-20f78ea67ff7",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Avoid overflow from uint32_t to uint8_t [WHAT & HOW] dmub_rb_cmd's ramping_boundary has size of uint8_t and it is assigned 0xFFFF. Fix it by changing it to uint8_t with value of 0xFF. This fixes 2 INTEGER_OVERFLOW issues reported by Coverity.",
      "id": "CVE-2024-47661",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-15T16:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fdce1dc6-98c7-4825-b5a3-fe31eaf0fc61",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Remove register from DCN35 DMCUB diagnostic collection [Why] These registers should not be read from driver and triggering the security violation when DMCUB work times out and diagnostics are collected blocks Z8 entry. [How] Remove the register read from DCN35.",
      "id": "CVE-2024-47662",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T16:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:00Z"
      },
      "bom-ref": "1c466891-99ec-47ca-a4e5-8c6973730262",
      "cwes": [
        369
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: spi: hisi-kunpeng: Add verification for the max_frequency provided by the firmware If the value of max_speed_hz is 0, it may cause a division by zero error in hisi_calc_effective_speed(). The value of max_speed_hz is provided by firmware. Firmware is generally considered as a trusted domain. However, as division by zero errors can cause system failure, for defense measure, the value of max_speed is validated here. So 0 is regarded as invalid and an error code is returned.",
      "id": "CVE-2024-47664",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T16:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:02Z"
      },
      "bom-ref": "b0b2d14d-3602-4026-8454-64be87a6d641",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: pm80xx: Set phy->enable_completion only when we wait for it pm8001_phy_control() populates the enable_completion pointer with a stack address, sends a PHY_LINK_RESET / PHY_HARD_RESET, waits 300 ms, and returns. The problem arises when a phy control response comes late. After 300 ms the pm8001_phy_control() function returns and the passed enable_completion stack address is no longer valid. Late phy control response invokes complete() on a dangling enable_completion pointer which leads to a kernel crash.",
      "id": "CVE-2024-47666",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T16:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "50952f7c-46b9-4b41-a010-5e52ee41d939",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: add bounds checking to ocfs2_xattr_find_entry() Add a paranoia check to make sure it doesn't stray beyond valid memory region containing ocfs2 xattr entries when scanning for a match. It will prevent out-of-bound access in case of crafted images.",
      "id": "CVE-2024-47670",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:03Z"
      },
      "bom-ref": "79f66c60-a796-4d62-8a8e-a1de19918d99",
      "description": "In the Linux kernel, the following vulnerability has been resolved: USB: usbtmc: prevent kernel-usb-infoleak The syzbot reported a kernel-usb-infoleak in usbtmc_write, we need to clear the structure before filling fields.",
      "id": "CVE-2024-47671",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:05Z"
      },
      "bom-ref": "ac574fba-57d5-4e1b-b8e5-51b4cb358b72",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: don't wait for tx queues if firmware is dead There is a WARNING in iwl_trans_wait_tx_queues_empty() (that was recently converted from just a message), that can be hit if we wait for TX queues to become empty after firmware died. Clearly, we can't expect anything from the firmware after it's declared dead. Don't call iwl_trans_wait_tx_queues_empty() in this case. While it could be a good idea to stop the flow earlier, the flush functions do some maintenance work that is not related to the firmware, so keep that part of the code running even when the firmware is not running. [edit commit message]",
      "id": "CVE-2024-47672",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:06Z"
      },
      "bom-ref": "70b47816-27d1-44e2-a5fd-0dab5af811d6",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: pause TCM when the firmware is stopped Not doing so will make us send a host command to the transport while the firmware is not alive, which will trigger a WARNING. bad state = 0 WARNING: CPU: 2 PID: 17434 at drivers/net/wireless/intel/iwlwifi/iwl-trans.c:115 iwl_trans_send_cmd+0x1cb/0x1e0 [iwlwifi] RIP: 0010:iwl_trans_send_cmd+0x1cb/0x1e0 [iwlwifi] Call Trace: <TASK> iwl_mvm_send_cmd+0x40/0xc0 [iwlmvm] iwl_mvm_config_scan+0x198/0x260 [iwlmvm] iwl_mvm_recalc_tcm+0x730/0x11d0 [iwlmvm] iwl_mvm_tcm_work+0x1d/0x30 [iwlmvm] process_one_work+0x29e/0x640 worker_thread+0x2df/0x690 ? rescuer_thread+0x540/0x540 kthread+0x192/0x1e0 ? set_kthread_struct+0x90/0x90 ret_from_fork+0x22/0x30",
      "id": "CVE-2024-47673",
      "published": "2024-10-09T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T20:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "10f5d2eb-4c17-4604-9bf2-406fba1c58fc",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Prevent tail call between progs attached to different hooks bpf progs can be attached to kernel functions, and the attached functions can take different parameters or return different return values. If prog attached to one kernel function tail calls prog attached to another kernel function, the ctx access or return value verification could be bypassed. For example, if prog1 is attached to func1 which takes only 1 parameter and prog2 is attached to func2 which takes two parameters. Since verifier assumes the bpf ctx passed to prog2 is constructed based on func2's prototype, verifier allows prog2 to access the second parameter from the bpf ctx passed to it. The problem is that verifier does not prevent prog1 from passing its bpf ctx to prog2 via tail call. In this case, the bpf ctx passed to prog2 is constructed from func1 instead of func2, that is, the assumption for ctx access verification is bypassed. Another example, if BPF LSM prog1 is attached to hook file_alloc_security, and BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifier knows the return value rules for these two hooks, e.g. it is legal for bpf_lsm_audit_rule_known to return positive number 1, and it is illegal for file_alloc_security to return positive number. So verifier allows prog2 to return positive number 1, but does not allow prog1 to return positive number. The problem is that verifier does not prevent prog1 from calling prog2 via tail call. In this case, prog2's return value 1 will be used as the return value for prog1's hook file_alloc_security. That is, the return value rule is bypassed. This patch adds restriction for tail call to prevent such bypasses.",
      "id": "CVE-2024-50063",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-25T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CDNS_I3C_MASTER not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "0cbbb85f-e050-4fe4-9603-61f3f149da87",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: i3c: master: cdns: Fix use after free vulnerability in cdns_i3c_master Driver Due to Race Condition In the cdns_i3c_master_probe function, &master->hj_work is bound with cdns_i3c_master_hj. And cdns_i3c_master_interrupt can call cnds_i3c_master_demux_ibis function to start the work. If we remove the module which will call cdns_i3c_master_remove to make cleanup, it will free master->base through i3c_master_unregister while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | cdns_i3c_master_hj cdns_i3c_master_remove | i3c_master_unregister(&master->base) | device_unregister(&master->dev) | device_release | //free master->base | | i3c_master_do_daa(&master->base) | //use master->base Fix it by ensuring that the work is canceled before proceeding with the cleanup in cdns_i3c_master_remove.",
      "id": "CVE-2024-50061",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-21T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:08Z"
      },
      "bom-ref": "de61f035-1815-44db-97a7-bff6a50685d7",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: serial: protect uart_port_dtr_rts() in uart_shutdown() too Commit af224ca2df29 (serial: core: Prevent unsafe uart port access, part 3) added few uport == NULL checks. It added one to uart_shutdown(), so the commit assumes, uport can be NULL in there. But right after that protection, there is an unprotected \"uart_port_dtr_rts(uport, false);\" call. That is invoked only if HUPCL is set, so I assume that is the reason why we do not see lots of these reports. Or it cannot be NULL at this point at all for some reason :P. Until the above is investigated, stay on the safe side and move this dereference to the if too. I got this inconsistency from Coverity under CID 1585130. Thanks.",
      "id": "CVE-2024-50058",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_TYPEC_TPS6598X not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "a9c44a99-63d0-47f6-9167-dc7d6defac07",
      "cwes": [
        763
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: tipd: Free IRQ only if it was requested before In polling mode, if no IRQ was requested there is no need to free it. Call devm_free_irq() only if client->irq is set. This fixes the warning caused by the tps6598x module removal: WARNING: CPU: 2 PID: 333 at kernel/irq/devres.c:144 devm_free_irq+0x80/0x8c ... ... Call trace: devm_free_irq+0x80/0x8c tps6598x_remove+0x28/0x88 [tps6598x] i2c_device_remove+0x2c/0x9c device_remove+0x4c/0x80 device_release_driver_internal+0x1cc/0x228 driver_detach+0x50/0x98 bus_remove_driver+0x6c/0xbc driver_unregister+0x30/0x60 i2c_del_driver+0x54/0x64 tps6598x_i2c_driver_exit+0x18/0xc3c [tps6598x] __arm64_sys_delete_module+0x184/0x264 invoke_syscall+0x48/0x110 el0_svc_common.constprop.0+0xc8/0xe8 do_el0_svc+0x20/0x2c el0_svc+0x28/0x98 el0t_64_sync_handler+0x13c/0x158 el0t_64_sync+0x190/0x194",
      "id": "CVE-2024-50057",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T16:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:54:06Z"
      },
      "bom-ref": "3afacaac-b92b-4186-8f42-fb81e5a2bbbd",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: driver core: bus: Fix double free in driver API bus_register() For bus_register(), any error which happens after kset_register() will cause that @priv are freed twice, fixed by setting @priv with NULL after the first free.",
      "id": "CVE-2024-50055",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:09Z"
      },
      "bom-ref": "a5247f08-1112-4b15-b8d8-942571b8907b",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fbcon: Fix a NULL pointer dereference issue in fbcon_putcs syzbot has found a NULL pointer dereference bug in fbcon. Here is the simplified C reproducer: struct param { uint8_t type; struct tiocl_selection ts; }; int main() { struct fb_con2fbmap con2fb; struct param param; int fd = open(\"/dev/fb1\", 0, 0); con2fb.console = 0x19; con2fb.framebuffer = 0; ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb); param.type = 2; param.ts.xs = 0; param.ts.ys = 0; param.ts.xe = 0; param.ts.ye = 0; param.ts.sel_mode = 0; int fd1 = open(\"/dev/tty1\", O_RDWR, 0); ioctl(fd1, TIOCLINUX, &param); con2fb.console = 1; con2fb.framebuffer = 0; ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb); return 0; } After calling ioctl(fd1, TIOCLINUX, &param), the subsequent ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb) causes the kernel to follow a different execution path: set_con2fb_map -> con2fb_init_display -> fbcon_set_disp -> redraw_screen -> hide_cursor -> clear_selection -> highlight -> invert_screen -> do_update_region -> fbcon_putcs -> ops->putcs Since ops->putcs is a NULL pointer, this leads to a kernel panic. To prevent this, we need to call set_blitting_type() within set_con2fb_map() to properly initialize ops->putcs.",
      "id": "CVE-2024-50048",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T21:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fb411d87-0805-4c10-b45b-0da60b1caced",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix UAF in async decryption Doing an async decryption (large read) crashes with a slab-use-after-free way down in the crypto API. Reproducer: # mount.cifs -o ...,seal,esize=1 //srv/share /mnt # dd if=/mnt/largefile of=/dev/null ... [ 194.196391] ================================================================== [ 194.196844] BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xc1/0x110 [ 194.197269] Read of size 8 at addr ffff888112bd0448 by task kworker/u77:2/899 [ 194.197707] [ 194.197818] CPU: 12 UID: 0 PID: 899 Comm: kworker/u77:2 Not tainted 6.11.0-lku-00028-gfca3ca14a17a-dirty #43 [ 194.198400] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014 [ 194.199046] Workqueue: smb3decryptd smb2_decrypt_offload [cifs] [ 194.200032] Call Trace: [ 194.200191] <TASK> [ 194.200327] dump_stack_lvl+0x4e/0x70 [ 194.200558] ? gf128mul_4k_lle+0xc1/0x110 [ 194.200809] print_report+0x174/0x505 [ 194.201040] ? __pfx__raw_spin_lock_irqsave+0x10/0x10 [ 194.201352] ? srso_return_thunk+0x5/0x5f [ 194.201604] ? __virt_addr_valid+0xdf/0x1c0 [ 194.201868] ? gf128mul_4k_lle+0xc1/0x110 [ 194.202128] kasan_report+0xc8/0x150 [ 194.202361] ? gf128mul_4k_lle+0xc1/0x110 [ 194.202616] gf128mul_4k_lle+0xc1/0x110 [ 194.202863] ghash_update+0x184/0x210 [ 194.203103] shash_ahash_update+0x184/0x2a0 [ 194.203377] ? __pfx_shash_ahash_update+0x10/0x10 [ 194.203651] ? srso_return_thunk+0x5/0x5f [ 194.203877] ? crypto_gcm_init_common+0x1ba/0x340 [ 194.204142] gcm_hash_assoc_remain_continue+0x10a/0x140 [ 194.204434] crypt_message+0xec1/0x10a0 [cifs] [ 194.206489] ? __pfx_crypt_message+0x10/0x10 [cifs] [ 194.208507] ? srso_return_thunk+0x5/0x5f [ 194.209205] ? srso_return_thunk+0x5/0x5f [ 194.209925] ? srso_return_thunk+0x5/0x5f [ 194.210443] ? srso_return_thunk+0x5/0x5f [ 194.211037] decrypt_raw_data+0x15f/0x250 [cifs] [ 194.212906] ? __pfx_decrypt_raw_data+0x10/0x10 [cifs] [ 194.214670] ? srso_return_thunk+0x5/0x5f [ 194.215193] smb2_decrypt_offload+0x12a/0x6c0 [cifs] This is because TFM is being used in parallel. Fix this by allocating a new AEAD TFM for async decryption, but keep the existing one for synchronous READ cases (similar to what is done in smb3_calc_signature()). Also remove the calls to aead_request_set_callback() and crypto_wait_req() since it's always going to be a synchronous operation.",
      "id": "CVE-2024-50047",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_XFRM is not set in kernel config.",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "c14d989a-926b-4407-b21e-fa720c9011be",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: do not delay dst_entries_add() in dst_release() dst_entries_add() uses per-cpu data that might be freed at netns dismantle from ip6_route_net_exit() calling dst_entries_destroy() Before ip6_route_net_exit() can be called, we release all the dsts associated with this netns, via calls to dst_release(), which waits an rcu grace period before calling dst_destroy() dst_entries_add() use in dst_destroy() is racy, because dst_entries_destroy() could have been called already. Decrementing the number of dsts must happen sooner. Notes: 1) in CONFIG_XFRM case, dst_destroy() can call dst_release_immediate(child), this might also cause UAF if the child does not have DST_NOCOUNT set. IPSEC maintainers might take a look and see how to address this. 2) There is also discussion about removing this count of dst, which might happen in future kernels.",
      "id": "CVE-2024-50036",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-17T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:11Z"
      },
      "bom-ref": "53fbb22c-597a-4cb3-b131-a646bd193aed",
      "description": "In the Linux kernel, the following vulnerability has been resolved: thermal: core: Reference count the zone in thermal_zone_get_by_id() There are places in the thermal netlink code where nothing prevents the thermal zone object from going away while being accessed after it has been returned by thermal_zone_get_by_id(). To address this, make thermal_zone_get_by_id() get a reference on the thermal zone device object to be returned with the help of get_device(), under thermal_list_lock, and adjust all of its callers to this change with the help of the cleanup.h infrastructure.",
      "id": "CVE-2024-50028",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T15:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "9557fa52-d788-46cd-ab5f-ded6cee04f40",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/bpf/32: Fix Oops on tail call tests test_bpf tail call tests end up as: test_bpf: #0 Tail call leaf jited:1 85 PASS test_bpf: #1 Tail call 2 jited:1 111 PASS test_bpf: #2 Tail call 3 jited:1 145 PASS test_bpf: #3 Tail call 4 jited:1 170 PASS test_bpf: #4 Tail call load/store leaf jited:1 190 PASS test_bpf: #5 Tail call load/store jited:1 BUG: Unable to handle kernel data access on write at 0xf1b4e000 Faulting instruction address: 0xbe86b710 Oops: Kernel access of bad area, sig: 11 [#1] BE PAGE_SIZE=4K MMU=Hash PowerMac Modules linked in: test_bpf(+) CPU: 0 PID: 97 Comm: insmod Not tainted 6.1.0-rc4+ #195 Hardware name: PowerMac3,1 750CL 0x87210 PowerMac NIP: be86b710 LR: be857e88 CTR: be86b704 REGS: f1b4df20 TRAP: 0300 Not tainted (6.1.0-rc4+) MSR: 00009032 <EE,ME,IR,DR,RI> CR: 28008242 XER: 00000000 DAR: f1b4e000 DSISR: 42000000 GPR00: 00000001 f1b4dfe0 c11d2280 00000000 00000000 00000000 00000002 00000000 GPR08: f1b4e000 be86b704 f1b4e000 00000000 00000000 100d816a f2440000 fe73baa8 GPR16: f2458000 00000000 c1941ae4 f1fe2248 00000045 c0de0000 f2458030 00000000 GPR24: 000003e8 0000000f f2458000 f1b4dc90 3e584b46 00000000 f24466a0 c1941a00 NIP [be86b710] 0xbe86b710 LR [be857e88] __run_one+0xec/0x264 [test_bpf] Call Trace: [f1b4dfe0] [00000002] 0x2 (unreliable) Instruction dump: XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX ---[ end trace 0000000000000000 ]--- This is a tentative to write above the stack. The problem is encoutered with tests added by commit 38608ee7b690 (\"bpf, tests: Add load store test case for tail call\") This happens because tail call is done to a BPF prog with a different stack_depth. At the time being, the stack is kept as is when the caller tail calls its callee. But at exit, the callee restores the stack based on its own properties. Therefore here, at each run, r1 is erroneously increased by 32 - 16 = 16 bytes. This was done that way in order to pass the tail call count from caller to callee through the stack. As powerpc32 doesn't have a red zone in the stack, it was necessary the maintain the stack as is for the tail call. But it was not anticipated that the BPF frame size could be different. Let's take a new approach. Use register r4 to carry the tail call count during the tail call, and save it into the stack at function entry if required. This means the input parameter must be in r3, which is more correct as it is a 32 bits parameter, then tail call better match with normal BPF function entry, the down side being that we move that input parameter back and forth between r3 and r4. That can be optimised later. Doing that also has the advantage of maximising the common parts between tail calls and a normal function exit. With the fix, tail call tests are now successfull: test_bpf: #0 Tail call leaf jited:1 53 PASS test_bpf: #1 Tail call 2 jited:1 115 PASS test_bpf: #2 Tail call 3 jited:1 154 PASS test_bpf: #3 Tail call 4 jited:1 165 PASS test_bpf: #4 Tail call load/store leaf jited:1 101 PASS test_bpf: #5 Tail call load/store jited:1 141 PASS test_bpf: #6 Tail call error path, max count reached jited:1 994 PASS test_bpf: #7 Tail call count preserved across function calls jited:1 140975 PASS test_bpf: #8 Tail call error path, NULL target jited:1 110 PASS test_bpf: #9 Tail call error path, index out of range jited:1 69 PASS test_bpf: test_tail_calls: Summary: 10 PASSED, 0 FAILED, [10/10 JIT'ed]",
      "id": "CVE-2022-48998",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-07T17:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "005a87e9-13e5-433a-8c6e-13376a99cda3",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix use-after-free during gpu recovery [Why] [ 754.862560] refcount_t: underflow; use-after-free. [ 754.862898] Call Trace: [ 754.862903] <TASK> [ 754.862913] amdgpu_job_free_cb+0xc2/0xe1 [amdgpu] [ 754.863543] drm_sched_main.cold+0x34/0x39 [amd_sched] [How] The fw_fence may be not init, check whether dma_fence_init is performed before job free",
      "id": "CVE-2022-48990",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T16:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "41cc38be-9005-42d6-8e31-0a19dbb51eaa",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix array index out of bound error in DCN32 DML [Why&How] LinkCapacitySupport array is indexed with the number of voltage states and not the number of max DPPs. Fix the error by changing the array declaration to use the correct (larger) array size of total number of voltage states.",
      "id": "CVE-2022-48979",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T18:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:12Z"
      },
      "bom-ref": "6f06cb6e-198b-4de9-8c8b-9b7c9812e1f4",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: flowtable_offload: fix using __this_cpu_add in preemptible flow_offload_queue_work() can be called in workqueue without bh disabled, like the call trace showed in my act_ct testing, calling NF_FLOW_TABLE_STAT_INC() there would cause a call trace: BUG: using __this_cpu_add() in preemptible [00000000] code: kworker/u4:0/138560 caller is flow_offload_queue_work+0xec/0x1b0 [nf_flow_table] Workqueue: act_ct_workqueue tcf_ct_flow_table_cleanup_work [act_ct] Call Trace: <TASK> dump_stack_lvl+0x33/0x46 check_preemption_disabled+0xc3/0xf0 flow_offload_queue_work+0xec/0x1b0 [nf_flow_table] nf_flow_table_iterate+0x138/0x170 [nf_flow_table] nf_flow_table_free+0x140/0x1a0 [nf_flow_table] tcf_ct_flow_table_cleanup_work+0x2f/0x2b0 [act_ct] process_one_work+0x6a3/0x1030 worker_thread+0x8a/0xdf0 This patch fixes it by using NF_FLOW_TABLE_STAT_INC_ATOMIC() instead in flow_offload_queue_work(). Note that for FLOW_CLS_REPLACE branch in flow_offload_queue_work(), it may not be called in preemptible path, but it's good to use NF_FLOW_TABLE_STAT_INC_ATOMIC() for all cases in flow_offload_queue_work().",
      "id": "CVE-2022-48976",
      "published": "2024-10-21T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T18:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:14Z"
      },
      "bom-ref": "f9269fd1-51ce-4647-aa95-5f07832ea8bd",
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/mm/ident_map: Use gbpages only where full GB page should be mapped. When ident_pud_init() uses only GB pages to create identity maps, large ranges of addresses not actually requested can be included in the resulting table; a 4K request will map a full GB. This can include a lot of extra address space past that requested, including areas marked reserved by the BIOS. That allows processor speculation into reserved regions, that on UV systems can cause system halts. Only use GB pages when map creation requests include the full GB page of space. Fall back to using smaller 2M pages when only portions of a GB page are included in the request. No attempt is made to coalesce mapping requests. If a request requires a map entry at the 2M (pmd) level, subsequent mapping requests within the same 1G region will also be at the pmd level, even if adjacent or overlapping such requests could have been combined to map a full GB page. Existing usage starts with larger regions and then adds smaller regions, so this should not have any great consequence.",
      "id": "CVE-2024-50017",
      "published": "2024-10-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-17T12:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:15Z"
      },
      "bom-ref": "b493d902-f684-4294-b9be-847e9a1bac26",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix access to uninitialised lock in fc replay path The following kernel trace can be triggered with fstest generic/629 when executed against a filesystem with fast-commit feature enabled: INFO: trying to register non-static key. The code is fine but needs lockdep annotation, or maybe you didn't initialize this object before use? turning off the locking correctness validator. CPU: 0 PID: 866 Comm: mount Not tainted 6.10.0+ #11 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x66/0x90 register_lock_class+0x759/0x7d0 __lock_acquire+0x85/0x2630 ? __find_get_block+0xb4/0x380 lock_acquire+0xd1/0x2d0 ? __ext4_journal_get_write_access+0xd5/0x160 _raw_spin_lock+0x33/0x40 ? __ext4_journal_get_write_access+0xd5/0x160 __ext4_journal_get_write_access+0xd5/0x160 ext4_reserve_inode_write+0x61/0xb0 __ext4_mark_inode_dirty+0x79/0x270 ? ext4_ext_replay_set_iblocks+0x2f8/0x450 ext4_ext_replay_set_iblocks+0x330/0x450 ext4_fc_replay+0x14c8/0x1540 ? jread+0x88/0x2e0 ? rcu_is_watching+0x11/0x40 do_one_pass+0x447/0xd00 jbd2_journal_recover+0x139/0x1b0 jbd2_journal_load+0x96/0x390 ext4_load_and_init_journal+0x253/0xd40 ext4_fill_super+0x2cc6/0x3180 ... In the replay path there's an attempt to lock sbi->s_bdev_wb_lock in function ext4_check_bdev_write_error(). Unfortunately, at this point this spinlock has not been initialized yet. Moving it's initialization to an earlier point in __ext4_fill_super() fixes this splat.",
      "id": "CVE-2024-50014",
      "published": "2024-10-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:17Z"
      },
      "bom-ref": "f453de11-d45d-44e0-be07-2cf667026a43",
      "description": "In the Linux kernel, the following vulnerability has been resolved: cpufreq: Avoid a bad reference count on CPU node In the parse_perf_domain function, if the call to of_parse_phandle_with_args returns an error, then the reference to the CPU device node that was acquired at the start of the function would not be properly decremented. Address this by declaring the variable with the __free(device_node) cleanup attribute.",
      "id": "CVE-2024-50012",
      "published": "2024-10-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:18Z"
      },
      "bom-ref": "aa973b43-d2b0-4646-8f83-d4cc6c0aa07a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: exec: don't WARN for racy path_noexec check Both i_mode and noexec checks wrapped in WARN_ON stem from an artifact of the previous implementation. They used to legitimately check for the condition, but that got moved up in two commits: 633fb6ac3980 (\"exec: move S_ISREG() check earlier\") 0fd338b2d2cd (\"exec: move path_noexec() check earlier\") Instead of being removed said checks are WARN_ON'ed instead, which has some debug value. However, the spurious path_noexec check is racy, resulting in unwarranted warnings should someone race with setting the noexec flag. One can note there is more to perm-checking whether execve is allowed and none of the conditions are guaranteed to still hold after they were tested for. Additionally this does not validate whether the code path did any perm checking to begin with -- it will pass if the inode happens to be regular. Keep the redundant path_noexec() check even though it's mindless nonsense checking for guarantee that isn't given so drop the WARN. Reword the commentary and do small tidy ups while here. [brauner: keep redundant path_noexec() check]",
      "id": "CVE-2024-50010",
      "published": "2024-10-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-24T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:20Z"
      },
      "bom-ref": "35416ebe-f42e-4aac-be18-573b578e3ef6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cpufreq: amd-pstate: add check for cpufreq_cpu_get's return value cpufreq_cpu_get may return NULL. To avoid NULL-dereference check it and return in case of error. Found by Linux Verification Center (linuxtesting.org) with SVACE.",
      "id": "CVE-2024-50009",
      "published": "2024-10-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5e1721b0-e9c6-4409-b309-e18e9f260857",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: update DML2 policy EnhancedPrefetchScheduleAccelerationFinal DCN35 [WHY & HOW] Mismatch in DCN35 DML2 cause bw validation failed to acquire unexpected DPP pipe to cause grey screen and system hang. Remove EnhancedPrefetchScheduleAccelerationFinal value override to match HW spec. (cherry picked from commit 9dad21f910fcea2bdcff4af46159101d7f9cd8ba)",
      "id": "CVE-2024-50004",
      "published": "2024-10-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-07T19:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:21Z"
      },
      "bom-ref": "82f0100a-afca-4020-b3c1-d38483058d1c",
      "cwes": [
        476,
        367
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: dsa: improve shutdown sequence Alexander Sverdlin presents 2 problems during shutdown with the lan9303 driver. One is specific to lan9303 and the other just happens to reproduce there. The first problem is that lan9303 is unique among DSA drivers in that it calls dev_get_drvdata() at \"arbitrary runtime\" (not probe, not shutdown, not remove): phy_state_machine() -> ... -> dsa_user_phy_read() -> ds->ops->phy_read() -> lan9303_phy_read() -> chip->ops->phy_read() -> lan9303_mdio_phy_read() -> dev_get_drvdata() But we never stop the phy_state_machine(), so it may continue to run after dsa_switch_shutdown(). Our common pattern in all DSA drivers is to set drvdata to NULL to suppress the remove() method that may come afterwards. But in this case it will result in an NPD. The second problem is that the way in which we set dp->conduit->dsa_ptr = NULL; is concurrent with receive packet processing. dsa_switch_rcv() checks once whether dev->dsa_ptr is NULL, but afterwards, rather than continuing to use that non-NULL value, dev->dsa_ptr is dereferenced again and again without NULL checks: dsa_conduit_find_user() and many other places. In between dereferences, there is no locking to ensure that what was valid once continues to be valid. Both problems have the common aspect that closing the conduit interface solves them. In the first case, dev_close(conduit) triggers the NETDEV_GOING_DOWN event in dsa_user_netdevice_event() which closes user ports as well. dsa_port_disable_rt() calls phylink_stop(), which synchronously stops the phylink state machine, and ds->ops->phy_read() will thus no longer call into the driver after this point. In the second case, dev_close(conduit) should do this, as per Documentation/networking/driver.rst: | Quiescence | ---------- | | After the ndo_stop routine has been called, the hardware must | not receive or transmit any data. All in flight packets must | be aborted. If necessary, poll or wait for completion of | any reset commands. So it should be sufficient to ensure that later, when we zeroize conduit->dsa_ptr, there will be no concurrent dsa_switch_rcv() call on this conduit. The addition of the netif_device_detach() function is to ensure that ioctls, rtnetlinks and ethtool requests on the user ports no longer propagate down to the driver - we're no longer prepared to handle them. The race condition actually did not exist when commit 0650bf52b31f (\"net: dsa: be compatible with masters which unregister on shutdown\") first introduced dsa_switch_shutdown(). It was created later, when we stopped unregistering the user interfaces from a bad spot, and we just replaced that sequence with a racy zeroization of conduit->dsa_ptr (one which doesn't ensure that the interfaces aren't up).",
      "id": "CVE-2024-49998",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_CIFS not set kernel config.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "36eb05f9-4b84-45d8-8543-c6713ef429ed",
      "cwes": [
        120
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: Fix buffer overflow when parsing NFS reparse points ReparseDataLength is sum of the InodeType size and DataBuffer size. So to get DataBuffer size it is needed to subtract InodeType's size from ReparseDataLength. Function cifs_strndup_from_utf16() is currentlly accessing buf->DataBuffer at position after the end of the buffer because it does not subtract InodeType size from the length. Fix this problem and correctly subtract variable len. Member InodeType is present only when reparse buffer is large enough. Check for ReparseDataLength before accessing InodeType to prevent another invalid memory access. Major and minor rdev values are present also only when reparse buffer is large enough. Check for reparse buffer size before calling reparse_mkdev().",
      "id": "CVE-2024-49996",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:23Z"
      },
      "bom-ref": "a58be3cd-9167-4a70-b7c4-e7f49778efb9",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: block: fix integer overflow in BLKSECDISCARD I independently rediscovered commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155 block: fix overflow in blk_ioctl_discard() but for secure erase. Same problem: uint64_t r[2] = {512, 18446744073709551104ULL}; ioctl(fd, BLKSECDISCARD, r); will enter near infinite loop inside blkdev_issue_secure_erase(): a.out: attempt to access beyond end of device loop0: rw=5, sector=3399043073, nr_sectors = 1024 limit=2048 bio_check_eod: 3286214 callbacks suppressed",
      "id": "CVE-2024-49994",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_DRM_STM is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1eab2537-a6ca-4ca2-bbcf-caa942e0f27d",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/stm: Avoid use-after-free issues with crtc and plane ltdc_load() calls functions drm_crtc_init_with_planes(), drm_universal_plane_init() and drm_encoder_init(). These functions should not be called with parameters allocated with devm_kzalloc() to avoid use-after-free issues [1]. Use allocations managed by the DRM framework. Found by Linux Verification Center (linuxtesting.org). [1] https://lore.kernel.org/lkml/u366i76e3qhh3ra5oxrtngjtm2u5lterkekcz6y2jkndhuxzli@diujon4h7qwb/",
      "id": "CVE-2024-49992",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T14:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "7d2c1ec4-aab3-4fb5-8a28-ab909ce51890",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdkfd: amdkfd_free_gtt_mem clear the correct pointer Pass pointer reference to amdgpu_bo_unref to clear the correct pointer, otherwise amdgpu_bo_unref clear the local variable, the original pointer not set to NULL, this could cause use-after-free bug.",
      "id": "CVE-2024-49991",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-17T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:24Z"
      },
      "bom-ref": "6d782a45-20d3-4d01-9915-245c039a919a",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/hdcp: Check GSC structure validity Sometimes xe_gsc is not initialized when checked at HDCP capability check. Add gsc structure check to avoid null pointer error.",
      "id": "CVE-2024-49990",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-28T16:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "c0c832a2-0263-4070-839d-8e54bc826051",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix double free issue during amdgpu module unload Flexible endpoints use DIGs from available inflexible endpoints, so only the encoders of inflexible links need to be freed. Otherwise, a double free issue may occur when unloading the amdgpu module. [ 279.190523] RIP: 0010:__slab_free+0x152/0x2f0 [ 279.190577] Call Trace: [ 279.190580] <TASK> [ 279.190582] ? show_regs+0x69/0x80 [ 279.190590] ? die+0x3b/0x90 [ 279.190595] ? do_trap+0xc8/0xe0 [ 279.190601] ? do_error_trap+0x73/0xa0 [ 279.190605] ? __slab_free+0x152/0x2f0 [ 279.190609] ? exc_invalid_op+0x56/0x70 [ 279.190616] ? __slab_free+0x152/0x2f0 [ 279.190642] ? asm_exc_invalid_op+0x1f/0x30 [ 279.190648] ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu] [ 279.191096] ? __slab_free+0x152/0x2f0 [ 279.191102] ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu] [ 279.191469] kfree+0x260/0x2b0 [ 279.191474] dcn10_link_encoder_destroy+0x19/0x30 [amdgpu] [ 279.191821] link_destroy+0xd7/0x130 [amdgpu] [ 279.192248] dc_destruct+0x90/0x270 [amdgpu] [ 279.192666] dc_destroy+0x19/0x40 [amdgpu] [ 279.193020] amdgpu_dm_fini+0x16e/0x200 [amdgpu] [ 279.193432] dm_hw_fini+0x26/0x40 [amdgpu] [ 279.193795] amdgpu_device_fini_hw+0x24c/0x400 [amdgpu] [ 279.194108] amdgpu_driver_unload_kms+0x4f/0x70 [amdgpu] [ 279.194436] amdgpu_pci_remove+0x40/0x80 [amdgpu] [ 279.194632] pci_device_remove+0x3a/0xa0 [ 279.194638] device_remove+0x40/0x70 [ 279.194642] device_release_driver_internal+0x1ad/0x210 [ 279.194647] driver_detach+0x4e/0xa0 [ 279.194650] bus_remove_driver+0x6f/0xf0 [ 279.194653] driver_unregister+0x33/0x60 [ 279.194657] pci_unregister_driver+0x44/0x90 [ 279.194662] amdgpu_exit+0x19/0x1f0 [amdgpu] [ 279.194939] __do_sys_delete_module.isra.0+0x198/0x2f0 [ 279.194946] __x64_sys_delete_module+0x16/0x20 [ 279.194950] do_syscall_64+0x58/0x120 [ 279.194954] entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 279.194980] </TASK>",
      "id": "CVE-2024-49989",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:26Z"
      },
      "bom-ref": "d709c1d6-8b2c-423f-a038-2ce95772ee1e",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: add refcnt to ksmbd_conn struct When sending an oplock break request, opinfo->conn is used, But freed ->conn can be used on multichannel. This patch add a reference count to the ksmbd_conn struct so that it can be freed when it is no longer used.",
      "id": "CVE-2024-49988",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-28T16:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:27Z"
      },
      "bom-ref": "319bed81-71e1-49f6-ae86-8a5b334f287f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpftool: Fix undefined behavior in qsort(NULL, 0, ...) When netfilter has no entry to display, qsort is called with qsort(NULL, 0, ...). This results in undefined behavior, as UBSan reports: net.c:827:2: runtime error: null pointer passed as argument 1, which is declared to never be null Although the C standard does not explicitly state whether calling qsort with a NULL pointer when the size is 0 constitutes undefined behavior, Section 7.1.4 of the C standard (Use of library functions) mentions: \"Each of the following statements applies unless explicitly stated otherwise in the detailed descriptions that follow: If an argument to a function has an invalid value (such as a value outside the domain of the function, or a pointer outside the address space of the program, or a null pointer, or a pointer to non-modifiable storage when the corresponding parameter is not const-qualified) or a type (after promotion) not expected by a function with variable number of arguments, the behavior is undefined.\" To avoid this, add an early return when nf_link_info is NULL to prevent calling qsort with a NULL pointer.",
      "id": "CVE-2024-49987",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-28T16:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:29Z"
      },
      "bom-ref": "ce4c8d61-dd78-4db3-9251-c9d9874e17a1",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gso: fix udp gso fraglist segmentation after pull from frag_list Detect gso fraglist skbs with corrupted geometry (see below) and pass these to skb_segment instead of skb_segment_list, as the first can segment them correctly. Valid SKB_GSO_FRAGLIST skbs - consist of two or more segments - the head_skb holds the protocol headers plus first gso_size - one or more frag_list skbs hold exactly one segment - all but the last must be gso_size Optional datapath hooks such as NAT and BPF (bpf_skb_pull_data) can modify these skbs, breaking these invariants. In extreme cases they pull all data into skb linear. For UDP, this causes a NULL ptr deref in __udpv4_gso_segment_list_csum at udp_hdr(seg->next)->dest. Detect invalid geometry due to pull, by checking head_skb size. Don't just drop, as this may blackhole a destination. Convert to be able to pass to regular skb_segment.",
      "id": "CVE-2024-49978",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-29T18:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_NFSD is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "a1122922-93a8-406b-b20d-21a4bcdda957",
      "description": "In the Linux kernel, the following vulnerability has been resolved: NFSD: Limit the number of concurrent async COPY operations Nothing appears to limit the number of concurrent async COPY operations that clients can start. In addition, AFAICT each async COPY can copy an unlimited number of 4MB chunks, so can run for a long time. Thus IMO async COPY can become a DoS vector. Add a restriction mechanism that bounds the number of concurrent background COPY operations. Start simple and try to be fair -- this patch implements a per-namespace limit. An async COPY request that occurs while this limit is exceeded gets NFS4ERR_DELAY. The requesting client can choose to send the request again after a delay or fall back to a traditional read/write style copy. If there is need to make the mechanism more sophisticated, we can visit that in future patches.",
      "id": "CVE-2024-49974",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "8bce179c-9269-4521-abdd-74862564c0c7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Deallocate DML memory if allocation fails [Why] When DC state create DML memory allocation fails, memory is not deallocated subsequently, resulting in uninitialized structure that is not NULL. [How] Deallocate memory if DML memory allocation fails.",
      "id": "CVE-2024-49972",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-01T20:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b6dd10ed-c2b2-49b7-99c7-4af25b659e1f",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Increase array size of dummy_boolean [WHY] dml2_core_shared_mode_support and dml_core_mode_support access the third element of dummy_boolean, i.e. hw_debug5 = &s->dummy_boolean[2], when dummy_boolean has size of 2. Any assignment to hw_debug5 causes an OVERRUN. [HOW] Increase dummy_boolean's array size to 3. This fixes 2 OVERRUN issues reported by Coverity.",
      "id": "CVE-2024-49971",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-01T19:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "d3addf5d-f5eb-4c0e-98b2-a1e9c1dba438",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Implement bounds check for stream encoder creation in DCN401 'stream_enc_regs' array is an array of dcn10_stream_enc_registers structures. The array is initialized with four elements, corresponding to the four calls to stream_enc_regs() in the array initializer. This means that valid indices for this array are 0, 1, 2, and 3. The error message 'stream_enc_regs' 4 <= 5 below, is indicating that there is an attempt to access this array with an index of 5, which is out of bounds. This could lead to undefined behavior Here, eng_id is used as an index to access the stream_enc_regs array. If eng_id is 5, this would result in an out-of-bounds access on the stream_enc_regs array. Thus fixing Buffer overflow error in dcn401_stream_encoder_create Found by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn401/dcn401_resource.c:1209 dcn401_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5",
      "id": "CVE-2024-49970",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-29T15:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:30Z"
      },
      "bom-ref": "1b402e78-7023-4e1e-a26c-e74d2a283ad9",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: filesystems without casefold feature cannot be mounted with siphash When mounting the ext4 filesystem, if the default hash version is set to DX_HASH_SIPHASH but the casefold feature is not set, exit the mounting.",
      "id": "CVE-2024-49968",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-07T19:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "state": "not_affected"
      },
      "bom-ref": "d4af1ee7-dd4f-412a-a49b-4d223262c3c8",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ext4: fix timer use-after-free on failed mount Syzbot has found an ODEBUG bug in ext4_fill_super The del_timer_sync function cancels the s_err_report timer, which reminds about filesystem errors daily. We should guarantee the timer is no longer active before kfree(sbi). When filesystem mounting fails, the flow goes to failed_mount3, where an error occurs when ext4_stop_mmpd is called, causing a read I/O failure. This triggers the ext4_handle_error function that ultimately re-arms the timer, leaving the s_err_report timer active before kfree(sbi) is called. Fix the issue by canceling the s_err_report timer after calling ext4_stop_mmpd.",
      "id": "CVE-2024-49960",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "state": "not_affected"
      },
      "bom-ref": "6800473e-a1a6-423b-9c90-7f830aace8bb",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix uaf in l2cap_connect [Syzbot reported] BUG: KASAN: slab-use-after-free in l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949 Read of size 8 at addr ffff8880241e9800 by task kworker/u9:0/54 CPU: 0 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-00268-g788220eee30d #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 Workqueue: hci2 hci_rx_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:93 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:119 print_address_description mm/kasan/report.c:377 [inline] print_report+0xc3/0x620 mm/kasan/report.c:488 kasan_report+0xd9/0x110 mm/kasan/report.c:601 l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949 l2cap_connect_req net/bluetooth/l2cap_core.c:4080 [inline] l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:4772 [inline] l2cap_sig_channel net/bluetooth/l2cap_core.c:5543 [inline] l2cap_recv_frame+0xf0b/0x8eb0 net/bluetooth/l2cap_core.c:6825 l2cap_recv_acldata+0x9b4/0xb70 net/bluetooth/l2cap_core.c:7514 hci_acldata_packet net/bluetooth/hci_core.c:3791 [inline] hci_rx_work+0xaab/0x1610 net/bluetooth/hci_core.c:4028 process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231 process_scheduled_works kernel/workqueue.c:3312 [inline] worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389 kthread+0x2c1/0x3a0 kernel/kthread.c:389 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 ... Freed by task 5245: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:579 poison_slab_object+0xf7/0x160 mm/kasan/common.c:240 __kasan_slab_free+0x32/0x50 mm/kasan/common.c:256 kasan_slab_free include/linux/kasan.h:184 [inline] slab_free_hook mm/slub.c:2256 [inline] slab_free mm/slub.c:4477 [inline] kfree+0x12a/0x3b0 mm/slub.c:4598 l2cap_conn_free net/bluetooth/l2cap_core.c:1810 [inline] kref_put include/linux/kref.h:65 [inline] l2cap_conn_put net/bluetooth/l2cap_core.c:1822 [inline] l2cap_conn_del+0x59d/0x730 net/bluetooth/l2cap_core.c:1802 l2cap_connect_cfm+0x9e6/0xf80 net/bluetooth/l2cap_core.c:7241 hci_connect_cfm include/net/bluetooth/hci_core.h:1960 [inline] hci_conn_failed+0x1c3/0x370 net/bluetooth/hci_conn.c:1265 hci_abort_conn_sync+0x75a/0xb50 net/bluetooth/hci_sync.c:5583 abort_conn_sync+0x197/0x360 net/bluetooth/hci_conn.c:2917 hci_cmd_sync_work+0x1a4/0x410 net/bluetooth/hci_sync.c:328 process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231 process_scheduled_works kernel/workqueue.c:3312 [inline] worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389 kthread+0x2c1/0x3a0 kernel/kthread.c:389 ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244",
      "id": "CVE-2024-49950",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:32Z"
      },
      "bom-ref": "5742c175-296c-4c47-b728-1d60b2fd25ba",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/ncsi: Disable the ncsi work before freeing the associated structure The work function can run after the ncsi device is freed, resulting in use-after-free bugs or kernel panic.",
      "id": "CVE-2024-49945",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-01T14:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:33Z"
      },
      "bom-ref": "ad078a6b-c84e-4e59-b724-d011d9e6af55",
      "description": "In the Linux kernel, the following vulnerability has been resolved: l2tp: prevent possible tunnel refcount underflow When a session is created, it sets a backpointer to its tunnel. When the session refcount drops to 0, l2tp_session_free drops the tunnel refcount if session->tunnel is non-NULL. However, session->tunnel is set in l2tp_session_create, before the tunnel refcount is incremented by l2tp_session_register, which leaves a small window where session->tunnel is non-NULL when the tunnel refcount hasn't been bumped. Moving the assignment to l2tp_session_register is trivial but l2tp_session_create calls l2tp_session_set_header_len which uses session->tunnel to get the tunnel's encap. Add an encap arg to l2tp_session_set_header_len to avoid using session->tunnel. If l2tpv3 sessions have colliding IDs, it is possible for l2tp_v3_session_get to race with l2tp_session_register and fetch a session which doesn't yet have session->tunnel set. Add a check for this case.",
      "id": "CVE-2024-49940",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-13T13:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:35Z"
      },
      "bom-ref": "da565f1b-2fa1-4200-89d9-de7ba327e6ba",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: avoid to add interface to list twice when SER If SER L2 occurs during the WoWLAN resume flow, the add interface flow is triggered by ieee80211_reconfig(). However, due to rtw89_wow_resume() return failure, it will cause the add interface flow to be executed again, resulting in a double add list and causing a kernel panic. Therefore, we have added a check to prevent double adding of the list. list_add double add: new=ffff99d6992e2010, prev=ffff99d6992e2010, next=ffff99d695302628. ------------[ cut here ]------------ kernel BUG at lib/list_debug.c:37! invalid opcode: 0000 [#1] PREEMPT SMP NOPTI CPU: 0 PID: 9 Comm: kworker/0:1 Tainted: G W O 6.6.30-02659-gc18865c4dfbd #1 770df2933251a0e3c888ba69d1053a817a6376a7 Hardware name: HP Grunt/Grunt, BIOS Google_Grunt.11031.169.0 06/24/2021 Workqueue: events_freezable ieee80211_restart_work [mac80211] RIP: 0010:__list_add_valid_or_report+0x5e/0xb0 Code: c7 74 18 48 39 ce 74 13 b0 01 59 5a 5e 5f 41 58 41 59 41 5a 5d e9 e2 d6 03 00 cc 48 c7 c7 8d 4f 17 83 48 89 c2 e8 02 c0 00 00 <0f> 0b 48 c7 c7 aa 8c 1c 83 e8 f4 bf 00 00 0f 0b 48 c7 c7 c8 bc 12 RSP: 0018:ffffa91b8007bc50 EFLAGS: 00010246 RAX: 0000000000000058 RBX: ffff99d6992e0900 RCX: a014d76c70ef3900 RDX: ffffa91b8007bae8 RSI: 00000000ffffdfff RDI: 0000000000000001 RBP: ffffa91b8007bc88 R08: 0000000000000000 R09: ffffa91b8007bae0 R10: 00000000ffffdfff R11: ffffffff83a79800 R12: ffff99d695302060 R13: ffff99d695300900 R14: ffff99d6992e1be0 R15: ffff99d6992e2010 FS: 0000000000000000(0000) GS:ffff99d6aac00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000078fbdba43480 CR3: 000000010e464000 CR4: 00000000001506f0 Call Trace: <TASK> ? __die_body+0x1f/0x70 ? die+0x3d/0x60 ? do_trap+0xa4/0x110 ? __list_add_valid_or_report+0x5e/0xb0 ? do_error_trap+0x6d/0x90 ? __list_add_valid_or_report+0x5e/0xb0 ? handle_invalid_op+0x30/0x40 ? __list_add_valid_or_report+0x5e/0xb0 ? exc_invalid_op+0x3c/0x50 ? asm_exc_invalid_op+0x16/0x20 ? __list_add_valid_or_report+0x5e/0xb0 rtw89_ops_add_interface+0x309/0x310 [rtw89_core 7c32b1ee6854761c0321027c8a58c5160e41f48f] drv_add_interface+0x5c/0x130 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc] ieee80211_reconfig+0x241/0x13d0 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc] ? finish_wait+0x3e/0x90 ? synchronize_rcu_expedited+0x174/0x260 ? sync_rcu_exp_done_unlocked+0x50/0x50 ? wake_bit_function+0x40/0x40 ieee80211_restart_work+0xf0/0x140 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc] process_scheduled_works+0x1e5/0x480 worker_thread+0xea/0x1e0 kthread+0xdb/0x110 ? move_linked_works+0x90/0x90 ? kthread_associate_blkcg+0xa0/0xa0 ret_from_fork+0x3b/0x50 ? kthread_associate_blkcg+0xa0/0xa0 ret_from_fork_asm+0x11/0x20 </TASK> Modules linked in: dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc rfcomm cmac uinput algif_hash algif_skcipher af_alg btusb btrtl iio_trig_hrtimer industrialio_sw_trigger btmtk industrialio_configfs btbcm btintel uvcvideo videobuf2_vmalloc iio_trig_sysfs videobuf2_memops videobuf2_v4l2 videobuf2_common uvc snd_hda_codec_hdmi veth snd_hda_intel snd_intel_dspcfg acpi_als snd_hda_codec industrialio_triggered_buffer kfifo_buf snd_hwdep industrialio i2c_piix4 snd_hda_core designware_i2s ip6table_nat snd_soc_max98357a xt_MASQUERADE xt_cgroup snd_soc_acp_rt5682_mach fuse rtw89_8922ae(O) rtw89_8922a(O) rtw89_pci(O) rtw89_core(O) 8021q mac80211(O) bluetooth ecdh_generic ecc cfg80211 r8152 mii joydev gsmi: Log Shutdown Reason 0x03 ---[ end trace 0000000000000000 ]---",
      "id": "CVE-2024-49939",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:36Z"
      },
      "bom-ref": "a9c7accb-1d3f-4e3e-b30b-a5f2d91fdc45",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: cfg80211: Set correct chandef when starting CAC When starting CAC in a mode other than AP mode, it return a \"WARNING: CPU: 0 PID: 63 at cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]\" caused by the chandef.chan being null at the end of CAC. Solution: Ensure the channel definition is set for the different modes when starting CAC to avoid getting a NULL 'chan' at the end of CAC. Call Trace: ? show_regs.part.0+0x14/0x16 ? __warn+0x67/0xc0 ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211] ? report_bug+0xa7/0x130 ? exc_overflow+0x30/0x30 ? handle_bug+0x27/0x50 ? exc_invalid_op+0x18/0x60 ? handle_exception+0xf6/0xf6 ? exc_overflow+0x30/0x30 ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211] ? exc_overflow+0x30/0x30 ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211] ? regulatory_propagate_dfs_state.cold+0x1b/0x4c [cfg80211] ? cfg80211_propagate_cac_done_wk+0x1a/0x30 [cfg80211] ? process_one_work+0x165/0x280 ? worker_thread+0x120/0x3f0 ? kthread+0xc2/0xf0 ? process_one_work+0x280/0x280 ? kthread_complete_and_exit+0x20/0x20 ? ret_from_fork+0x19/0x24 [shorten subject, remove OCB, reorder cases to match previous list]",
      "id": "CVE-2024-49937",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-13T17:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:38Z"
      },
      "bom-ref": "a91ff91d-5caf-4b24-9d41-7e55a492c967",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/inode: Prevent dump_mapping() accessing invalid dentry.d_name.name It's observed that a crash occurs during hot-remove a memory device, in which user is accessing the hugetlb. See calltrace as following: ------------[ cut here ]------------ WARNING: CPU: 1 PID: 14045 at arch/x86/mm/fault.c:1278 do_user_addr_fault+0x2a0/0x790 Modules linked in: kmem device_dax cxl_mem cxl_pmem cxl_port cxl_pci dax_hmem dax_pmem nd_pmem cxl_acpi nd_btt cxl_core crc32c_intel nvme virtiofs fuse nvme_core nfit libnvdimm dm_multipath scsi_dh_rdac scsi_dh_emc s mirror dm_region_hash dm_log dm_mod CPU: 1 PID: 14045 Comm: daxctl Not tainted 6.10.0-rc2-lizhijian+ #492 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 RIP: 0010:do_user_addr_fault+0x2a0/0x790 Code: 48 8b 00 a8 04 0f 84 b5 fe ff ff e9 1c ff ff ff 4c 89 e9 4c 89 e2 be 01 00 00 00 bf 02 00 00 00 e8 b5 ef 24 00 e9 42 fe ff ff <0f> 0b 48 83 c4 08 4c 89 ea 48 89 ee 4c 89 e7 5b 5d 41 5c 41 5d 41 RSP: 0000:ffffc90000a575f0 EFLAGS: 00010046 RAX: ffff88800c303600 RBX: 0000000000000000 RCX: 0000000000000000 RDX: 0000000000001000 RSI: ffffffff82504162 RDI: ffffffff824b2c36 RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: ffffc90000a57658 R13: 0000000000001000 R14: ffff88800bc2e040 R15: 0000000000000000 FS: 00007f51cb57d880(0000) GS:ffff88807fd00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000001000 CR3: 00000000072e2004 CR4: 00000000001706f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __warn+0x8d/0x190 ? do_user_addr_fault+0x2a0/0x790 ? report_bug+0x1c3/0x1d0 ? handle_bug+0x3c/0x70 ? exc_invalid_op+0x14/0x70 ? asm_exc_invalid_op+0x16/0x20 ? do_user_addr_fault+0x2a0/0x790 ? exc_page_fault+0x31/0x200 exc_page_fault+0x68/0x200 <...snip...> BUG: unable to handle page fault for address: 0000000000001000 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP PTI ---[ end trace 0000000000000000 ]--- BUG: unable to handle page fault for address: 0000000000001000 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 14045 Comm: daxctl Kdump: loaded Tainted: G W 6.10.0-rc2-lizhijian+ #492 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014 RIP: 0010:dentry_name+0x1f4/0x440 <...snip...> ? dentry_name+0x2fa/0x440 vsnprintf+0x1f3/0x4f0 vprintk_store+0x23a/0x540 vprintk_emit+0x6d/0x330 _printk+0x58/0x80 dump_mapping+0x10b/0x1a0 ? __pfx_free_object_rcu+0x10/0x10 __dump_page+0x26b/0x3e0 ? vprintk_emit+0xe0/0x330 ? _printk+0x58/0x80 ? dump_page+0x17/0x50 dump_page+0x17/0x50 do_migrate_range+0x2f7/0x7f0 ? do_migrate_range+0x42/0x7f0 ? offline_pages+0x2f4/0x8c0 offline_pages+0x60a/0x8c0 memory_subsys_offline+0x9f/0x1c0 ? lockdep_hardirqs_on+0x77/0x100 ? _raw_spin_unlock_irqrestore+0x38/0x60 device_offline+0xe3/0x110 state_store+0x6e/0xc0 kernfs_fop_write_iter+0x143/0x200 vfs_write+0x39f/0x560 ksys_write+0x65/0xf0 do_syscall_64+0x62/0x130 Previously, some sanity check have been done in dump_mapping() before the print facility parsing '%pd' though, it's still possible to run into an invalid dentry.d_name.name. Since dump_mapping() only needs to dump the filename only, retrieve it by itself in a safer way to prevent an unnecessary crash. Note that either retrieving the filename with '%pd' or strncpy_from_kernel_nofault(), the filename could be unreliable.",
      "id": "CVE-2024-49934",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:39Z"
      },
      "bom-ref": "b1aa7a6b-b401-43bf-8433-2eb2afb3bc42",
      "cwes": [
        617
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: don't readahead the relocation inode on RST On relocation we're doing readahead on the relocation inode, but if the filesystem is backed by a RAID stripe tree we can get ENOENT (e.g. due to preallocated extents not being mapped in the RST) from the lookup. But readahead doesn't handle the error and submits invalid reads to the device, causing an assertion in the scatter-gather list code: BTRFS info (device nvme1n1): balance: start -d -m -s BTRFS info (device nvme1n1): relocating block group 6480920576 flags data|raid0 BTRFS error (device nvme1n1): cannot find raid-stripe for logical [6481928192, 6481969152] devid 2, profile raid0 ------------[ cut here ]------------ kernel BUG at include/linux/scatterlist.h:115! Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 1012 Comm: btrfs Not tainted 6.10.0-rc7+ #567 RIP: 0010:__blk_rq_map_sg+0x339/0x4a0 RSP: 0018:ffffc90001a43820 EFLAGS: 00010202 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802 RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000 RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8 R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000 FS: 00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 000000002cd11000 CR3: 00000001109ea001 CR4: 0000000000370eb0 Call Trace: <TASK> ? __die_body.cold+0x14/0x25 ? die+0x2e/0x50 ? do_trap+0xca/0x110 ? do_error_trap+0x65/0x80 ? __blk_rq_map_sg+0x339/0x4a0 ? exc_invalid_op+0x50/0x70 ? __blk_rq_map_sg+0x339/0x4a0 ? asm_exc_invalid_op+0x1a/0x20 ? __blk_rq_map_sg+0x339/0x4a0 nvme_prep_rq.part.0+0x9d/0x770 nvme_queue_rq+0x7d/0x1e0 __blk_mq_issue_directly+0x2a/0x90 ? blk_mq_get_budget_and_tag+0x61/0x90 blk_mq_try_issue_list_directly+0x56/0xf0 blk_mq_flush_plug_list.part.0+0x52b/0x5d0 __blk_flush_plug+0xc6/0x110 blk_finish_plug+0x28/0x40 read_pages+0x160/0x1c0 page_cache_ra_unbounded+0x109/0x180 relocate_file_extent_cluster+0x611/0x6a0 ? btrfs_search_slot+0xba4/0xd20 ? balance_dirty_pages_ratelimited_flags+0x26/0xb00 relocate_data_extent.constprop.0+0x134/0x160 relocate_block_group+0x3f2/0x500 btrfs_relocate_block_group+0x250/0x430 btrfs_relocate_chunk+0x3f/0x130 btrfs_balance+0x71b/0xef0 ? kmalloc_trace_noprof+0x13b/0x280 btrfs_ioctl+0x2c2e/0x3030 ? kvfree_call_rcu+0x1e6/0x340 ? list_lru_add_obj+0x66/0x80 ? mntput_no_expire+0x3a/0x220 __x64_sys_ioctl+0x96/0xc0 do_syscall_64+0x54/0x110 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7fcc04514f9b Code: Unable to access opcode bytes at 0x7fcc04514f71. RSP: 002b:00007ffeba923370 EFLAGS: 00000246 ORIG_RAX: 0000000000000010 RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fcc04514f9b RDX: 00007ffeba923460 RSI: 00000000c4009420 RDI: 0000000000000003 RBP: 0000000000000000 R08: 0000000000000013 R09: 0000000000000001 R10: 00007fcc043fbba8 R11: 0000000000000246 R12: 00007ffeba924fc5 R13: 00007ffeba923460 R14: 0000000000000002 R15: 00000000004d4bb0 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010:__blk_rq_map_sg+0x339/0x4a0 RSP: 0018:ffffc90001a43820 EFLAGS: 00010202 RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802 RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000 RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8 R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000 FS: 00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fcc04514f71 CR3: 00000001109ea001 CR4: 0000000000370eb0 Kernel p ---truncated---",
      "id": "CVE-2024-49932",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-13T15:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_ATH12K not set in kernel config.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6dc5f859-6eaa-4a51-9f74-a3af9e254951",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix array out-of-bound access in SoC stats Currently, the ath12k_soc_dp_stats::hal_reo_error array is defined with a maximum size of DP_REO_DST_RING_MAX. However, the ath12k_dp_rx_process() function access ath12k_soc_dp_stats::hal_reo_error using the REO destination SRNG ring ID, which is incorrect. SRNG ring ID differ from normal ring ID, and this usage leads to out-of-bounds array access. To fix this issue, modify ath12k_dp_rx_process() to use the normal ring ID directly instead of the SRNG ring ID to avoid out-of-bounds array access. Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.0.1-00029-QCAHKSWPL_SILICONZ-1",
      "id": "CVE-2024-49931",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T15:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:41Z"
      },
      "bom-ref": "85ba9ce4-40c7-4e46-add0-4c5c8b460b22",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: iwlwifi: mvm: avoid NULL pointer dereference iwl_mvm_tx_skb_sta() and iwl_mvm_tx_mpdu() verify that the mvmvsta pointer is not NULL. It retrieves this pointer using iwl_mvm_sta_from_mac80211, which is dereferencing the ieee80211_sta pointer. If sta is NULL, iwl_mvm_sta_from_mac80211 will dereference a NULL pointer. Fix this by checking the sta pointer before retrieving the mvmsta from it. If sta is not NULL, then mvmsta isn't either.",
      "id": "CVE-2024-49929",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFG_RTW89_* not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "d90caebc-bb6b-4fed-ae0d-f7ea34185e7b",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: avoid reading out of bounds when loading TX power FW elements Because the loop-expression will do one more time before getting false from cond-expression, the original code copied one more entry size beyond valid region. Fix it by moving the entry copy to loop-body.",
      "id": "CVE-2024-49928",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T15:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:42Z"
      },
      "bom-ref": "970f89e9-c5b7-462f-8135-cf41edfa1cbd",
      "description": "In the Linux kernel, the following vulnerability has been resolved: rcu-tasks: Fix access non-existent percpu rtpcp variable in rcu_tasks_need_gpcb() For kernels built with CONFIG_FORCE_NR_CPUS=y, the nr_cpu_ids is defined as NR_CPUS instead of the number of possible cpus, this will cause the following system panic: smpboot: Allowing 4 CPUs, 0 hotplug CPUs ... setup_percpu: NR_CPUS:512 nr_cpumask_bits:512 nr_cpu_ids:512 nr_node_ids:1 ... BUG: unable to handle page fault for address: ffffffff9911c8c8 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 0 PID: 15 Comm: rcu_tasks_trace Tainted: G W 6.6.21 #1 5dc7acf91a5e8e9ac9dcfc35bee0245691283ea6 RIP: 0010:rcu_tasks_need_gpcb+0x25d/0x2c0 RSP: 0018:ffffa371c00a3e60 EFLAGS: 00010082 CR2: ffffffff9911c8c8 CR3: 000000040fa20005 CR4: 00000000001706f0 Call Trace: <TASK> ? __die+0x23/0x80 ? page_fault_oops+0xa4/0x180 ? exc_page_fault+0x152/0x180 ? asm_exc_page_fault+0x26/0x40 ? rcu_tasks_need_gpcb+0x25d/0x2c0 ? __pfx_rcu_tasks_kthread+0x40/0x40 rcu_tasks_one_gp+0x69/0x180 rcu_tasks_kthread+0x94/0xc0 kthread+0xe8/0x140 ? __pfx_kthread+0x40/0x40 ret_from_fork+0x34/0x80 ? __pfx_kthread+0x40/0x40 ret_from_fork_asm+0x1b/0x80 </TASK> Considering that there may be holes in the CPU numbers, use the maximum possible cpu number, instead of nr_cpu_ids, for configuring enqueue and dequeue limits. [ neeraj.upadhyay: Fix htmldocs build error reported by Stephen Rothwell ]",
      "id": "CVE-2024-49926",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-24T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:44Z"
      },
      "bom-ref": "9004faff-b246-4d84-8262-6a49a7574f44",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: fbdev: efifb: Register sysfs groups through driver core The driver core can register and cleanup sysfs groups already. Make use of that functionality to simplify the error handling and cleanup. Also avoid a UAF race during unregistering where the sysctl attributes were usable after the info struct was freed.",
      "id": "CVE-2024-49925",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "155fd147-b61f-4bdf-96b9-ae82b6dc3387",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Pass non-null to dcn20_validate_apply_pipe_split_flags [WHAT & HOW] \"dcn20_validate_apply_pipe_split_flags\" dereferences merge, and thus it cannot be a null pointer. Let's pass a valid pointer to avoid null dereference. This fixes 2 FORWARD_NULL issues reported by Coverity.",
      "id": "CVE-2024-49923",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-21T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "03303629-770d-4963-83af-cec12ccbd322",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check null pointers before using them [WHAT & HOW] These pointers are null checked previously in the same function, indicating they might be null as reported by Coverity. As a result, they need to be checked when used again. This fixes 3 FORWARD_NULL issue reported by Coverity.",
      "id": "CVE-2024-49922",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T14:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "bb9329f8-de83-4151-ad80-2ba1ae8418e3",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check null pointers before used [WHAT & HOW] Poniters, such as dc->clk_mgr, are null checked previously in the same function, so Coverity warns \"implies that \"dc->clk_mgr\" might be null\". As a result, these pointers need to be checked when used again. This fixes 10 FORWARD_NULL issues reported by Coverity.",
      "id": "CVE-2024-49921",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T15:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c1822be7-564d-4edc-af4c-ab96093fd668",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check null pointers before multiple uses [WHAT & HOW] Poniters, such as stream_enc and dc->bw_vbios, are null checked previously in the same function, so Coverity warns \"implies that stream_enc and dc->bw_vbios might be null\". They are used multiple times in the subsequent code and need to be checked. This fixes 10 FORWARD_NULL issues reported by Coverity.",
      "id": "CVE-2024-49920",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T14:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "1928d9fe-6dfd-4115-b0d6-1b30dc58972c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null check for head_pipe in dcn201_acquire_free_pipe_for_layer This commit addresses a potential null pointer dereference issue in the `dcn201_acquire_free_pipe_for_layer` function. The issue could occur when `head_pipe` is null. The fix adds a check to ensure `head_pipe` is not null before asserting it. If `head_pipe` is null, the function returns NULL to prevent a potential null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn201/dcn201_resource.c:1016 dcn201_acquire_free_pipe_for_layer() error: we previously assumed 'head_pipe' could be null (see line 1010)",
      "id": "CVE-2024-49919",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-21T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "35ad1da9-e3da-4623-9dc8-7b5351ca560a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null check for head_pipe in dcn32_acquire_idle_pipe_for_head_pipe_in_layer This commit addresses a potential null pointer dereference issue in the `dcn32_acquire_idle_pipe_for_head_pipe_in_layer` function. The issue could occur when `head_pipe` is null. The fix adds a check to ensure `head_pipe` is not null before asserting it. If `head_pipe` is null, the function returns NULL to prevent a potential null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn32/dcn32_resource.c:2690 dcn32_acquire_idle_pipe_for_head_pipe_in_layer() error: we previously assumed 'head_pipe' could be null (see line 2681)",
      "id": "CVE-2024-49918",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T16:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b2a8ab3e-5288-4ade-9e3b-04248828e871",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn30_init_hw This commit addresses a potential null pointer dereference issue in the `dcn30_init_hw` function. The issue could occur when `dc->clk_mgr` or `dc->clk_mgr->funcs` is null. The fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` is not null before accessing its functions. This prevents a potential null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:789 dcn30_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 628)",
      "id": "CVE-2024-49917",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "82ba78e3-39e4-4200-9599-e2160c56dc62",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn401_init_hw This commit addresses a potential null pointer dereference issue in the `dcn401_init_hw` function. The issue could occur when `dc->clk_mgr` or `dc->clk_mgr->funcs` is null. The fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` is not null before accessing its functions. This prevents a potential null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn401/dcn401_hwseq.c:416 dcn401_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 225)",
      "id": "CVE-2024-49916",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T17:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fe9cb724-799a-4fcd-8fc8-95e212514c89",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL check for clk_mgr in dcn32_init_hw This commit addresses a potential null pointer dereference issue in the `dcn32_init_hw` function. The issue could occur when `dc->clk_mgr` is null. The fix adds a check to ensure `dc->clk_mgr` is not null before accessing its functions. This prevents a potential null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn32/dcn32_hwseq.c:961 dcn32_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 782)",
      "id": "CVE-2024-49915",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "d6d7f89b-2486-4500-9f6a-f94c80838a6b",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null check for pipe_ctx->plane_state in dcn20_program_pipe This commit addresses a null pointer dereference issue in the `dcn20_program_pipe` function. The issue could occur when `pipe_ctx->plane_state` is null. The fix adds a check to ensure `pipe_ctx->plane_state` is not null before accessing. This prevents a null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn20/dcn20_hwseq.c:1925 dcn20_program_pipe() error: we previously assumed 'pipe_ctx->plane_state' could be null (see line 1877)",
      "id": "CVE-2024-49914",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T13:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5c965d8c-f5e7-466e-8dae-186256f12a27",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Handle null 'stream_status' in 'planes_changed_for_existing_stream' This commit adds a null check for 'stream_status' in the function 'planes_changed_for_existing_stream'. Previously, the code assumed 'stream_status' could be null, but did not handle the case where it was actually null. This could lead to a null pointer dereference. Reported by smatch: drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:3784 planes_changed_for_existing_stream() error: we previously assumed 'stream_status' could be null (see line 3774)",
      "id": "CVE-2024-49912",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T17:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "75b2316e-94e5-43ef-80ec-f864691f8e09",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL check for function pointer in dcn20_set_output_transfer_func This commit adds a null check for the set_output_gamma function pointer in the dcn20_set_output_transfer_func function. Previously, set_output_gamma was being checked for null at line 1030, but then it was being dereferenced without any null check at line 1048. This could potentially lead to a null pointer dereference error if set_output_gamma is null. To fix this, we now ensure that set_output_gamma is not null before dereferencing it. We do this by adding a null check for set_output_gamma before the call to set_output_gamma at line 1048.",
      "id": "CVE-2024-49911",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "89dbb644-6c39-4f5e-932d-c7ffa118cc03",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL check for function pointer in dcn401_set_output_transfer_func This commit adds a null check for the set_output_gamma function pointer in the dcn401_set_output_transfer_func function. Previously, set_output_gamma was being checked for null, but then it was being dereferenced without any null check. This could lead to a null pointer dereference if set_output_gamma is null. To fix this, we now ensure that set_output_gamma is not null before dereferencing it. We do this by adding a null check for set_output_gamma before the call to set_output_gamma.",
      "id": "CVE-2024-49910",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T02:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "2e06788b-c792-46b6-84f8-dcccee96db48",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add NULL check for function pointer in dcn32_set_output_transfer_func This commit adds a null check for the set_output_gamma function pointer in the dcn32_set_output_transfer_func function. Previously, set_output_gamma was being checked for null, but then it was being dereferenced without any null check. This could lead to a null pointer dereference if set_output_gamma is null. To fix this, we now ensure that set_output_gamma is not null before dereferencing it. We do this by adding a null check for set_output_gamma before the call to set_output_gamma.",
      "id": "CVE-2024-49909",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "fa0e25f3-4d8a-4297-995d-509bfe93cb40",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null check for 'afb' in amdgpu_dm_update_cursor (v2) This commit adds a null check for the 'afb' variable in the amdgpu_dm_update_cursor function. Previously, 'afb' was assumed to be null at line 8388, but was used later in the code without a null check. This could potentially lead to a null pointer dereference. Changes since v1: - Moved the null check for 'afb' to the line where 'afb' is used. (Alex) Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm.c:8433 amdgpu_dm_update_cursor() error: we previously assumed 'afb' could be null (see line 8388)",
      "id": "CVE-2024-49908",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T03:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "a64d59c6-8ef0-480f-9383-e1856ab55184",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check null pointer before try to access it [why & how] Change the order of the pipe_ctx->plane_state check to ensure that plane_state is not null before accessing it.",
      "id": "CVE-2024-49906",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T13:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "148d3723-75af-4bb7-9391-76c105ffc4b5",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Add null check for 'afb' in amdgpu_dm_plane_handle_cursor_update (v2) This commit adds a null check for the 'afb' variable in the amdgpu_dm_plane_handle_cursor_update function. Previously, 'afb' was assumed to be null, but was used later in the code without a null check. This could potentially lead to a null pointer dereference. Changes since v1: - Moved the null check for 'afb' to the line where 'afb' is used. (Alex) Fixes the below: drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_plane.c:1298 amdgpu_dm_plane_handle_cursor_update() error: we previously assumed 'afb' could be null (see line 1252)",
      "id": "CVE-2024-49905",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T03:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "f1360344-9353-4a90-826b-e9a652798d9f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: add list empty check to avoid null pointer issue Add list empty check to avoid null pointer issues in some corner cases. - list_for_each_entry_safe()",
      "id": "CVE-2024-49904",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T15:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:45Z"
      },
      "bom-ref": "64ca0632-3972-4e82-b231-da16cc0fcb9c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/msm/adreno: Assign msm_gpu->pdev earlier to avoid nullptrs There are some cases, such as the one uncovered by Commit 46d4efcccc68 (\"drm/msm/a6xx: Avoid a nullptr dereference when speedbin setting fails\") where msm_gpu_cleanup() : platform_set_drvdata(gpu->pdev, NULL); is called on gpu->pdev == NULL, as the GPU device has not been fully initialized yet. Turns out that there's more than just the aforementioned path that causes this to happen (e.g. the case when there's speedbin data in the catalog, but opp-supported-hw is missing in DT). Assigning msm_gpu->pdev earlier seems like the least painful solution to this, therefore do so. Patchwork: https://patchwork.freedesktop.org/patch/602742/",
      "id": "CVE-2024-49901",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T14:05:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "47c48d4b-be98-45df-807a-f9fc84433be9",
      "cwes": [
        369
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Initialize denominators' default to 1 [WHAT & HOW] Variables used as denominators and maybe not assigned to other values, should not be 0. Change their default to 1 so they are never 0. This fixes 10 DIVIDE_BY_ZERO issues reported by Coverity.",
      "id": "CVE-2024-49899",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "9e12219e-0e90-4a62-8a51-056acdaa3a59",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check null-initialized variables [WHAT & HOW] drr_timing and subvp_pipe are initialized to null and they are not always assigned new values. It is necessary to check for null before dereferencing. This fixes 2 FORWARD_NULL issues reported by Coverity.",
      "id": "CVE-2024-49898",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "7f00dd3b-e739-4857-b32f-84a13898f3ff",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check phantom_stream before it is used dcn32_enable_phantom_stream can return null, so returned value must be checked before used. This fixes 1 NULL_RETURNS issue reported by Coverity.",
      "id": "CVE-2024-49897",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "b28afb2f-079d-4818-96d7-79a18f3b48bf",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check stream_status before it is used [WHAT & HOW] dc_state_get_stream_status can return null, and therefore null must be checked before stream_status is used. This fixes 1 NULL_RETURNS issue reported by Coverity.",
      "id": "CVE-2024-49893",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-25T14:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:47Z"
      },
      "bom-ref": "a2c10bb9-a0ec-47bc-b74b-e690e7bba0d4",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Validate hdwq pointers before dereferencing in reset/errata paths When the HBA is undergoing a reset or is handling an errata event, NULL ptr dereference crashes may occur in routines such as lpfc_sli_flush_io_rings(), lpfc_dev_loss_tmo_callbk(), or lpfc_abort_handler(). Add NULL ptr checks before dereferencing hdwq pointers that may have been freed due to operations colliding with a reset or errata event handler.",
      "id": "CVE-2024-49891",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:48Z"
      },
      "bom-ref": "0b3fa763-341e-4e80-9778-566c22040ec8",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix a sdiv overflow issue Zac Ecob reported a problem where a bpf program may cause kernel crash due to the following error: Oops: divide error: 0000 [#1] PREEMPT SMP KASAN PTI The failure is due to the below signed divide: LLONG_MIN/-1 where LLONG_MIN equals to -9,223,372,036,854,775,808. LLONG_MIN/-1 is supposed to give a positive number 9,223,372,036,854,775,808, but it is impossible since for 64-bit system, the maximum positive number is 9,223,372,036,854,775,807. On x86_64, LLONG_MIN/-1 will cause a kernel exception. On arm64, the result for LLONG_MIN/-1 is LLONG_MIN. Further investigation found all the following sdiv/smod cases may trigger an exception when bpf program is running on x86_64 platform: - LLONG_MIN/-1 for 64bit operation - INT_MIN/-1 for 32bit operation - LLONG_MIN%-1 for 64bit operation - INT_MIN%-1 for 32bit operation where -1 can be an immediate or in a register. On arm64, there are no exceptions: - LLONG_MIN/-1 = LLONG_MIN - INT_MIN/-1 = INT_MIN - LLONG_MIN%-1 = 0 - INT_MIN%-1 = 0 where -1 can be an immediate or in a register. Insn patching is needed to handle the above cases and the patched codes produced results aligned with above arm64 result. The below are pseudo codes to handle sdiv/smod exceptions including both divisor -1 and divisor 0 and the divisor is stored in a register. sdiv: tmp = rX tmp += 1 /* [-1, 0] -> [0, 1] if tmp >(unsigned) 1 goto L2 if tmp == 0 goto L1 rY = 0 L1: rY = -rY; goto L3 L2: rY /= rX L3: smod: tmp = rX tmp += 1 /* [-1, 0] -> [0, 1] if tmp >(unsigned) 1 goto L1 if tmp == 1 (is64 ? goto L2 : goto L3) rY = 0; goto L2 L1: rY %= rX L2: goto L4 // only when !is64 L3: wY = wY // only when !is64 L4: [1] https://lore.kernel.org/bpf/tPJLTEh7S_DxFEqAI2Ji5MBSoZVg7_G-Py2iaZpAaWtM961fFTWtsnlzwvTbzBzaUzwQAoNATXKUlt0LZOFgnDcIyKCswAnAGdUF3LBrhGQ=@protonmail.com/",
      "id": "CVE-2024-49888",
      "published": "2024-10-21T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-13T14:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "cc34b127-12ff-41d6-b4e4-d3fcde80b68d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Fix helper writes to read-only maps Lonial found an issue that despite user- and BPF-side frozen BPF map (like in case of .rodata), it was still possible to write into it from a BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT} as arguments. In check_func_arg() when the argument is as mentioned, the meta->raw_mode is never set. Later, check_helper_mem_access(), under the case of PTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the subsequent call to check_map_access_type() and given the BPF map is read-only it succeeds. The helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT when results are written into them as opposed to read out of them. The latter indicates that it's okay to pass a pointer to uninitialized memory as the memory is written to anyway. However, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM just with additional alignment requirement. So it is better to just get rid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the fixed size memory types. For this, add MEM_ALIGNED to additionally ensure alignment given these helpers write directly into the args via *<ptr> = val. The .arg*_size has been initialized reflecting the actual sizeof(*<ptr>). MEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated argument types, since in !MEM_FIXED_SIZE cases the verifier does not know the buffer size a priori and therefore cannot blindly write *<ptr> = val.",
      "id": "CVE-2024-49861",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:50Z"
      },
      "bom-ref": "7e785c0b-e6e0-434b-98df-9a7ebacb0a70",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to check atomic_file in f2fs ioctl interfaces Some f2fs ioctl interfaces like f2fs_ioc_set_pin_file(), f2fs_move_file_range(), and f2fs_defragment_range() missed to check atomic_write status, which may cause potential race issue, fix it.",
      "id": "CVE-2024-49859",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-22T16:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "e74cb15c-7a9e-4fb8-a490-3a437e8e9983",
      "cwes": [
        670
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm: call the security_mmap_file() LSM hook in remap_file_pages() The remap_file_pages syscall handler calls do_mmap() directly, which doesn't contain the LSM security check. And if the process has called personality(READ_IMPLIES_EXEC) before and remap_file_pages() is called for RW pages, this will actually result in remapping the pages to RWX, bypassing a W^X policy enforced by SELinux. So we should check prot by security_mmap_file LSM hook in the remap_file_pages syscall handler before do_mmap() is called. Otherwise, it potentially permits an attacker to bypass a W^X policy enforced by SELinux. The bypass is similar to CVE-2016-10044, which bypass the same thing via AIO and can be found in [1]. The PoC: $ cat > test.c int main(void) { size_t pagesz = sysconf(_SC_PAGE_SIZE); int mfd = syscall(SYS_memfd_create, \"test\", 0); const char *buf = mmap(NULL, 4 * pagesz, PROT_READ | PROT_WRITE, MAP_SHARED, mfd, 0); unsigned int old = syscall(SYS_personality, 0xffffffff); syscall(SYS_personality, READ_IMPLIES_EXEC | old); syscall(SYS_remap_file_pages, buf, pagesz, 0, 2, 0); syscall(SYS_personality, old); // show the RWX page exists even if W^X policy is enforced int fd = open(\"/proc/self/maps\", O_RDONLY); unsigned char buf2[1024]; while (1) { int ret = read(fd, buf2, 1024); if (ret <= 0) break; write(1, buf2, ret); } close(fd); } $ gcc test.c -o test $ ./test | grep rwx 7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted) [PM: subject line tweaks]",
      "id": "CVE-2024-47745",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:51Z"
      },
      "bom-ref": "e6049993-2878-4e86-9bcb-25c67562492b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: mac80211: don't use rate mask for offchannel TX either Like the commit ab9177d83c04 (\"wifi: mac80211: don't use rate mask for scanning\"), ignore incorrect settings to avoid no supported rate warning reported by syzbot. The syzbot did bisect and found cause is commit 9df66d5b9f45 (\"cfg80211: fix default HE tx bitrate mask in 2G band\"), which however corrects bitmask of HE MCS and recognizes correctly settings of empty legacy rate plus HE MCS rate instead of returning -EINVAL. As suggestions [1], follow the change of SCAN TX to consider this case of offchannel TX as well. [1] https://lore.kernel.org/linux-wireless/6ab2dc9c3afe753ca6fdcdd1421e7a1f47e87b84.camel@sipsolutions.net/T/#m2ac2a6d2be06a37c9c47a3d8a44b4f647ed4f024",
      "id": "CVE-2024-47738",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T22:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:53Z"
      },
      "bom-ref": "36f194ef-4cac-49a6-beef-a9914fbecb08",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: erofs: handle overlapped pclusters out of crafted images properly syzbot reported a task hang issue due to a deadlock case where it is waiting for the folio lock of a cached folio that will be used for cache I/Os. After looking into the crafted fuzzed image, I found it's formed with several overlapped big pclusters as below: Ext: logical offset | length : physical offset | length 0: 0.. 16384 | 16384 : 151552.. 167936 | 16384 1: 16384.. 32768 | 16384 : 155648.. 172032 | 16384 2: 32768.. 49152 | 16384 : 537223168.. 537239552 | 16384 ... Here, extent 0/1 are physically overlapped although it's entirely _impossible_ for normal filesystem images generated by mkfs. First, managed folios containing compressed data will be marked as up-to-date and then unlocked immediately (unlike in-place folios) when compressed I/Os are complete. If physical blocks are not submitted in the incremental order, there should be separate BIOs to avoid dependency issues. However, the current code mis-arranges z_erofs_fill_bio_vec() and BIO submission which causes unexpected BIO waits. Second, managed folios will be connected to their own pclusters for efficient inter-queries. However, this is somewhat hard to implement easily if overlapped big pclusters exist. Again, these only appear in fuzzed images so let's simply fall back to temporary short-lived pages for correctness. Additionally, it justifies that referenced managed folios cannot be truncated for now and reverts part of commit 2080ca1ed3e4 (\"erofs: tidy up `struct z_erofs_bvec`\") for simplicity although it shouldn't be any difference.",
      "id": "CVE-2024-47736",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-17T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_CRYPTO_DEV_HISI_SEC is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "3eb14755-d60b-46bc-9458-3fc9eb5e71a1",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: crypto: hisilicon/qm - inject error before stopping queue The master ooo cannot be completely closed when the accelerator core reports memory error. Therefore, the driver needs to inject the qm error to close the master ooo. Currently, the qm error is injected after stopping queue, memory may be released immediately after stopping queue, causing the device to access the released memory. Therefore, error is injected to close master ooo before stopping queue to ensure that the device does not access the released memory.",
      "id": "CVE-2024-47730",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:54Z"
      },
      "bom-ref": "02ce4015-3c18-45b0-b49b-b3d26f0b96cf",
      "cwes": [
        459
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Zero former ARG_PTR_TO_{LONG,INT} args in case of error For all non-tracing helpers which formerly had ARG_PTR_TO_{LONG,INT} as input arguments, zero the value for the case of an error as otherwise it could leak memory. For tracing, it is not needed given CAP_PERFMON can already read all kernel memory anyway hence bpf_get_func_arg() and bpf_get_func_ret() is skipped in here. Also, the MTU helpers mtu_len pointer value is being written but also read. Technically, the MEM_UNINIT should not be there in order to always force init. Removing MEM_UNINIT needs more verifier rework though: MEM_UNINIT right now implies two things actually: i) write into memory, ii) memory does not have to be initialized. If we lift MEM_UNINIT, it then becomes: i) read into memory, ii) memory must be initialized. This means that for bpf_*_check_mtu() we're readding the issue we're trying to fix, that is, it would then be able to write back into things like .rodata BPF maps. Follow-up work will rework the MEM_UNINIT semantics such that the intent can be better expressed. For now just clear the *mtu_len on error path which can be lifted later again.",
      "id": "CVE-2024-47728",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T20:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_F2FS_FS is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "078938d4-b5cf-40c1-8e95-a3de950b9eba",
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to wait dio completion It should wait all existing dio write IOs before block removal, otherwise, previous direct write IO may overwrite data in the block which may be reused by other inode.",
      "id": "CVE-2024-47726",
      "published": "2024-10-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:56Z"
      },
      "bom-ref": "9fb6b309-b32b-4eeb-b409-67bd033a7d74",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: avoid possible NULL deref in rt6_uncached_list_flush_dev() Blamed commit accidentally removed a check for rt->rt6i_idev being NULL, as spotted by syzbot: Oops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 1 UID: 0 PID: 10998 Comm: syz-executor Not tainted 6.11.0-rc6-syzkaller-00208-g625403177711 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024 RIP: 0010:rt6_uncached_list_flush_dev net/ipv6/route.c:177 [inline] RIP: 0010:rt6_disable_ip+0x33e/0x7e0 net/ipv6/route.c:4914 Code: 41 80 3c 04 00 74 0a e8 90 d0 9b f7 48 8b 7c 24 08 48 8b 07 48 89 44 24 10 4c 89 f0 48 c1 e8 03 48 b9 00 00 00 00 00 fc ff df <80> 3c 08 00 74 08 4c 89 f7 e8 64 d0 9b f7 48 8b 44 24 18 49 39 06 RSP: 0018:ffffc900047374e0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 1ffff1100fdf8f33 RCX: dffffc0000000000 RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff88807efc78c0 RBP: ffffc900047375d0 R08: 0000000000000003 R09: fffff520008e6e8c R10: dffffc0000000000 R11: fffff520008e6e8c R12: 1ffff1100fdf8f18 R13: ffff88807efc7998 R14: 0000000000000000 R15: ffff88807efc7930 FS: 0000000000000000(0000) GS:ffff8880b8900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000020002a80 CR3: 0000000022f62000 CR4: 00000000003506f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> addrconf_ifdown+0x15d/0x1bd0 net/ipv6/addrconf.c:3856 addrconf_notify+0x3cb/0x1020 notifier_call_chain+0x19f/0x3e0 kernel/notifier.c:93 call_netdevice_notifiers_extack net/core/dev.c:2032 [inline] call_netdevice_notifiers net/core/dev.c:2046 [inline] unregister_netdevice_many_notify+0xd81/0x1c40 net/core/dev.c:11352 unregister_netdevice_many net/core/dev.c:11414 [inline] unregister_netdevice_queue+0x303/0x370 net/core/dev.c:11289 unregister_netdevice include/linux/netdevice.h:3129 [inline] __tun_detach+0x6b9/0x1600 drivers/net/tun.c:685 tun_detach drivers/net/tun.c:701 [inline] tun_chr_close+0x108/0x1b0 drivers/net/tun.c:3510 __fput+0x24a/0x8a0 fs/file_table.c:422 task_work_run+0x24f/0x310 kernel/task_work.c:228 exit_task_work include/linux/task_work.h:40 [inline] do_exit+0xa2f/0x27f0 kernel/exit.c:882 do_group_exit+0x207/0x2c0 kernel/exit.c:1031 __do_sys_exit_group kernel/exit.c:1042 [inline] __se_sys_exit_group kernel/exit.c:1040 [inline] __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1040 x64_sys_call+0x2634/0x2640 arch/x86/include/generated/asm/syscalls_64.h:232 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7f1acc77def9 Code: Unable to access opcode bytes at 0x7f1acc77decf. RSP: 002b:00007ffeb26fa738 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f1acc77def9 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000043 RBP: 00007f1acc7dd508 R08: 00007ffeb26f84d7 R09: 0000000000000003 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001 R13: 0000000000000003 R14: 00000000ffffffff R15: 00007ffeb26fa8e0 </TASK> Modules linked in: ---[ end trace 0000000000000000 ]--- RIP: 0010:rt6_uncached_list_flush_dev net/ipv6/route.c:177 [inline] RIP: 0010:rt6_disable_ip+0x33e/0x7e0 net/ipv6/route.c:4914 Code: 41 80 3c 04 00 74 0a e8 90 d0 9b f7 48 8b 7c 24 08 48 8b 07 48 89 44 24 10 4c 89 f0 48 c1 e8 03 48 b9 00 00 00 00 00 fc ff df <80> 3c 08 00 74 08 4c 89 f7 e8 64 d0 9b f7 48 8b 44 24 18 49 39 06 RSP: 0018:ffffc900047374e0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: 1ffff1100fdf8f33 RCX: dffffc0000000000 RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff88807efc78c0 R ---truncated---",
      "id": "CVE-2024-47707",
      "published": "2024-10-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "3765b71d-b457-4b05-8bf6-149e0f693b5a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Check link_res->hpo_dp_link_enc before using it [WHAT & HOW] Functions dp_enable_link_phy and dp_disable_link_phy can pass link_res without initializing hpo_dp_link_enc and it is necessary to check for null before dereferencing. This fixes 2 FORWARD_NULL issues reported by Coverity.",
      "id": "CVE-2024-47704",
      "published": "2024-10-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T13:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:57Z"
      },
      "bom-ref": "5c0913b0-736b-45b6-81c1-8c752fa6bba1",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, lsm: Add check for BPF LSM return value A bpf prog returning a positive number attached to file_alloc_security hook makes kernel panic. This happens because file system can not filter out the positive number returned by the LSM prog using IS_ERR, and misinterprets this positive number as a file pointer. Given that hook file_alloc_security never returned positive number before the introduction of BPF LSM, and other BPF LSM hooks may encounter similar issues, this patch adds LSM return value check in verifier, to ensure no unexpected value is returned.",
      "id": "CVE-2024-47703",
      "published": "2024-10-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-24T13:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "ebc156c1-eefc-4ad9-910d-857545e42a6b",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread() syzbot reports a f2fs bug as below: __dump_stack lib/dump_stack.c:88 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114 print_report+0xe8/0x550 mm/kasan/report.c:491 kasan_report+0x143/0x180 mm/kasan/report.c:601 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189 instrument_atomic_read_write include/linux/instrumented.h:96 [inline] atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:252 [inline] __refcount_add include/linux/refcount.h:184 [inline] __refcount_inc include/linux/refcount.h:241 [inline] refcount_inc include/linux/refcount.h:258 [inline] get_task_struct include/linux/sched/task.h:118 [inline] kthread_stop+0xca/0x630 kernel/kthread.c:704 f2fs_stop_gc_thread+0x65/0xb0 fs/f2fs/gc.c:210 f2fs_do_shutdown+0x192/0x540 fs/f2fs/file.c:2283 f2fs_ioc_shutdown fs/f2fs/file.c:2325 [inline] __f2fs_ioctl+0x443a/0xbe60 fs/f2fs/file.c:4325 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f The root cause is below race condition, it may cause use-after-free issue in sbi->gc_th pointer. - remount - f2fs_remount - f2fs_stop_gc_thread - kfree(gc_th) - f2fs_ioc_shutdown - f2fs_do_shutdown - f2fs_stop_gc_thread - kthread_stop(gc_th->f2fs_gc_task) : sbi->gc_thread = NULL; We will call f2fs_do_shutdown() in two paths: - for f2fs_ioc_shutdown() path, we should grab sb->s_umount semaphore for fixing. - for f2fs_shutdown() path, it's safe since caller has already grabbed sb->s_umount semaphore.",
      "id": "CVE-2024-47691",
      "published": "2024-10-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T20:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "9c060d3c-ddb2-4d26-86ab-14e7b51a25a0",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Skip Recompute DSC Params if no Stream on Link [why] Encounter NULL pointer dereference uner mst + dsc setup. BUG: kernel NULL pointer dereference, address: 0000000000000008 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2 Hardware name: LENOVO 20NKS01Y00/20NKS01Y00, BIOS R12ET61W(1.31 ) 07/28/2022 RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper] Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8> RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293 RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224 RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280 RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850 R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000 R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224 FS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0 Call Trace: <TASK> ? __die+0x23/0x70 ? page_fault_oops+0x171/0x4e0 ? plist_add+0xbe/0x100 ? exc_page_fault+0x7c/0x180 ? asm_exc_page_fault+0x26/0x30 ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026] compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054] drm_atomic_check_only+0x5c5/0xa40 drm_mode_atomic_ioctl+0x76e/0xbc0 [how] dsc recompute should be skipped if no mode change detected on the new request. If detected, keep checking whether the stream is already on current state or not.",
      "id": "CVE-2024-47683",
      "published": "2024-10-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-24T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:54:59Z"
      },
      "bom-ref": "cd69ac85-f3ba-463f-86f4-b021d7c04fc1",
      "cwes": [
        203
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: icmp: change the order of rate limits ICMP messages are ratelimited : After the blamed commits, the two rate limiters are applied in this order: 1) host wide ratelimit (icmp_global_allow()) 2) Per destination ratelimit (inetpeer based) In order to avoid side-channels attacks, we need to apply the per destination check first. This patch makes the following change : 1) icmp_global_allow() checks if the host wide limit is reached. But credits are not yet consumed. This is deferred to 3) 2) The per destination limit is checked/updated. This might add a new node in inetpeer tree. 3) icmp_global_consume() consumes tokens if prior operations succeeded. This means that host wide ratelimit is still effective in keeping inetpeer tree small even under DDOS. As a bonus, I removed icmp_global.lock as the fast path can use a lock-free operation.",
      "id": "CVE-2024-47678",
      "published": "2024-10-21T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-10-23T17:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "96077c9a-f42f-4612-b9e4-c28711658dc4",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: uprobe: avoid out-of-bounds memory access of fetching args Uprobe needs to fetch args into a percpu buffer, and then copy to ring buffer to avoid non-atomic context problem. Sometimes user-space strings, arrays can be very large, but the size of percpu buffer is only page size. And store_trace_args() won't check whether these data exceeds a single page or not, caused out-of-bounds memory access. It could be reproduced by following steps: 1. build kernel with CONFIG_KASAN enabled 2. save follow program as test.c ``` \\#include <stdio.h> \\#include <stdlib.h> \\#include <string.h> // If string length large than MAX_STRING_SIZE, the fetch_store_strlen() // will return 0, cause __get_data_size() return shorter size, and // store_trace_args() will not trigger out-of-bounds access. // So make string length less than 4096. \\#define STRLEN 4093 void generate_string(char *str, int n) { int i; for (i = 0; i < n; ++i) { char c = i % 26 + 'a'; str[i] = c; } str[n-1] = '\\0'; } void print_string(char *str) { printf(\"%s\\n\", str); } int main() { char tmp[STRLEN]; generate_string(tmp, STRLEN); print_string(tmp); return 0; } ``` 3. compile program `gcc -o test test.c` 4. get the offset of `print_string()` ``` objdump -t test | grep -w print_string 0000000000401199 g F .text 000000000000001b print_string ``` 5. configure uprobe with offset 0x1199 ``` off=0x1199 cd /sys/kernel/debug/tracing/ echo \"p /root/test:${off} arg1=+0(%di):ustring arg2=\\$comm arg3=+0(%di):ustring\" > uprobe_events echo 1 > events/uprobes/enable echo 1 > tracing_on ``` 6. run `test`, and kasan will report error. ================================================================== BUG: KASAN: use-after-free in strncpy_from_user+0x1d6/0x1f0 Write of size 8 at addr ffff88812311c004 by task test/499CPU: 0 UID: 0 PID: 499 Comm: test Not tainted 6.12.0-rc3+ #18 Hardware name: Red Hat KVM, BIOS 1.16.0-4.al8 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x55/0x70 print_address_description.constprop.0+0x27/0x310 kasan_report+0x10f/0x120 ? strncpy_from_user+0x1d6/0x1f0 strncpy_from_user+0x1d6/0x1f0 ? rmqueue.constprop.0+0x70d/0x2ad0 process_fetch_insn+0xb26/0x1470 ? __pfx_process_fetch_insn+0x10/0x10 ? _raw_spin_lock+0x85/0xe0 ? __pfx__raw_spin_lock+0x10/0x10 ? __pte_offset_map+0x1f/0x2d0 ? unwind_next_frame+0xc5f/0x1f80 ? arch_stack_walk+0x68/0xf0 ? is_bpf_text_address+0x23/0x30 ? kernel_text_address.part.0+0xbb/0xd0 ? __kernel_text_address+0x66/0xb0 ? unwind_get_return_address+0x5e/0xa0 ? __pfx_stack_trace_consume_entry+0x10/0x10 ? arch_stack_walk+0xa2/0xf0 ? _raw_spin_lock_irqsave+0x8b/0xf0 ? __pfx__raw_spin_lock_irqsave+0x10/0x10 ? depot_alloc_stack+0x4c/0x1f0 ? _raw_spin_unlock_irqrestore+0xe/0x30 ? stack_depot_save_flags+0x35d/0x4f0 ? kasan_save_stack+0x34/0x50 ? kasan_save_stack+0x24/0x50 ? mutex_lock+0x91/0xe0 ? __pfx_mutex_lock+0x10/0x10 prepare_uprobe_buffer.part.0+0x2cd/0x500 uprobe_dispatcher+0x2c3/0x6a0 ? __pfx_uprobe_dispatcher+0x10/0x10 ? __kasan_slab_alloc+0x4d/0x90 handler_chain+0xdd/0x3e0 handle_swbp+0x26e/0x3d0 ? __pfx_handle_swbp+0x10/0x10 ? uprobe_pre_sstep_notifier+0x151/0x1b0 irqentry_exit_to_user_mode+0xe2/0x1b0 asm_exc_int3+0x39/0x40 RIP: 0033:0x401199 Code: 01 c2 0f b6 45 fb 88 02 83 45 fc 01 8b 45 fc 3b 45 e4 7c b7 8b 45 e4 48 98 48 8d 50 ff 48 8b 45 e8 48 01 d0 ce RSP: 002b:00007ffdf00576a8 EFLAGS: 00000206 RAX: 00007ffdf00576b0 RBX: 0000000000000000 RCX: 0000000000000ff2 RDX: 0000000000000ffc RSI: 0000000000000ffd RDI: 00007ffdf00576b0 RBP: 00007ffdf00586b0 R08: 00007feb2f9c0d20 R09: 00007feb2f9c0d20 R10: 0000000000000001 R11: 0000000000000202 R12: 0000000000401040 R13: 00007ffdf0058780 R14: 0000000000000000 R15: 0000000000000000 </TASK> This commit enforces the buffer's maxlen less than a page-size to avoid store_trace_args() out-of-memory access.",
      "id": "CVE-2024-50067",
      "published": "2024-10-28T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB_SERVER not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "09f97f7c-5b90-48a0-8915-2b440af08f70",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix user-after-free from session log off There is racy issue between smb2 session log off and smb2 session setup. It will cause user-after-free from session log off. This add session_lock when setting SMB2_SESSION_EXPIRED and referece count to session struct not to free session while it is being used.",
      "id": "CVE-2024-50086",
      "published": "2024-10-29T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-25T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_N_GSM is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e5a6955b-94be-40d4-87e9-9ff5bf418378",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: tty: n_gsm: Fix use-after-free in gsm_cleanup_mux BUG: KASAN: slab-use-after-free in gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm] Read of size 8 at addr ffff88815fe99c00 by task poc/3379 CPU: 0 UID: 0 PID: 3379 Comm: poc Not tainted 6.11.0+ #56 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Call Trace: <TASK> gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm] __pfx_gsm_cleanup_mux+0x10/0x10 drivers/tty/n_gsm.c:3124 [n_gsm] __pfx_sched_clock_cpu+0x10/0x10 kernel/sched/clock.c:389 update_load_avg+0x1c1/0x27b0 kernel/sched/fair.c:4500 __pfx_min_vruntime_cb_rotate+0x10/0x10 kernel/sched/fair.c:846 __rb_insert_augmented+0x492/0xbf0 lib/rbtree.c:161 gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm] _raw_spin_lock_irqsave+0x92/0xf0 arch/x86/include/asm/atomic.h:107 __pfx_gsmld_ioctl+0x10/0x10 drivers/tty/n_gsm.c:3822 [n_gsm] ktime_get+0x5e/0x140 kernel/time/timekeeping.c:195 ldsem_down_read+0x94/0x4e0 arch/x86/include/asm/atomic64_64.h:79 __pfx_ldsem_down_read+0x10/0x10 drivers/tty/tty_ldsem.c:338 __pfx_do_vfs_ioctl+0x10/0x10 fs/ioctl.c:805 tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818 Allocated by task 65: gsm_data_alloc.constprop.0+0x27/0x190 drivers/tty/n_gsm.c:926 [n_gsm] gsm_send+0x2c/0x580 drivers/tty/n_gsm.c:819 [n_gsm] gsm1_receive+0x547/0xad0 drivers/tty/n_gsm.c:3038 [n_gsm] gsmld_receive_buf+0x176/0x280 drivers/tty/n_gsm.c:3609 [n_gsm] tty_ldisc_receive_buf+0x101/0x1e0 drivers/tty/tty_buffer.c:391 tty_port_default_receive_buf+0x61/0xa0 drivers/tty/tty_port.c:39 flush_to_ldisc+0x1b0/0x750 drivers/tty/tty_buffer.c:445 process_scheduled_works+0x2b0/0x10d0 kernel/workqueue.c:3229 worker_thread+0x3dc/0x950 kernel/workqueue.c:3391 kthread+0x2a3/0x370 kernel/kthread.c:389 ret_from_fork+0x2d/0x70 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:257 Freed by task 3367: kfree+0x126/0x420 mm/slub.c:4580 gsm_cleanup_mux+0x36c/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm] gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm] tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818 [Analysis] gsm_msg on the tx_ctrl_list or tx_data_list of gsm_mux can be freed by multi threads through ioctl,which leads to the occurrence of uaf. Protect it by gsm tx lock.",
      "id": "CVE-2024-50073",
      "published": "2024-10-29T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:00Z"
      },
      "bom-ref": "4c30e3d2-786b-4e35-8a91-1ad495afe925",
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/bugs: Use code segment selector for VERW operand Robert Gill reported below #GP in 32-bit mode when dosemu software was executing vm86() system call: general protection fault: 0000 [#1] PREEMPT SMP CPU: 4 PID: 4610 Comm: dosemu.bin Not tainted 6.6.21-gentoo-x86 #1 Hardware name: Dell Inc. PowerEdge 1950/0H723K, BIOS 2.7.0 10/30/2010 EIP: restore_all_switch_stack+0xbe/0xcf EAX: 00000000 EBX: 00000000 ECX: 00000000 EDX: 00000000 ESI: 00000000 EDI: 00000000 EBP: 00000000 ESP: ff8affdc DS: 0000 ES: 0000 FS: 0000 GS: 0033 SS: 0068 EFLAGS: 00010046 CR0: 80050033 CR2: 00c2101c CR3: 04b6d000 CR4: 000406d0 Call Trace: show_regs+0x70/0x78 die_addr+0x29/0x70 exc_general_protection+0x13c/0x348 exc_bounds+0x98/0x98 handle_exception+0x14d/0x14d exc_bounds+0x98/0x98 restore_all_switch_stack+0xbe/0xcf exc_bounds+0x98/0x98 restore_all_switch_stack+0xbe/0xcf This only happens in 32-bit mode when VERW based mitigations like MDS/RFDS are enabled. This is because segment registers with an arbitrary user value can result in #GP when executing VERW. Intel SDM vol. 2C documents the following behavior for VERW instruction: #GP(0) - If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. CLEAR_CPU_BUFFERS macro executes VERW instruction before returning to user space. Use %cs selector to reference VERW operand. This ensures VERW will not #GP for an arbitrary user %ds. [ mingo: Fixed the SOB chain. ]",
      "id": "CVE-2024-50072",
      "published": "2024-10-29T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:02Z"
      },
      "bom-ref": "cb5d60af-7225-4ee5-aee0-c6151b97c4b0",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Use raw_spinlock_t in ringbuf The function __bpf_ringbuf_reserve is invoked from a tracepoint, which disables preemption. Using spinlock_t in this context can lead to a \"sleep in atomic\" warning in the RT variant. This issue is illustrated in the example below: BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48 in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 556208, name: test_progs preempt_count: 1, expected: 0 RCU nest depth: 1, expected: 1 INFO: lockdep is turned off. Preemption disabled at: [<ffffd33a5c88ea44>] migrate_enable+0xc0/0x39c CPU: 7 PID: 556208 Comm: test_progs Tainted: G Hardware name: Qualcomm SA8775P Ride (DT) Call trace: dump_backtrace+0xac/0x130 show_stack+0x1c/0x30 dump_stack_lvl+0xac/0xe8 dump_stack+0x18/0x30 __might_resched+0x3bc/0x4fc rt_spin_lock+0x8c/0x1a4 __bpf_ringbuf_reserve+0xc4/0x254 bpf_ringbuf_reserve_dynptr+0x5c/0xdc bpf_prog_ac3d15160d62622a_test_read_write+0x104/0x238 trace_call_bpf+0x238/0x774 perf_call_bpf_enter.isra.0+0x104/0x194 perf_syscall_enter+0x2f8/0x510 trace_sys_enter+0x39c/0x564 syscall_trace_enter+0x220/0x3c0 do_el0_svc+0x138/0x1dc el0_svc+0x54/0x130 el0t_64_sync_handler+0x134/0x150 el0t_64_sync+0x17c/0x180 Switch the spinlock to raw_spinlock_t to avoid this error.",
      "id": "CVE-2024-50138",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:03Z"
      },
      "bom-ref": "69a731e2-8865-4917-915d-2134d2d2c4cd",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-pci: fix race condition between reset and nvme_dev_disable() nvme_dev_disable() modifies the dev->online_queues field, therefore nvme_pci_update_nr_queues() should avoid racing against it, otherwise we could end up passing invalid values to blk_mq_update_nr_hw_queues(). WARNING: CPU: 39 PID: 61303 at drivers/pci/msi/api.c:347 pci_irq_get_affinity+0x187/0x210 Workqueue: nvme-reset-wq nvme_reset_work [nvme] RIP: 0010:pci_irq_get_affinity+0x187/0x210 Call Trace: <TASK> ? blk_mq_pci_map_queues+0x87/0x3c0 ? pci_irq_get_affinity+0x187/0x210 blk_mq_pci_map_queues+0x87/0x3c0 nvme_pci_map_queues+0x189/0x460 [nvme] blk_mq_update_nr_hw_queues+0x2a/0x40 nvme_reset_work+0x1be/0x2a0 [nvme] Fix the bug by locking the shutdown_lock mutex before using dev->online_queues. Give up if nvme_dev_disable() is running or if it has been executed already.",
      "id": "CVE-2024-50135",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T14:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "3c549600-6bee-4b30-b413-0c0993ed79f9",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: SCO: Fix UAF on sco_sock_timeout conn->sk maybe have been unlinked/freed while waiting for sco_conn_lock so this checks if the conn->sk is still valid by checking if it part of sco_sk_list.",
      "id": "CVE-2024-50125",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "634ec3b8-5bf1-40d3-8311-c0a407bc11ca",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net In the normal case, when we excute `echo 0 > /proc/fs/nfsd/threads`, the function `nfs4_state_destroy_net` in `nfs4_state_shutdown_net` will release all resources related to the hashed `nfs4_client`. If the `nfsd_client_shrinker` is running concurrently, the `expire_client` function will first unhash this client and then destroy it. This can lead to the following warning. Additionally, numerous use-after-free errors may occur as well. nfsd_client_shrinker echo 0 > /proc/fs/nfsd/threads expire_client nfsd_shutdown_net unhash_client ... nfs4_state_shutdown_net /* won't wait shrinker exit */ /* cancel_work(&nn->nfsd_shrinker_work) * nfsd_file for this /* won't destroy unhashed client1 */ * client1 still alive nfs4_state_destroy_net */ nfsd_file_cache_shutdown /* trigger warning */ kmem_cache_destroy(nfsd_file_slab) kmem_cache_destroy(nfsd_file_mark_slab) /* release nfsd_file and mark */ __destroy_client ==================================================================== BUG nfsd_file (Not tainted): Objects remaining in nfsd_file on __kmem_cache_shutdown() -------------------------------------------------------------------- CPU: 4 UID: 0 PID: 764 Comm: sh Not tainted 6.12.0-rc3+ #1 dump_stack_lvl+0x53/0x70 slab_err+0xb0/0xf0 __kmem_cache_shutdown+0x15c/0x310 kmem_cache_destroy+0x66/0x160 nfsd_file_cache_shutdown+0xac/0x210 [nfsd] nfsd_destroy_serv+0x251/0x2a0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e ==================================================================== BUG nfsd_file_mark (Tainted: G B W ): Objects remaining nfsd_file_mark on __kmem_cache_shutdown() -------------------------------------------------------------------- dump_stack_lvl+0x53/0x70 slab_err+0xb0/0xf0 __kmem_cache_shutdown+0x15c/0x310 kmem_cache_destroy+0x66/0x160 nfsd_file_cache_shutdown+0xc8/0x210 [nfsd] nfsd_destroy_serv+0x251/0x2a0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e To resolve this issue, cancel `nfsd_shrinker_work` using synchronous mode in nfs4_state_shutdown_net.",
      "id": "CVE-2024-50121",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "justification": "requires_dependency",
        "state": "not_affected"
      },
      "bom-ref": "89cff95c-2c71-4221-bec8-e2d7106fa2a9",
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/lam: Disable ADDRESS_MASKING in most cases Linear Address Masking (LAM) has a weakness related to transient execution as described in the SLAM paper[1]. Unless Linear Address Space Separation (LASS) is enabled this weakness may be exploitable. Until kernel adds support for LASS[2], only allow LAM for COMPILE_TEST, or when speculation mitigations have been disabled at compile time, otherwise keep LAM disabled. There are no processors in market that support LAM yet, so currently nobody is affected by this issue. [1] SLAM: https://download.vusec.net/papers/slam_sp24.pdf [2] LASS: https://lore.kernel.org/lkml/20230609183632.48706-1-alexander.shishkin@linux.intel.com/ [ dhansen: update SPECULATION_MITIGATIONS -> CPU_MITIGATIONS ]",
      "id": "CVE-2024-50112",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T20:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:05Z"
      },
      "bom-ref": "84317490-c2e7-4aac-9dd1-9f0fb3a4ad09",
      "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: Enable IRQ if do_ale() triggered in irq-enabled context Unaligned access exception can be triggered in irq-enabled context such as user mode, in this case do_ale() may call get_user() which may cause sleep. Then we will get: BUG: sleeping function called from invalid context at arch/loongarch/kernel/access-helper.h:7 in_atomic(): 0, irqs_disabled(): 1, non_block: 0, pid: 129, name: modprobe preempt_count: 0, expected: 0 RCU nest depth: 0, expected: 0 CPU: 0 UID: 0 PID: 129 Comm: modprobe Tainted: G W 6.12.0-rc1+ #1723 Tainted: [W]=WARN Stack : 9000000105e0bd48 0000000000000000 9000000003803944 9000000105e08000 9000000105e0bc70 9000000105e0bc78 0000000000000000 0000000000000000 9000000105e0bc78 0000000000000001 9000000185e0ba07 9000000105e0b890 ffffffffffffffff 9000000105e0bc78 73924b81763be05b 9000000100194500 000000000000020c 000000000000000a 0000000000000000 0000000000000003 00000000000023f0 00000000000e1401 00000000072f8000 0000007ffbb0e260 0000000000000000 0000000000000000 9000000005437650 90000000055d5000 0000000000000000 0000000000000003 0000007ffbb0e1f0 0000000000000000 0000005567b00490 0000000000000000 9000000003803964 0000007ffbb0dfec 00000000000000b0 0000000000000007 0000000000000003 0000000000071c1d ... Call Trace: [<9000000003803964>] show_stack+0x64/0x1a0 [<9000000004c57464>] dump_stack_lvl+0x74/0xb0 [<9000000003861ab4>] __might_resched+0x154/0x1a0 [<900000000380c96c>] emulate_load_store_insn+0x6c/0xf60 [<9000000004c58118>] do_ale+0x78/0x180 [<9000000003801bc8>] handle_ale+0x128/0x1e0 So enable IRQ if unaligned access exception is triggered in irq-enabled context to fix it.",
      "id": "CVE-2024-50111",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T20:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "9555a835-e27e-404c-b2c5-84fbd18da321",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Disable PSR-SU on Parade 08-01 TCON too Stuart Hayhurst has found that both at bootup and fullscreen VA-API video is leading to black screens for around 1 second and kernel WARNING [1] traces when calling dmub_psr_enable() with Parade 08-01 TCON. These symptoms all go away with PSR-SU disabled for this TCON, so disable it for now while DMUB traces [2] from the failure can be analyzed and the failure state properly root caused. (cherry picked from commit afb634a6823d8d9db23c5fb04f79c5549349628b)",
      "id": "CVE-2024-50108",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-08T21:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "7d6e7c0b-7e6b-4273-b789-9612ea2326e9",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: fix race between laundromat and free_stateid There is a race between laundromat handling of revoked delegations and a client sending free_stateid operation. Laundromat thread finds that delegation has expired and needs to be revoked so it marks the delegation stid revoked and it puts it on a reaper list but then it unlock the state lock and the actual delegation revocation happens without the lock. Once the stid is marked revoked a racing free_stateid processing thread does the following (1) it calls list_del_init() which removes it from the reaper list and (2) frees the delegation stid structure. The laundromat thread ends up not calling the revoke_delegation() function for this particular delegation but that means it will no release the lock lease that exists on the file. Now, a new open for this file comes in and ends up finding that lease list isn't empty and calls nfsd_breaker_owns_lease() which ends up trying to derefence a freed delegation stateid. Leading to the followint use-after-free KASAN warning: kernel: ================================================================== kernel: BUG: KASAN: slab-use-after-free in nfsd_breaker_owns_lease+0x140/0x160 [nfsd] kernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205 kernel: kernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9 kernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024 kernel: Call trace: kernel: dump_backtrace+0x98/0x120 kernel: show_stack+0x1c/0x30 kernel: dump_stack_lvl+0x80/0xe8 kernel: print_address_description.constprop.0+0x84/0x390 kernel: print_report+0xa4/0x268 kernel: kasan_report+0xb4/0xf8 kernel: __asan_report_load8_noabort+0x1c/0x28 kernel: nfsd_breaker_owns_lease+0x140/0x160 [nfsd] kernel: nfsd_file_do_acquire+0xb3c/0x11d0 [nfsd] kernel: nfsd_file_acquire_opened+0x84/0x110 [nfsd] kernel: nfs4_get_vfs_file+0x634/0x958 [nfsd] kernel: nfsd4_process_open2+0xa40/0x1a40 [nfsd] kernel: nfsd4_open+0xa08/0xe80 [nfsd] kernel: nfsd4_proc_compound+0xb8c/0x2130 [nfsd] kernel: nfsd_dispatch+0x22c/0x718 [nfsd] kernel: svc_process_common+0x8e8/0x1960 [sunrpc] kernel: svc_process+0x3d4/0x7e0 [sunrpc] kernel: svc_handle_xprt+0x828/0xe10 [sunrpc] kernel: svc_recv+0x2cc/0x6a8 [sunrpc] kernel: nfsd+0x270/0x400 [nfsd] kernel: kthread+0x288/0x310 kernel: ret_from_fork+0x10/0x20 This patch proposes a fixed that's based on adding 2 new additional stid's sc_status values that help coordinate between the laundromat and other operations (nfsd4_free_stateid() and nfsd4_delegreturn()). First to make sure, that once the stid is marked revoked, it is not removed by the nfsd4_free_stateid(), the laundromat take a reference on the stateid. Then, coordinating whether the stid has been put on the cl_revoked list or we are processing FREE_STATEID and need to make sure to remove it from the list, each check that state and act accordingly. If laundromat has added to the cl_revoke list before the arrival of FREE_STATEID, then nfsd4_free_stateid() knows to remove it from the list. If nfsd4_free_stateid() finds that operations arrived before laundromat has placed it on cl_revoke list, it marks the state freed and then laundromat will no longer add it to the list. Also, for nfsd4_delegreturn() when looking for the specified stid, we need to access stid that are marked removed or freeable, it means the laundromat has started processing it but hasn't finished and this delegreturn needs to return nfserr_deleg_revoked and not nfserr_bad_stateid. The latter will not trigger a FREE_STATEID and the lack of it will leave this stid on the cl_revoked list indefinitely.",
      "id": "CVE-2024-50106",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:06Z"
      },
      "bom-ref": "fad8c663-c16b-4bea-b982-64d714e8f31b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Set SDEV_OFFLINE when UFS is shut down There is a history of deadlock if reboot is performed at the beginning of booting. SDEV_QUIESCE was set for all LU's scsi_devices by UFS shutdown, and at that time the audio driver was waiting on blk_mq_submit_bio() holding a mutex_lock while reading the fw binary. After that, a deadlock issue occurred while audio driver shutdown was waiting for mutex_unlock of blk_mq_submit_bio(). To solve this, set SDEV_OFFLINE for all LUs except WLUN, so that any I/O that comes down after a UFS shutdown will return an error. [ 31.907781]I[0: swapper/0: 0] 1 130705007 1651079834 11289729804 0 D( 2) 3 ffffff882e208000 * init [device_shutdown] [ 31.907793]I[0: swapper/0: 0] Mutex: 0xffffff8849a2b8b0: owner[0xffffff882e28cb00 kworker/6:0 :49] [ 31.907806]I[0: swapper/0: 0] Call trace: [ 31.907810]I[0: swapper/0: 0] __switch_to+0x174/0x338 [ 31.907819]I[0: swapper/0: 0] __schedule+0x5ec/0x9cc [ 31.907826]I[0: swapper/0: 0] schedule+0x7c/0xe8 [ 31.907834]I[0: swapper/0: 0] schedule_preempt_disabled+0x24/0x40 [ 31.907842]I[0: swapper/0: 0] __mutex_lock+0x408/0xdac [ 31.907849]I[0: swapper/0: 0] __mutex_lock_slowpath+0x14/0x24 [ 31.907858]I[0: swapper/0: 0] mutex_lock+0x40/0xec [ 31.907866]I[0: swapper/0: 0] device_shutdown+0x108/0x280 [ 31.907875]I[0: swapper/0: 0] kernel_restart+0x4c/0x11c [ 31.907883]I[0: swapper/0: 0] __arm64_sys_reboot+0x15c/0x280 [ 31.907890]I[0: swapper/0: 0] invoke_syscall+0x70/0x158 [ 31.907899]I[0: swapper/0: 0] el0_svc_common+0xb4/0xf4 [ 31.907909]I[0: swapper/0: 0] do_el0_svc+0x2c/0xb0 [ 31.907918]I[0: swapper/0: 0] el0_svc+0x34/0xe0 [ 31.907928]I[0: swapper/0: 0] el0t_64_sync_handler+0x68/0xb4 [ 31.907937]I[0: swapper/0: 0] el0t_64_sync+0x1a0/0x1a4 [ 31.908774]I[0: swapper/0: 0] 49 0 11960702 11236868007 0 D( 2) 6 ffffff882e28cb00 * kworker/6:0 [__bio_queue_enter] [ 31.908783]I[0: swapper/0: 0] Call trace: [ 31.908788]I[0: swapper/0: 0] __switch_to+0x174/0x338 [ 31.908796]I[0: swapper/0: 0] __schedule+0x5ec/0x9cc [ 31.908803]I[0: swapper/0: 0] schedule+0x7c/0xe8 [ 31.908811]I[0: swapper/0: 0] __bio_queue_enter+0xb8/0x178 [ 31.908818]I[0: swapper/0: 0] blk_mq_submit_bio+0x194/0x67c [ 31.908827]I[0: swapper/0: 0] __submit_bio+0xb8/0x19c",
      "id": "CVE-2024-50098",
      "published": "2024-11-05T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-12T16:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:08Z"
      },
      "bom-ref": "f77226ab-55ea-4725-b04f-9aff9a3cf83a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: dm vdo: don't refer to dedupe_context after releasing it Clear the dedupe_context pointer in a data_vio whenever ownership of the context is lost, so that vdo can't examine it accidentally.",
      "id": "CVE-2024-50091",
      "published": "2024-11-05T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-12T21:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:09Z"
      },
      "bom-ref": "af3c5b3e-a6eb-4eea-8eb3-2e036906e3f8",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/oa: Fix overflow in oa batch buffer By default xe_bb_create_job() appends a MI_BATCH_BUFFER_END to batch buffer, this is not a problem if batch buffer is only used once but oa reuses the batch buffer for the same metric and at each call it appends a MI_BATCH_BUFFER_END, printing the warning below and then overflowing. [ 381.072016] ------------[ cut here ]------------ [ 381.072019] xe 0000:00:02.0: [drm] Assertion `bb->len * 4 + bb_prefetch(q->gt) <= size` failed! platform: LUNARLAKE subplatform: 1 graphics: Xe2_LPG / Xe2_HPG 20.04 step B0 media: Xe2_LPM / Xe2_HPM 20.00 step B0 tile: 0 VRAM 0 B GT: 0 type 1 So here checking if batch buffer already have MI_BATCH_BUFFER_END if not append it. v2: - simply fix, suggestion from Ashutosh (cherry picked from commit 9ba0e0f30ca42a98af3689460063edfb6315718a)",
      "id": "CVE-2024-50090",
      "published": "2024-11-05T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-18T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:11Z"
      },
      "bom-ref": "55748936-ecca-4020-a5e2-15bca07ab264",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: support non-r10 register spill/fill to/from stack in precision tracking Use instruction (jump) history to record instructions that performed register spill/fill to/from stack, regardless if this was done through read-only r10 register, or any other register after copying r10 into it *and* potentially adjusting offset. To make this work reliably, we push extra per-instruction flags into instruction history, encoding stack slot index (spi) and stack frame number in extra 10 bit flags we take away from prev_idx in instruction history. We don't touch idx field for maximum performance, as it's checked most frequently during backtracking. This change removes basically the last remaining practical limitation of precision backtracking logic in BPF verifier. It fixes known deficiencies, but also opens up new opportunities to reduce number of verified states, explored in the subsequent patches. There are only three differences in selftests' BPF object files according to veristat, all in the positive direction (less states). File Program Insns (A) Insns (B) Insns (DIFF) States (A) States (B) States (DIFF) -------------------------------------- ------------- --------- --------- ------------- ---------- ---------- ------------- test_cls_redirect_dynptr.bpf.linked3.o cls_redirect 2987 2864 -123 (-4.12%) 240 231 -9 (-3.75%) xdp_synproxy_kern.bpf.linked3.o syncookie_tc 82848 82661 -187 (-0.23%) 5107 5073 -34 (-0.67%) xdp_synproxy_kern.bpf.linked3.o syncookie_xdp 85116 84964 -152 (-0.18%) 5162 5130 -32 (-0.62%) Note, I avoided renaming jmp_history to more generic insn_hist to minimize number of lines changed and potential merge conflicts between bpf and bpf-next trees. Notice also cur_hist_entry pointer reset to NULL at the beginning of instruction verification loop. This pointer avoids the problem of relying on last jump history entry's insn_idx to determine whether we already have entry for current instruction or not. It can happen that we added jump history entry because current instruction is_jmp_point(), but also we need to add instruction flags for stack access. In this case, we don't want to entries, so we need to reuse last added entry, if it is present. Relying on insn_idx comparison has the same ambiguity problem as the one that was fixed recently in [0], so we avoid that. [0] https://patchwork.kernel.org/project/netdevbpf/patch/20231110002638.4168352-3-andrii@kernel.org/",
      "id": "CVE-2023-52920",
      "published": "2024-11-05T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:12Z"
      },
      "bom-ref": "09257eec-df5b-4b68-9587-6f072fe7680c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fsl/fman: Fix refcount handling of fman-related devices In mac_probe() there are multiple calls to of_find_device_by_node(), fman_bind() and fman_port_bind() which takes references to of_dev->dev. Not all references taken by these calls are released later on error path in mac_probe() and in mac_remove() which lead to reference leaks. Add references release.",
      "id": "CVE-2024-50166",
      "published": "2024-11-07T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-22T16:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:14Z"
      },
      "bom-ref": "bb4ed2f0-bb8f-4e4f-9ce1-1524c5e2ee8b",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: Don't call cleanup on profile rollback failure When profile rollback fails in mlx5e_netdev_change_profile, the netdev profile var is left set to NULL. Avoid a crash when unloading the driver by not calling profile->cleanup in such a case. This was encountered while testing, with the original trigger that the wq rescuer thread creation got interrupted (presumably due to Ctrl+C-ing modprobe), which gets converted to ENOMEM (-12) by mlx5e_priv_init, the profile rollback also fails for the same reason (signal still active) so the profile is left as NULL, leading to a crash later in _mlx5e_remove. [ 732.473932] mlx5_core 0000:08:00.1: E-Switch: Unload vfs: mode(OFFLOADS), nvfs(2), necvfs(0), active vports(2) [ 734.525513] workqueue: Failed to create a rescuer kthread for wq \"mlx5e\": -EINTR [ 734.557372] mlx5_core 0000:08:00.1: mlx5e_netdev_init_profile:6235:(pid 6086): mlx5e_priv_init failed, err=-12 [ 734.559187] mlx5_core 0000:08:00.1 eth3: mlx5e_netdev_change_profile: new profile init failed, -12 [ 734.560153] workqueue: Failed to create a rescuer kthread for wq \"mlx5e\": -EINTR [ 734.589378] mlx5_core 0000:08:00.1: mlx5e_netdev_init_profile:6235:(pid 6086): mlx5e_priv_init failed, err=-12 [ 734.591136] mlx5_core 0000:08:00.1 eth3: mlx5e_netdev_change_profile: failed to rollback to orig profile, -12 [ 745.537492] BUG: kernel NULL pointer dereference, address: 0000000000000008 [ 745.538222] #PF: supervisor read access in kernel mode <snipped> [ 745.551290] Call Trace: [ 745.551590] <TASK> [ 745.551866] ? __die+0x20/0x60 [ 745.552218] ? page_fault_oops+0x150/0x400 [ 745.555307] ? exc_page_fault+0x79/0x240 [ 745.555729] ? asm_exc_page_fault+0x22/0x30 [ 745.556166] ? mlx5e_remove+0x6b/0xb0 [mlx5_core] [ 745.556698] auxiliary_bus_remove+0x18/0x30 [ 745.557134] device_release_driver_internal+0x1df/0x240 [ 745.557654] bus_remove_device+0xd7/0x140 [ 745.558075] device_del+0x15b/0x3c0 [ 745.558456] mlx5_rescan_drivers_locked.part.0+0xb1/0x2f0 [mlx5_core] [ 745.559112] mlx5_unregister_device+0x34/0x50 [mlx5_core] [ 745.559686] mlx5_uninit_one+0x46/0xf0 [mlx5_core] [ 745.560203] remove_one+0x4e/0xd0 [mlx5_core] [ 745.560694] pci_device_remove+0x39/0xa0 [ 745.561112] device_release_driver_internal+0x1df/0x240 [ 745.561631] driver_detach+0x47/0x90 [ 745.562022] bus_remove_driver+0x84/0x100 [ 745.562444] pci_unregister_driver+0x3b/0x90 [ 745.562890] mlx5_cleanup+0xc/0x1b [mlx5_core] [ 745.563415] __x64_sys_delete_module+0x14d/0x2f0 [ 745.563886] ? kmem_cache_free+0x1b0/0x460 [ 745.564313] ? lockdep_hardirqs_on_prepare+0xe2/0x190 [ 745.564825] do_syscall_64+0x6d/0x140 [ 745.565223] entry_SYSCALL_64_after_hwframe+0x4b/0x53 [ 745.565725] RIP: 0033:0x7f1579b1288b",
      "id": "CVE-2024-50146",
      "published": "2024-11-07T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-27T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "55a1f164-7fbd-483a-a3c6-c2dfe2800e1a",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: fix a UBSAN warning in DML2.1 When programming phantom pipe, since cursor_width is explicity set to 0, this causes calculation logic to trigger overflow for an unsigned int triggering the kernel's UBSAN check as below: [ 40.962845] UBSAN: shift-out-of-bounds in /tmp/amd.EfpumTkO/amd/amdgpu/../display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c:3312:34 [ 40.962849] shift exponent 4294967170 is too large for 32-bit type 'unsigned int' [ 40.962852] CPU: 1 PID: 1670 Comm: gnome-shell Tainted: G W OE 6.5.0-41-generic #41~22.04.2-Ubuntu [ 40.962854] Hardware name: Gigabyte Technology Co., Ltd. X670E AORUS PRO X/X670E AORUS PRO X, BIOS F21 01/10/2024 [ 40.962856] Call Trace: [ 40.962857] <TASK> [ 40.962860] dump_stack_lvl+0x48/0x70 [ 40.962870] dump_stack+0x10/0x20 [ 40.962872] __ubsan_handle_shift_out_of_bounds+0x1ac/0x360 [ 40.962878] calculate_cursor_req_attributes.cold+0x1b/0x28 [amdgpu] [ 40.963099] dml_core_mode_support+0x6b91/0x16bc0 [amdgpu] [ 40.963327] ? srso_alias_return_thunk+0x5/0x7f [ 40.963331] ? CalculateWatermarksMALLUseAndDRAMSpeedChangeSupport+0x18b8/0x2790 [amdgpu] [ 40.963534] ? srso_alias_return_thunk+0x5/0x7f [ 40.963536] ? dml_core_mode_support+0xb3db/0x16bc0 [amdgpu] [ 40.963730] dml2_core_calcs_mode_support_ex+0x2c/0x90 [amdgpu] [ 40.963906] ? srso_alias_return_thunk+0x5/0x7f [ 40.963909] ? dml2_core_calcs_mode_support_ex+0x2c/0x90 [amdgpu] [ 40.964078] core_dcn4_mode_support+0x72/0xbf0 [amdgpu] [ 40.964247] dml2_top_optimization_perform_optimization_phase+0x1d3/0x2a0 [amdgpu] [ 40.964420] dml2_build_mode_programming+0x23d/0x750 [amdgpu] [ 40.964587] dml21_validate+0x274/0x770 [amdgpu] [ 40.964761] ? srso_alias_return_thunk+0x5/0x7f [ 40.964763] ? resource_append_dpp_pipes_for_plane_composition+0x27c/0x3b0 [amdgpu] [ 40.964942] dml2_validate+0x504/0x750 [amdgpu] [ 40.965117] ? dml21_copy+0x95/0xb0 [amdgpu] [ 40.965291] ? srso_alias_return_thunk+0x5/0x7f [ 40.965295] dcn401_validate_bandwidth+0x4e/0x70 [amdgpu] [ 40.965491] update_planes_and_stream_state+0x38d/0x5c0 [amdgpu] [ 40.965672] update_planes_and_stream_v3+0x52/0x1e0 [amdgpu] [ 40.965845] ? srso_alias_return_thunk+0x5/0x7f [ 40.965849] dc_update_planes_and_stream+0x71/0xb0 [amdgpu] Fix this by adding a guard for checking cursor width before triggering the size calculation.",
      "id": "CVE-2024-50177",
      "published": "2024-11-08T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T23:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:15Z"
      },
      "bom-ref": "b6f94f5b-2894-4cb9-b0ba-afe19014d4ba",
      "description": "In the Linux kernel, the following vulnerability has been resolved: cpufreq: loongson3: Use raw_smp_processor_id() in do_service_request() Use raw_smp_processor_id() instead of plain smp_processor_id() in do_service_request(), otherwise we may get some errors with the driver enabled: BUG: using smp_processor_id() in preemptible [00000000] code: (udev-worker)/208 caller is loongson3_cpufreq_probe+0x5c/0x250 [loongson3_cpufreq]",
      "id": "CVE-2024-50178",
      "published": "2024-11-08T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T20:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:17Z"
      },
      "bom-ref": "06243c71-7e83-4656-94c9-79c04b37629a",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Ensure DA_ID handling completion before deleting an NPIV instance Deleting an NPIV instance requires all fabric ndlps to be released before an NPIV's resources can be torn down. Failure to release fabric ndlps beforehand opens kref imbalance race conditions. Fix by forcing the DA_ID to complete synchronously with usage of wait_queue.",
      "id": "CVE-2024-50183",
      "published": "2024-11-08T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-09T23:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_DRM_VC4 is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "8b2c2814-696c-4eca-9be6-8e01f43680c3",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/vc4: Stop the active perfmon before being destroyed Upon closing the file descriptor, the active performance monitor is not stopped. Although all perfmons are destroyed in `vc4_perfmon_close_file()`, the active performance monitor's pointer (`vc4->active_perfmon`) is still retained. If we open a new file descriptor and submit a few jobs with performance monitors, the driver will attempt to stop the active performance monitor using the stale pointer in `vc4->active_perfmon`. However, this pointer is no longer valid because the previous process has already terminated, and all performance monitors associated with it have been destroyed and freed. To fix this, when the active performance monitor belongs to a given process, explicitly stop it before destroying and freeing it.",
      "id": "CVE-2024-50187",
      "published": "2024-11-08T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T21:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:18Z"
      },
      "bom-ref": "ba00df76-ddfd-4659-866a-1e226a22fd30",
      "description": "In the Linux kernel, the following vulnerability has been resolved: udf: refactor inode_bmap() to handle error Refactor inode_bmap() to handle error since udf_next_aext() can return error now. On situations like ftruncate, udf_extend_file() can now detect errors and bail out early without resorting to checking for particular offsets and assuming internal behavior of these functions.",
      "id": "CVE-2024-50211",
      "published": "2024-11-08T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-18T19:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:20Z"
      },
      "bom-ref": "be8dede0-a5cc-4fa9-a07e-585d51fad1a7",
      "cwes": [
        191
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: fix crash when config small gso_max_size/gso_ipv4_max_size Config a small gso_max_size/gso_ipv4_max_size will lead to an underflow in sk_dst_gso_max_size(), which may trigger a BUG_ON crash, because sk->sk_gso_max_size would be much bigger than device limits. Call Trace: tcp_write_xmit tso_segs = tcp_init_tso_segs(skb, mss_now); tcp_set_skb_tso_segs tcp_skb_pcount_set // skb->len = 524288, mss_now = 8 // u16 tso_segs = 524288/8 = 65535 -> 0 tso_segs = DIV_ROUND_UP(skb->len, mss_now) BUG_ON(!tso_segs) Add check for the minimum value of gso_max_size and gso_ipv4_max_size.",
      "id": "CVE-2024-50258",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:21Z"
      },
      "bom-ref": "df7b1fc2-797e-4ff4-bb5f-0a92c0be50b7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_reject_ipv6: fix potential crash in nf_send_reset6() I got a syzbot report without a repro [1] crashing in nf_send_reset6() I think the issue is that dev->hard_header_len is zero, and we attempt later to push an Ethernet header. Use LL_MAX_HEADER, as other functions in net/ipv6/netfilter/nf_reject_ipv6.c. [1] skbuff: skb_under_panic: text:ffffffff89b1d008 len:74 put:14 head:ffff88803123aa00 data:ffff88803123a9f2 tail:0x3c end:0x140 dev:syz_tun kernel BUG at net/core/skbuff.c:206 ! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI CPU: 0 UID: 0 PID: 7373 Comm: syz.1.568 Not tainted 6.12.0-rc2-syzkaller-00631-g6d858708d465 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 RIP: 0010:skb_panic net/core/skbuff.c:206 [inline] RIP: 0010:skb_under_panic+0x14b/0x150 net/core/skbuff.c:216 Code: 0d 8d 48 c7 c6 60 a6 29 8e 48 8b 54 24 08 8b 0c 24 44 8b 44 24 04 4d 89 e9 50 41 54 41 57 41 56 e8 ba 30 38 02 48 83 c4 20 90 <0f> 0b 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 RSP: 0018:ffffc900045269b0 EFLAGS: 00010282 RAX: 0000000000000088 RBX: dffffc0000000000 RCX: cd66dacdc5d8e800 RDX: 0000000000000000 RSI: 0000000000000200 RDI: 0000000000000000 RBP: ffff88802d39a3d0 R08: ffffffff8174afec R09: 1ffff920008a4ccc R10: dffffc0000000000 R11: fffff520008a4ccd R12: 0000000000000140 R13: ffff88803123aa00 R14: ffff88803123a9f2 R15: 000000000000003c FS: 00007fdbee5ff6c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 000000005d322000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> skb_push+0xe5/0x100 net/core/skbuff.c:2636 eth_header+0x38/0x1f0 net/ethernet/eth.c:83 dev_hard_header include/linux/netdevice.h:3208 [inline] nf_send_reset6+0xce6/0x1270 net/ipv6/netfilter/nf_reject_ipv6.c:358 nft_reject_inet_eval+0x3b9/0x690 net/netfilter/nft_reject_inet.c:48 expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline] nft_do_chain+0x4ad/0x1da0 net/netfilter/nf_tables_core.c:288 nft_do_chain_inet+0x418/0x6b0 net/netfilter/nft_chain_filter.c:161 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_slow+0xc3/0x220 net/netfilter/core.c:626 nf_hook include/linux/netfilter.h:269 [inline] NF_HOOK include/linux/netfilter.h:312 [inline] br_nf_pre_routing_ipv6+0x63e/0x770 net/bridge/br_netfilter_ipv6.c:184 nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline] nf_hook_bridge_pre net/bridge/br_input.c:277 [inline] br_handle_frame+0x9fd/0x1530 net/bridge/br_input.c:424 __netif_receive_skb_core+0x13e8/0x4570 net/core/dev.c:5562 __netif_receive_skb_one_core net/core/dev.c:5666 [inline] __netif_receive_skb+0x12f/0x650 net/core/dev.c:5781 netif_receive_skb_internal net/core/dev.c:5867 [inline] netif_receive_skb+0x1e8/0x890 net/core/dev.c:5926 tun_rx_batched+0x1b7/0x8f0 drivers/net/tun.c:1550 tun_get_user+0x3056/0x47e0 drivers/net/tun.c:2007 tun_chr_write_iter+0x10d/0x1f0 drivers/net/tun.c:2053 new_sync_write fs/read_write.c:590 [inline] vfs_write+0xa6d/0xc90 fs/read_write.c:683 ksys_write+0x183/0x2b0 fs/read_write.c:736 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0033:0x7fdbeeb7d1ff Code: 89 54 24 18 48 89 74 24 10 89 7c 24 08 e8 c9 8d 02 00 48 8b 54 24 18 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 31 44 89 c7 48 89 44 24 08 e8 1c 8e 02 00 48 RSP: 002b:00007fdbee5ff000 EFLAGS: 00000293 ORIG_RAX: 0000000000000001 RAX: ffffffffffffffda RBX: 00007fdbeed36058 RCX: 00007fdbeeb7d1ff RDX: 000000000000008e RSI: 0000000020000040 RDI: 00000000000000c8 RBP: 00007fdbeebf12be R08: 0000000 ---truncated---",
      "id": "CVE-2024-50256",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-14T18:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:23Z"
      },
      "bom-ref": "11c47507-c408-4316-a1b1-31dec0a33a63",
      "cwes": [
        119
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ntfs3: Add bounds checking to mi_enum_attr() Added bounds checking to make sure that every attr don't stray beyond valid memory region.",
      "id": "CVE-2024-50248",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "23961c54-6bdc-4c3a-814c-764e344494cf",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Add rough attr alloc_size check",
      "id": "CVE-2024-50246",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:24Z"
      },
      "bom-ref": "38d2f6f7-092f-4134-b362-a9321b5e01a3",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Fix general protection fault in run_is_mapped_full Fixed deleating of a non-resident attribute in ntfs_create_inode() rollback.",
      "id": "CVE-2024-50243",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-17T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "f0c74d36-840a-4210-987a-443cb11e22cd",
      "description": "In the Linux kernel, the following vulnerability has been resolved: fs/ntfs3: Additional check in ntfs_file_release",
      "id": "CVE-2024-50242",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_GFS2_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "63849a36-ef6e-481e-baa3-03b8c3b3ddf5",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free of block device file in __btrfs_free_extra_devids() Mounting btrfs from two images (which have the same one fsid and two different dev_uuids) in certain executing order may trigger an UAF for variable 'device->bdev_file' in __btrfs_free_extra_devids(). And following are the details: 1. Attach image_1 to loop0, attach image_2 to loop1, and scan btrfs devices by ioctl(BTRFS_IOC_SCAN_DEV): / btrfs_device_1 ? loop0 fs_device \\ btrfs_device_2 ? loop1 2. mount /dev/loop0 /mnt btrfs_open_devices btrfs_device_1->bdev_file = btrfs_get_bdev_and_sb(loop0) btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1) btrfs_fill_super open_ctree fail: btrfs_close_devices // -ENOMEM btrfs_close_bdev(btrfs_device_1) fput(btrfs_device_1->bdev_file) // btrfs_device_1->bdev_file is freed btrfs_close_bdev(btrfs_device_2) fput(btrfs_device_2->bdev_file) 3. mount /dev/loop1 /mnt btrfs_open_devices btrfs_get_bdev_and_sb(&bdev_file) // EIO, btrfs_device_1->bdev_file is not assigned, // which points to a freed memory area btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1) btrfs_fill_super open_ctree btrfs_free_extra_devids if (btrfs_device_1->bdev_file) fput(btrfs_device_1->bdev_file) // UAF ! Fix it by setting 'device->bdev_file' as 'NULL' after closing the btrfs_device in btrfs_close_one_device().",
      "id": "CVE-2024-50217",
      "published": "2024-11-09T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-11T01:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:26Z"
      },
      "bom-ref": "9f79d8b3-963b-4ad6-9402-39232c60a6b6",
      "cwes": [
        416
      ],
      "description": "A use-after-free vulnerability was found in the cyttsp4_core driver in the Linux kernel. This issue occurs in the device cleanup routine due to a possible rearming of the watchdog_timer from the workqueue. This could allow a local user to crash the system, causing a denial of service.",
      "id": "CVE-2023-4134",
      "published": "2024-11-14T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-18T22:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:27Z"
      },
      "bom-ref": "c3a42fb3-9770-4784-8746-314d14632c97",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/imagination: Break an object reference loop When remaining resources are being cleaned up on driver close, outstanding VM mappings may result in resources being leaked, due to an object reference loop, as shown below, with each object (or set of objects) referencing the object below it: PVR GEM Object GPU scheduler \"finished\" fence GPU scheduler \u201cscheduled\u201d fence PVR driver \u201cdone\u201d fence PVR Context PVR VM Context PVR VM Mappings PVR GEM Object The reference that the PVR VM Context has on the VM mappings is a soft one, in the sense that the freeing of outstanding VM mappings is done as part of VM context destruction; no reference counts are involved, as is the case for all the other references in the loop. To break the reference loop during cleanup, free the outstanding VM mappings before destroying the PVR Context associated with the VM context.",
      "id": "CVE-2024-53084",
      "published": "2024-11-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T19:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:29Z"
      },
      "bom-ref": "8402330a-bcde-43f3-beff-c83580756eaa",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm/thp: fix deferred split unqueue naming and locking Recent changes are putting more pressure on THP deferred split queues: under load revealing long-standing races, causing list_del corruptions, \"Bad page state\"s and worse (I keep BUGs in both of those, so usually don't get to see how badly they end up without). The relevant recent changes being 6.8's mTHP, 6.10's mTHP swapout, and 6.12's mTHP swapin, improved swap allocation, and underused THP splitting. Before fixing locking: rename misleading folio_undo_large_rmappable(), which does not undo large_rmappable, to folio_unqueue_deferred_split(), which is what it does. But that and its out-of-line __callee are mm internals of very limited usability: add comment and WARN_ON_ONCEs to check usage; and return a bool to say if a deferred split was unqueued, which can then be used in WARN_ON_ONCEs around safety checks (sparing callers the arcane conditionals in __folio_unqueue_deferred_split()). Just omit the folio_unqueue_deferred_split() from free_unref_folios(), all of whose callers now call it beforehand (and if any forget then bad_page() will tell) - except for its caller put_pages_list(), which itself no longer has any callers (and will be deleted separately). Swapout: mem_cgroup_swapout() has been resetting folio->memcg_data 0 without checking and unqueueing a THP folio from deferred split list; which is unfortunate, since the split_queue_lock depends on the memcg (when memcg is enabled); so swapout has been unqueueing such THPs later, when freeing the folio, using the pgdat's lock instead: potentially corrupting the memcg's list. __remove_mapping() has frozen refcount to 0 here, so no problem with calling folio_unqueue_deferred_split() before resetting memcg_data. That goes back to 5.4 commit 87eaceb3faa5 (\"mm: thp: make deferred split shrinker memcg aware\"): which included a check on swapcache before adding to deferred queue, but no check on deferred queue before adding THP to swapcache. That worked fine with the usual sequence of events in reclaim (though there were a couple of rare ways in which a THP on deferred queue could have been swapped out), but 6.12 commit dafff3f4c850 (\"mm: split underused THPs\") avoids splitting underused THPs in reclaim, which makes swapcache THPs on deferred queue commonplace. Keep the check on swapcache before adding to deferred queue? Yes: it is no longer essential, but preserves the existing behaviour, and is likely to be a worthwhile optimization (vmstat showed much more traffic on the queue under swapping load if the check was removed); update its comment. Memcg-v1 move (deprecated): mem_cgroup_move_account() has been changing folio->memcg_data without checking and unqueueing a THP folio from the deferred list, sometimes corrupting \"from\" memcg's list, like swapout. Refcount is non-zero here, so folio_unqueue_deferred_split() can only be used in a WARN_ON_ONCE to validate the fix, which must be done earlier: mem_cgroup_move_charge_pte_range() first try to split the THP (splitting of course unqueues), or skip it if that fails. Not ideal, but moving charge has been requested, and khugepaged should repair the THP later: nobody wants new custom unqueueing code just for this deprecated case. The 87eaceb3faa5 commit did have the code to move from one deferred list to another (but was not conscious of its unsafety while refcount non-0); but that was removed by 5.6 commit fac0516b5534 (\"mm: thp: don't need care deferred split queue in memcg charge move path\"), which argued that the existence of a PMD mapping guarantees that the THP cannot be on a deferred list. As above, false in rare cases, and now commonly false. Backport to 6.11 should be straightforward. Earlier backports must take care that other _deferred_list fixes and dependencies are included. There is not a strong case for backports, but they can fix cornercases.",
      "id": "CVE-2024-53079",
      "published": "2024-11-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T16:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "b4a202cd-7c8c-420d-b1b5-8e95305001c7",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: firmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier() The scmi_dev->name is released prematurely in __scmi_device_destroy(), which causes slab-use-after-free when accessing scmi_dev->name in scmi_bus_notifier(). So move the release of scmi_dev->name to scmi_device_release() to avoid slab-use-after-free. | BUG: KASAN: slab-use-after-free in strncmp+0xe4/0xec | Read of size 1 at addr ffffff80a482bcc0 by task swapper/0/1 | | CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.6.38-debug #1 | Hardware name: Qualcomm Technologies, Inc. SA8775P Ride (DT) | Call trace: | dump_backtrace+0x94/0x114 | show_stack+0x18/0x24 | dump_stack_lvl+0x48/0x60 | print_report+0xf4/0x5b0 | kasan_report+0xa4/0xec | __asan_report_load1_noabort+0x20/0x2c | strncmp+0xe4/0xec | scmi_bus_notifier+0x5c/0x54c | notifier_call_chain+0xb4/0x31c | blocking_notifier_call_chain+0x68/0x9c | bus_notify+0x54/0x78 | device_del+0x1bc/0x840 | device_unregister+0x20/0xb4 | __scmi_device_destroy+0xac/0x280 | scmi_device_destroy+0x94/0xd0 | scmi_chan_setup+0x524/0x750 | scmi_probe+0x7fc/0x1508 | platform_probe+0xc4/0x19c | really_probe+0x32c/0x99c | __driver_probe_device+0x15c/0x3c4 | driver_probe_device+0x5c/0x170 | __driver_attach+0x1c8/0x440 | bus_for_each_dev+0xf4/0x178 | driver_attach+0x3c/0x58 | bus_add_driver+0x234/0x4d4 | driver_register+0xf4/0x3c0 | __platform_driver_register+0x60/0x88 | scmi_driver_init+0xb0/0x104 | do_one_initcall+0xb4/0x664 | kernel_init_freeable+0x3c8/0x894 | kernel_init+0x24/0x1e8 | ret_from_fork+0x10/0x20 | | Allocated by task 1: | kasan_save_stack+0x2c/0x54 | kasan_set_track+0x2c/0x40 | kasan_save_alloc_info+0x24/0x34 | __kasan_kmalloc+0xa0/0xb8 | __kmalloc_node_track_caller+0x6c/0x104 | kstrdup+0x48/0x84 | kstrdup_const+0x34/0x40 | __scmi_device_create.part.0+0x8c/0x408 | scmi_device_create+0x104/0x370 | scmi_chan_setup+0x2a0/0x750 | scmi_probe+0x7fc/0x1508 | platform_probe+0xc4/0x19c | really_probe+0x32c/0x99c | __driver_probe_device+0x15c/0x3c4 | driver_probe_device+0x5c/0x170 | __driver_attach+0x1c8/0x440 | bus_for_each_dev+0xf4/0x178 | driver_attach+0x3c/0x58 | bus_add_driver+0x234/0x4d4 | driver_register+0xf4/0x3c0 | __platform_driver_register+0x60/0x88 | scmi_driver_init+0xb0/0x104 | do_one_initcall+0xb4/0x664 | kernel_init_freeable+0x3c8/0x894 | kernel_init+0x24/0x1e8 | ret_from_fork+0x10/0x20 | | Freed by task 1: | kasan_save_stack+0x2c/0x54 | kasan_set_track+0x2c/0x40 | kasan_save_free_info+0x38/0x5c | __kasan_slab_free+0xe8/0x164 | __kmem_cache_free+0x11c/0x230 | kfree+0x70/0x130 | kfree_const+0x20/0x40 | __scmi_device_destroy+0x70/0x280 | scmi_device_destroy+0x94/0xd0 | scmi_chan_setup+0x524/0x750 | scmi_probe+0x7fc/0x1508 | platform_probe+0xc4/0x19c | really_probe+0x32c/0x99c | __driver_probe_device+0x15c/0x3c4 | driver_probe_device+0x5c/0x170 | __driver_attach+0x1c8/0x440 | bus_for_each_dev+0xf4/0x178 | driver_attach+0x3c/0x58 | bus_add_driver+0x234/0x4d4 | driver_register+0xf4/0x3c0 | __platform_driver_register+0x60/0x88 | scmi_driver_init+0xb0/0x104 | do_one_initcall+0xb4/0x664 | kernel_init_freeable+0x3c8/0x894 | kernel_init+0x24/0x1e8 | ret_from_fork+0x10/0x20",
      "id": "CVE-2024-53068",
      "published": "2024-11-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:30Z"
      },
      "bom-ref": "5a997b90-c8fd-4658-b385-51a941273951",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/hdcp: Add encoder check in intel_hdcp_get_capability Sometimes during hotplug scenario or suspend/resume scenario encoder is not always initialized when intel_hdcp_get_capability add a check to avoid kernel null pointer dereference.",
      "id": "CVE-2024-53051",
      "published": "2024-11-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_DRM_I915 is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "ddf3480c-1ef9-45b8-baf8-c3367e2bf94c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915/hdcp: Add encoder check in hdcp2_get_capability Add encoder check in intel_hdcp2_get_capability to avoid null pointer error.",
      "id": "CVE-2024-53050",
      "published": "2024-11-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-20T16:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:32Z"
      },
      "bom-ref": "5d3a56de-2e13-49bd-acd5-b322f2ecfcde",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv4: ip_tunnel: Fix suspicious RCU usage warning in ip_tunnel_find() The per-netns IP tunnel hash table is protected by the RTNL mutex and ip_tunnel_find() is only called from the control path where the mutex is taken. Add a lockdep expression to hlist_for_each_entry_rcu() in ip_tunnel_find() in order to validate that the mutex is held and to silence the suspicious RCU usage warning [1]. [1] WARNING: suspicious RCU usage 6.12.0-rc3-custom-gd95d9a31aceb #139 Not tainted ----------------------------- net/ipv4/ip_tunnel.c:221 RCU-list traversed in non-reader section!! other info that might help us debug this: rcu_scheduler_active = 2, debug_locks = 1 1 lock held by ip/362: #0: ffffffff86fc7cb0 (rtnl_mutex){+.+.}-{3:3}, at: rtnetlink_rcv_msg+0x377/0xf60 stack backtrace: CPU: 12 UID: 0 PID: 362 Comm: ip Not tainted 6.12.0-rc3-custom-gd95d9a31aceb #139 Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011 Call Trace: <TASK> dump_stack_lvl+0xba/0x110 lockdep_rcu_suspicious.cold+0x4f/0xd6 ip_tunnel_find+0x435/0x4d0 ip_tunnel_newlink+0x517/0x7a0 ipgre_newlink+0x14c/0x170 __rtnl_newlink+0x1173/0x19c0 rtnl_newlink+0x6c/0xa0 rtnetlink_rcv_msg+0x3cc/0xf60 netlink_rcv_skb+0x171/0x450 netlink_unicast+0x539/0x7f0 netlink_sendmsg+0x8c1/0xd80 ____sys_sendmsg+0x8f9/0xc20 ___sys_sendmsg+0x197/0x1e0 __sys_sendmsg+0x122/0x1f0 do_syscall_64+0xbb/0x1d0 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-50304",
      "published": "2024-11-19T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:33Z"
      },
      "bom-ref": "75d61030-d9bd-4b1a-a6dd-1e1594c564fc",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: enetc: allocate vf_state during PF probes In the previous implementation, vf_state is allocated memory only when VF is enabled. However, net_device_ops::ndo_set_vf_mac() may be called before VF is enabled to configure the MAC address of VF. If this is the case, enetc_pf_set_vf_mac() will access vf_state, resulting in access to a null pointer. The simplified error log is as follows. root@ls1028ardb:~# ip link set eno0 vf 1 mac 00:0c:e7:66:77:89 [ 173.543315] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004 [ 173.637254] pc : enetc_pf_set_vf_mac+0x3c/0x80 Message from sy [ 173.641973] lr : do_setlink+0x4a8/0xec8 [ 173.732292] Call trace: [ 173.734740] enetc_pf_set_vf_mac+0x3c/0x80 [ 173.738847] __rtnl_newlink+0x530/0x89c [ 173.742692] rtnl_newlink+0x50/0x7c [ 173.746189] rtnetlink_rcv_msg+0x128/0x390 [ 173.750298] netlink_rcv_skb+0x60/0x130 [ 173.754145] rtnetlink_rcv+0x18/0x24 [ 173.757731] netlink_unicast+0x318/0x380 [ 173.761665] netlink_sendmsg+0x17c/0x3c8",
      "id": "CVE-2024-50298",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T15:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "8bc2e70d-99ad-44ac-ad96-451bb47bbc9c",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab-use-after-free in ksmbd_smb2_session_create There is a race condition between ksmbd_smb2_session_create and ksmbd_expire_session. This patch add missing sessions_table_lock while adding/deleting session from global session table.",
      "id": "CVE-2024-50286",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:35Z"
      },
      "bom-ref": "729910fa-3992-42c5-92cd-f569081874d9",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: check outstanding simultaneous SMB operations If Client send simultaneous SMB operations to ksmbd, It exhausts too much memory through the \"ksmbd_work_cache\u201d. It will cause OOM issue. ksmbd has a credit mechanism but it can't handle this problem. This patch add the check if it exceeds max credits to prevent this problem by assuming that one smb request consumes at least one credit.",
      "id": "CVE-2024-50285",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T15:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_SMB_SERVER is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "9b840814-aaae-4431-b7bb-093499f87b2f",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: Fix the missing xa_store error check xa_store() can fail, it return xa_err(-EINVAL) if the entry cannot be stored in an XArray, or xa_err(-ENOMEM) if memory allocation failed, so check error for xa_store() to fix it.",
      "id": "CVE-2024-50284",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T16:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB_SERVER not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "3a79dec8-124d-4647-98b2-084dac2f9725",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix slab-use-after-free in smb3_preauth_hash_rsp ksmbd_user_session_put should be called under smb3_preauth_hash_rsp(). It will avoid freeing session before calling smb3_preauth_hash_rsp().",
      "id": "CVE-2024-50283",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:36Z"
      },
      "bom-ref": "5be834d3-f1bc-4626-a5be-6913a273c14b",
      "description": "In the Linux kernel, the following vulnerability has been resolved: dm cache: fix flushing uninitialized delayed_work on cache_ctr error An unexpected WARN_ON from flush_work() may occur when cache creation fails, caused by destroying the uninitialized delayed_work waker in the error path of cache_create(). For example, the warning appears on the superblock checksum error. Reproduce steps: dmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\" dmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\" dmsetup create corig --table \"0 524288 linear /dev/sdc 262144\" dd if=/dev/urandom of=/dev/mapper/cmeta bs=4k count=1 oflag=direct dmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\" Kernel logs: (snip) WARNING: CPU: 0 PID: 84 at kernel/workqueue.c:4178 __flush_work+0x5d4/0x890 Fix by pulling out the cancel_delayed_work_sync() from the constructor's error path. This patch doesn't affect the use-after-free fix for concurrent dm_resume and dm_destroy (commit 6a459d8edbdb (\"dm cache: Fix UAF in destroy()\")) as cache_dtr is not changed.",
      "id": "CVE-2024-50280",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:38Z"
      },
      "bom-ref": "f4d476ce-422a-4843-9dd0-b3db1d81ec8c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: dm: fix a crash if blk_alloc_disk fails If blk_alloc_disk fails, the variable md->disk is set to an error value. cleanup_mapped_device will see that md->disk is non-NULL and it will attempt to access it, causing a crash on this statement \"md->disk->private_data = NULL;\".",
      "id": "CVE-2024-50277",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T15:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "state": "not_affected"
      },
      "bom-ref": "89a1049b-2e7a-42e9-9204-4cb82a4e47d3",
      "description": "In the Linux kernel, the following vulnerability has been resolved: arm64/sve: Discard stale CPU state when handling SVE traps The logic for handling SVE traps manipulates saved FPSIMD/SVE state incorrectly, and a race with preemption can result in a task having TIF_SVE set and TIF_FOREIGN_FPSTATE clear even though the live CPU state is stale (e.g. with SVE traps enabled). This has been observed to result in warnings from do_sve_acc() where SVE traps are not expected while TIF_SVE is set: | if (test_and_set_thread_flag(TIF_SVE)) | WARN_ON(1); /* SVE access shouldn't have trapped */ Warnings of this form have been reported intermittently, e.g. https://lore.kernel.org/linux-arm-kernel/CA+G9fYtEGe_DhY2Ms7+L7NKsLYUomGsgqpdBj+QwDLeSg=JhGg@mail.gmail.com/ https://lore.kernel.org/linux-arm-kernel/000000000000511e9a060ce5a45c@google.com/ The race can occur when the SVE trap handler is preempted before and after manipulating the saved FPSIMD/SVE state, starting and ending on the same CPU, e.g. | void do_sve_acc(unsigned long esr, struct pt_regs *regs) | { | // Trap on CPU 0 with TIF_SVE clear, SVE traps enabled | // task->fpsimd_cpu is 0. | // per_cpu_ptr(&fpsimd_last_state, 0) is task. | | ... | | // Preempted; migrated from CPU 0 to CPU 1. | // TIF_FOREIGN_FPSTATE is set. | | get_cpu_fpsimd_context(); | | if (test_and_set_thread_flag(TIF_SVE)) | WARN_ON(1); /* SVE access shouldn't have trapped */ | | sve_init_regs() { | if (!test_thread_flag(TIF_FOREIGN_FPSTATE)) { | ... | } else { | fpsimd_to_sve(current); | current->thread.fp_type = FP_STATE_SVE; | } | } | | put_cpu_fpsimd_context(); | | // Preempted; migrated from CPU 1 to CPU 0. | // task->fpsimd_cpu is still 0 | // If per_cpu_ptr(&fpsimd_last_state, 0) is still task then: | // - Stale HW state is reused (with SVE traps enabled) | // - TIF_FOREIGN_FPSTATE is cleared | // - A return to userspace skips HW state restore | } Fix the case where the state is not live and TIF_FOREIGN_FPSTATE is set by calling fpsimd_flush_task_state() to detach from the saved CPU state. This ensures that a subsequent context switch will not reuse the stale CPU state, and will instead set TIF_FOREIGN_FPSTATE, forcing the new state to be reloaded from memory prior to a return to userspace.",
      "id": "CVE-2024-50275",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:39Z"
      },
      "bom-ref": "19106ad3-e712-41e1-9907-970b9d03f091",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: filemap: Fix bounds checking in filemap_read() If the caller supplies an iocb->ki_pos value that is close to the filesystem upper limit, and an iterator with a count that causes us to overflow that limit, then filemap_read() enters an infinite loop. This behaviour was discovered when testing xfstests generic/525 with the \"localio\" optimisation for loopback NFS mounts.",
      "id": "CVE-2024-50272",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:41Z"
      },
      "bom-ref": "7f28491f-ec38-436d-a983-c1104612c641",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: signal: restore the override_rlimit logic Prior to commit d64696905554 (\"Reimplement RLIMIT_SIGPENDING on top of ucounts\") UCOUNT_RLIMIT_SIGPENDING rlimit was not enforced for a class of signals. However now it's enforced unconditionally, even if override_rlimit is set. This behavior change caused production issues. For example, if the limit is reached and a process receives a SIGSEGV signal, sigqueue_alloc fails to allocate the necessary resources for the signal delivery, preventing the signal from being delivered with siginfo. This prevents the process from correctly identifying the fault address and handling the error. From the user-space perspective, applications are unaware that the limit has been reached and that the siginfo is effectively 'corrupted'. This can lead to unpredictable behavior and crashes, as we observed with java applications. Fix this by passing override_rlimit into inc_rlimit_get_ucounts() and skip the comparison to max there if override_rlimit is set. This effectively restores the old behavior.",
      "id": "CVE-2024-50271",
      "published": "2024-11-19T02:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-27T15:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "2119ecd6-07b0-4adc-af5d-c12b8887c402",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix possible UAF in amdgpu_cs_pass1() Since the gang_size check is outside of chunk parsing loop, we need to reset i before we free the chunk data. Suggested by Ye Zhang (@VAR10CK) of Baidu Security.",
      "id": "CVE-2023-52921",
      "published": "2024-11-19T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:42Z"
      },
      "bom-ref": "b9ee7191-dabe-47ca-a319-0cc9e1ac0099",
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: Fix use-after-free of network namespace. Recently, we got a customer report that CIFS triggers oops while reconnecting to a server. [0] The workload runs on Kubernetes, and some pods mount CIFS servers in non-root network namespaces. The problem rarely happened, but it was always while the pod was dying. The root cause is wrong reference counting for network namespace. CIFS uses kernel sockets, which do not hold refcnt of the netns that the socket belongs to. That means CIFS must ensure the socket is always freed before its netns; otherwise, use-after-free happens. The repro steps are roughly: 1. mount CIFS in a non-root netns 2. drop packets from the netns 3. destroy the netns 4. unmount CIFS We can reproduce the issue quickly with the script [1] below and see the splat [2] if CONFIG_NET_NS_REFCNT_TRACKER is enabled. When the socket is TCP, it is hard to guarantee the netns lifetime without holding refcnt due to async timers. Let's hold netns refcnt for each socket as done for SMC in commit 9744d2bf1976 (\"smc: Fix use-after-free in tcp_write_timer_handler().\"). Note that we need to move put_net() from cifs_put_tcp_session() to clean_demultiplex_info(); otherwise, __sock_create() still could touch a freed netns while cifsd tries to reconnect from cifs_demultiplex_thread(). Also, maybe_get_net() cannot be put just before __sock_create() because the code is not under RCU and there is a small chance that the same address happened to be reallocated to another netns. [0]: CIFS: VFS: \\\\XXXXXXXXXXX has not responded in 15 seconds. Reconnecting... CIFS: Serverclose failed 4 times, giving up Unable to handle kernel paging request at virtual address 14de99e461f84a07 Mem abort info: ESR = 0x0000000096000004 EC = 0x25: DABT (current EL), IL = 32 bits SET = 0, FnV = 0 EA = 0, S1PTW = 0 FSC = 0x04: level 0 translation fault Data abort info: ISV = 0, ISS = 0x00000004 CM = 0, WnR = 0 [14de99e461f84a07] address between user and kernel address ranges Internal error: Oops: 0000000096000004 [#1] SMP Modules linked in: cls_bpf sch_ingress nls_utf8 cifs cifs_arc4 cifs_md4 dns_resolver tcp_diag inet_diag veth xt_state xt_connmark nf_conntrack_netlink xt_nat xt_statistic xt_MASQUERADE xt_mark xt_addrtype ipt_REJECT nf_reject_ipv4 nft_chain_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xt_comment nft_compat nf_tables nfnetlink overlay nls_ascii nls_cp437 sunrpc vfat fat aes_ce_blk aes_ce_cipher ghash_ce sm4_ce_cipher sm4 sm3_ce sm3 sha3_ce sha512_ce sha512_arm64 sha1_ce ena button sch_fq_codel loop fuse configfs dmi_sysfs sha2_ce sha256_arm64 dm_mirror dm_region_hash dm_log dm_mod dax efivarfs CPU: 5 PID: 2690970 Comm: cifsd Not tainted 6.1.103-109.184.amzn2023.aarch64 #1 Hardware name: Amazon EC2 r7g.4xlarge/, BIOS 1.0 11/1/2018 pstate: 00400005 (nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : fib_rules_lookup+0x44/0x238 lr : __fib_lookup+0x64/0xbc sp : ffff8000265db790 x29: ffff8000265db790 x28: 0000000000000000 x27: 000000000000bd01 x26: 0000000000000000 x25: ffff000b4baf8000 x24: ffff00047b5e4580 x23: ffff8000265db7e0 x22: 0000000000000000 x21: ffff00047b5e4500 x20: ffff0010e3f694f8 x19: 14de99e461f849f7 x18: 0000000000000000 x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000 x14: 0000000000000000 x13: 0000000000000000 x12: 3f92800abd010002 x11: 0000000000000001 x10: ffff0010e3f69420 x9 : ffff800008a6f294 x8 : 0000000000000000 x7 : 0000000000000006 x6 : 0000000000000000 x5 : 0000000000000001 x4 : ffff001924354280 x3 : ffff8000265db7e0 x2 : 0000000000000000 x1 : ffff0010e3f694f8 x0 : ffff00047b5e4500 Call trace: fib_rules_lookup+0x44/0x238 __fib_lookup+0x64/0xbc ip_route_output_key_hash_rcu+0x2c4/0x398 ip_route_output_key_hash+0x60/0x8c tcp_v4_connect+0x290/0x488 __inet_stream_connect+0x108/0x3d0 inet_stream_connect+0x50/0x78 kernel_connect+0x6c/0xac generic_ip_conne ---truncated---",
      "id": "CVE-2024-53095",
      "published": "2024-11-21T19:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:44Z"
      },
      "bom-ref": "df78ecc5-d3f3-4cad-b7fa-6630ad13adfd",
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/siw: Add sendpage_ok() check to disable MSG_SPLICE_PAGES While running ISER over SIW, the initiator machine encounters a warning from skb_splice_from_iter() indicating that a slab page is being used in send_page. To address this, it is better to add a sendpage_ok() check within the driver itself, and if it returns 0, then MSG_SPLICE_PAGES flag should be disabled before entering the network stack. A similar issue has been discussed for NVMe in this thread: https://lore.kernel.org/all/20240530142417.146696-1-ofir.gal@volumez.com/ WARNING: CPU: 0 PID: 5342 at net/core/skbuff.c:7140 skb_splice_from_iter+0x173/0x320 Call Trace: tcp_sendmsg_locked+0x368/0xe40 siw_tx_hdt+0x695/0xa40 [siw] siw_qp_sq_process+0x102/0xb00 [siw] siw_sq_resume+0x39/0x110 [siw] siw_run_sq+0x74/0x160 [siw] kthread+0xd2/0x100 ret_from_fork+0x34/0x40 ret_from_fork_asm+0x1a/0x30",
      "id": "CVE-2024-53094",
      "published": "2024-11-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T15:07:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:45Z"
      },
      "bom-ref": "1d28c54b-b181-4d45-8e5c-813b479abfa0",
      "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-multipath: defer partition scanning We need to suppress the partition scan from occuring within the controller's scan_work context. If a path error occurs here, the IO will wait until a path becomes available or all paths are torn down, but that action also occurs within scan_work, so it would deadlock. Defer the partion scan to a different context that does not block scan_work.",
      "id": "CVE-2024-53093",
      "published": "2024-11-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T15:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:47Z"
      },
      "bom-ref": "02ba4ab4-1d97-43fd-9b23-51c0dec086c4",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Add sk_is_inet and IS_ICSK check in tls_sw_has_ctx_tx/rx As the introduction of the support for vsock and unix sockets in sockmap, tls_sw_has_ctx_tx/rx cannot presume the socket passed in must be IS_ICSK. vsock and af_unix sockets have vsock_sock and unix_sock instead of inet_connection_sock. For these sockets, tls_get_ctx may return an invalid pointer and cause page fault in function tls_sw_ctx_rx. BUG: unable to handle page fault for address: 0000000000040030 Workqueue: vsock-loopback vsock_loopback_work RIP: 0010:sk_psock_strp_data_ready+0x23/0x60 Call Trace: ? __die+0x81/0xc3 ? no_context+0x194/0x350 ? do_page_fault+0x30/0x110 ? async_page_fault+0x3e/0x50 ? sk_psock_strp_data_ready+0x23/0x60 virtio_transport_recv_pkt+0x750/0x800 ? update_load_avg+0x7e/0x620 vsock_loopback_work+0xd0/0x100 process_one_work+0x1a7/0x360 worker_thread+0x30/0x390 ? create_worker+0x1a0/0x1a0 kthread+0x112/0x130 ? __kthread_cancel_work+0x40/0x40 ret_from_fork+0x1f/0x40 v2: - Add IS_ICSK check v3: - Update the commits in Fixes",
      "id": "CVE-2024-53091",
      "published": "2024-11-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T14:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:48Z"
      },
      "bom-ref": "38ce2796-6671-4d32-81e5-7f751935d58e",
      "cwes": [
        674
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: afs: Fix lock recursion afs_wake_up_async_call() can incur lock recursion. The problem is that it is called from AF_RXRPC whilst holding the ->notify_lock, but it tries to take a ref on the afs_call struct in order to pass it to a work queue - but if the afs_call is already queued, we then have an extraneous ref that must be put... calling afs_put_call() may call back down into AF_RXRPC through rxrpc_kernel_shutdown_call(), however, which might try taking the ->notify_lock again. This case isn't very common, however, so defer it to a workqueue. The oops looks something like: BUG: spinlock recursion on CPU#0, krxrpcio/7001/1646 lock: 0xffff888141399b30, .magic: dead4ead, .owner: krxrpcio/7001/1646, .owner_cpu: 0 CPU: 0 UID: 0 PID: 1646 Comm: krxrpcio/7001 Not tainted 6.12.0-rc2-build3+ #4351 Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014 Call Trace: <TASK> dump_stack_lvl+0x47/0x70 do_raw_spin_lock+0x3c/0x90 rxrpc_kernel_shutdown_call+0x83/0xb0 afs_put_call+0xd7/0x180 rxrpc_notify_socket+0xa0/0x190 rxrpc_input_split_jumbo+0x198/0x1d0 rxrpc_input_data+0x14b/0x1e0 ? rxrpc_input_call_packet+0xc2/0x1f0 rxrpc_input_call_event+0xad/0x6b0 rxrpc_input_packet_on_conn+0x1e1/0x210 rxrpc_input_packet+0x3f2/0x4d0 rxrpc_io_thread+0x243/0x410 ? __pfx_rxrpc_io_thread+0x10/0x10 kthread+0xcf/0xe0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x24/0x40 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",
      "id": "CVE-2024-53090",
      "published": "2024-11-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T14:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:50Z"
      },
      "bom-ref": "d7a2445b-2495-4501-810c-1eee41153780",
      "description": "In the Linux kernel, the following vulnerability has been resolved: LoongArch: KVM: Mark hrtimer to expire in hard interrupt context Like commit 2c0d278f3293f (\"KVM: LAPIC: Mark hrtimer to expire in hard interrupt context\") and commit 9090825fa9974 (\"KVM: arm/arm64: Let the timer expire in hardirq context on RT\"), On PREEMPT_RT enabled kernels unmarked hrtimers are moved into soft interrupt expiry mode by default. Then the timers are canceled from an preempt-notifier which is invoked with disabled preemption which is not allowed on PREEMPT_RT. The timer callback is short so in could be invoked in hard-IRQ context. So let the timer expire on hard-IRQ context even on -RT. This fix a \"scheduling while atomic\" bug for PREEMPT_RT enabled kernels: BUG: scheduling while atomic: qemu-system-loo/1011/0x00000002 Modules linked in: amdgpu rfkill nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat ns CPU: 1 UID: 0 PID: 1011 Comm: qemu-system-loo Tainted: G W 6.12.0-rc2+ #1774 Tainted: [W]=WARN Hardware name: Loongson Loongson-3A5000-7A1000-1w-CRB/Loongson-LS3A5000-7A1000-1w-CRB, BIOS vUDK2018-LoongArch-V2.0.0-prebeta9 10/21/2022 Stack : ffffffffffffffff 0000000000000000 9000000004e3ea38 9000000116744000 90000001167475a0 0000000000000000 90000001167475a8 9000000005644830 90000000058dc000 90000000058dbff8 9000000116747420 0000000000000001 0000000000000001 6a613fc938313980 000000000790c000 90000001001c1140 00000000000003fe 0000000000000001 000000000000000d 0000000000000003 0000000000000030 00000000000003f3 000000000790c000 9000000116747830 90000000057ef000 0000000000000000 9000000005644830 0000000000000004 0000000000000000 90000000057f4b58 0000000000000001 9000000116747868 900000000451b600 9000000005644830 9000000003a13998 0000000010000020 00000000000000b0 0000000000000004 0000000000000000 0000000000071c1d ... Call Trace: [<9000000003a13998>] show_stack+0x38/0x180 [<9000000004e3ea34>] dump_stack_lvl+0x84/0xc0 [<9000000003a71708>] __schedule_bug+0x48/0x60 [<9000000004e45734>] __schedule+0x1114/0x1660 [<9000000004e46040>] schedule_rtlock+0x20/0x60 [<9000000004e4e330>] rtlock_slowlock_locked+0x3f0/0x10a0 [<9000000004e4f038>] rt_spin_lock+0x58/0x80 [<9000000003b02d68>] hrtimer_cancel_wait_running+0x68/0xc0 [<9000000003b02e30>] hrtimer_cancel+0x70/0x80 [<ffff80000235eb70>] kvm_restore_timer+0x50/0x1a0 [kvm] [<ffff8000023616c8>] kvm_arch_vcpu_load+0x68/0x2a0 [kvm] [<ffff80000234c2d4>] kvm_sched_in+0x34/0x60 [kvm] [<9000000003a749a0>] finish_task_switch.isra.0+0x140/0x2e0 [<9000000004e44a70>] __schedule+0x450/0x1660 [<9000000004e45cb0>] schedule+0x30/0x180 [<ffff800002354c70>] kvm_vcpu_block+0x70/0x120 [kvm] [<ffff800002354d80>] kvm_vcpu_halt+0x60/0x3e0 [kvm] [<ffff80000235b194>] kvm_handle_gspr+0x3f4/0x4e0 [kvm] [<ffff80000235f548>] kvm_handle_exit+0x1c8/0x260 [kvm]",
      "id": "CVE-2024-53089",
      "published": "2024-11-21T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T14:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:51Z"
      },
      "bom-ref": "f443505c-34f8-4fde-96e5-28103b1412e3",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nvme: tcp: avoid race between queue_lock lock and destroy Commit 76d54bf20cdc (\"nvme-tcp: don't access released socket during error recovery\") added a mutex_lock() call for the queue->queue_lock in nvme_tcp_get_address(). However, the mutex_lock() races with mutex_destroy() in nvme_tcp_free_queue(), and causes the WARN below. DEBUG_LOCKS_WARN_ON(lock->magic != lock) WARNING: CPU: 3 PID: 34077 at kernel/locking/mutex.c:587 __mutex_lock+0xcf0/0x1220 Modules linked in: nvmet_tcp nvmet nvme_tcp nvme_fabrics iw_cm ib_cm ib_core pktcdvd nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables qrtr sunrpc ppdev 9pnet_virtio 9pnet pcspkr netfs parport_pc parport e1000 i2c_piix4 i2c_smbus loop fuse nfnetlink zram bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper xfs drm sym53c8xx floppy nvme scsi_transport_spi nvme_core nvme_auth serio_raw ata_generic pata_acpi dm_multipath qemu_fw_cfg [last unloaded: ib_uverbs] CPU: 3 UID: 0 PID: 34077 Comm: udisksd Not tainted 6.11.0-rc7 #319 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014 RIP: 0010:__mutex_lock+0xcf0/0x1220 Code: 08 84 d2 0f 85 c8 04 00 00 8b 15 ef b6 c8 01 85 d2 0f 85 78 f4 ff ff 48 c7 c6 20 93 ee af 48 c7 c7 60 91 ee af e8 f0 a7 6d fd <0f> 0b e9 5e f4 ff ff 48 b8 00 00 00 00 00 fc ff df 4c 89 f2 48 c1 RSP: 0018:ffff88811305f760 EFLAGS: 00010286 RAX: 0000000000000000 RBX: ffff88812c652058 RCX: 0000000000000000 RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000001 RBP: ffff88811305f8b0 R08: 0000000000000001 R09: ffffed1075c36341 R10: ffff8883ae1b1a0b R11: 0000000000010498 R12: 0000000000000000 R13: 0000000000000000 R14: dffffc0000000000 R15: ffff88812c652058 FS: 00007f9713ae4980(0000) GS:ffff8883ae180000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fcd78483c7c CR3: 0000000122c38000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __warn.cold+0x5b/0x1af ? __mutex_lock+0xcf0/0x1220 ? report_bug+0x1ec/0x390 ? handle_bug+0x3c/0x80 ? exc_invalid_op+0x13/0x40 ? asm_exc_invalid_op+0x16/0x20 ? __mutex_lock+0xcf0/0x1220 ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp] ? __pfx___mutex_lock+0x10/0x10 ? __lock_acquire+0xd6a/0x59e0 ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp] nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp] ? __pfx_nvme_tcp_get_address+0x10/0x10 [nvme_tcp] nvme_sysfs_show_address+0x81/0xc0 [nvme_core] dev_attr_show+0x42/0x80 ? __asan_memset+0x1f/0x40 sysfs_kf_seq_show+0x1f0/0x370 seq_read_iter+0x2cb/0x1130 ? rw_verify_area+0x3b1/0x590 ? __mutex_lock+0x433/0x1220 vfs_read+0x6a6/0xa20 ? lockdep_hardirqs_on+0x78/0x100 ? __pfx_vfs_read+0x10/0x10 ksys_read+0xf7/0x1d0 ? __pfx_ksys_read+0x10/0x10 ? __x64_sys_openat+0x105/0x1d0 do_syscall_64+0x93/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? __pfx_ksys_read+0x10/0x10 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on_prepare+0x16d/0x400 ? do_syscall_64+0x9f/0x180 ? lockdep_hardirqs_on+0x78/0x100 ? do_syscall_64+0x9f/0x180 ? do_syscall_64+0x9f/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e RIP: 0033:0x7f9713f55cfa Code: 55 48 89 e5 48 83 ec 20 48 89 55 e8 48 89 75 f0 89 7d f8 e8 e8 74 f8 ff 48 8b 55 e8 48 8b 75 f0 4 ---truncated---",
      "id": "CVE-2024-53100",
      "published": "2024-11-25T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T15:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "50341622-c645-4c41-8b65-b77755c9d1b3",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: Check validity of link->type in bpf_link_show_fdinfo() If a newly-added link type doesn't invoke BPF_LINK_TYPE(), accessing bpf_link_type_strs[link->type] may result in an out-of-bounds access. To spot such missed invocations early in the future, checking the validity of link->type in bpf_link_show_fdinfo() and emitting a warning when such invocations are missed.",
      "id": "CVE-2024-53099",
      "published": "2024-11-25T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "8c3d4e44-2f7e-4c47-bbcc-88e7c75307f8",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/xe/ufence: Prefetch ufence addr to catch bogus address access_ok() only checks for addr overflow so also try to read the addr to catch invalid addr sent from userspace. (cherry picked from commit 9408c4508483ffc60811e910a93d6425b8e63928)",
      "id": "CVE-2024-53098",
      "published": "2024-11-25T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-24T15:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:53Z"
      },
      "bom-ref": "22fdb116-47e1-495e-95d3-7209b73153bc",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: fix data-races around sk->sk_forward_alloc Syzkaller reported this warning: ------------[ cut here ]------------ WARNING: CPU: 0 PID: 16 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x1c5/0x1e0 Modules linked in: CPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.12.0-rc5 #26 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 RIP: 0010:inet_sock_destruct+0x1c5/0x1e0 Code: 24 12 4c 89 e2 5b 48 c7 c7 98 ec bb 82 41 5c e9 d1 18 17 ff 4c 89 e6 5b 48 c7 c7 d0 ec bb 82 41 5c e9 bf 18 17 ff 0f 0b eb 83 <0f> 0b eb 97 0f 0b eb 87 0f 0b e9 68 ff ff ff 66 66 2e 0f 1f 84 00 RSP: 0018:ffffc9000008bd90 EFLAGS: 00010206 RAX: 0000000000000300 RBX: ffff88810b172a90 RCX: 0000000000000007 RDX: 0000000000000002 RSI: 0000000000000300 RDI: ffff88810b172a00 RBP: ffff88810b172a00 R08: ffff888104273c00 R09: 0000000000100007 R10: 0000000000020000 R11: 0000000000000006 R12: ffff88810b172a00 R13: 0000000000000004 R14: 0000000000000000 R15: ffff888237c31f78 FS: 0000000000000000(0000) GS:ffff888237c00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffc63fecac8 CR3: 000000000342e000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? __warn+0x88/0x130 ? inet_sock_destruct+0x1c5/0x1e0 ? report_bug+0x18e/0x1a0 ? handle_bug+0x53/0x90 ? exc_invalid_op+0x18/0x70 ? asm_exc_invalid_op+0x1a/0x20 ? inet_sock_destruct+0x1c5/0x1e0 __sk_destruct+0x2a/0x200 rcu_do_batch+0x1aa/0x530 ? rcu_do_batch+0x13b/0x530 rcu_core+0x159/0x2f0 handle_softirqs+0xd3/0x2b0 ? __pfx_smpboot_thread_fn+0x10/0x10 run_ksoftirqd+0x25/0x30 smpboot_thread_fn+0xdd/0x1d0 kthread+0xd3/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x34/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> ---[ end trace 0000000000000000 ]--- Its possible that two threads call tcp_v6_do_rcv()/sk_forward_alloc_add() concurrently when sk->sk_state == TCP_LISTEN with sk->sk_lock unlocked, which triggers a data-race around sk->sk_forward_alloc: tcp_v6_rcv tcp_v6_do_rcv skb_clone_and_charge_r sk_rmem_schedule __sk_mem_schedule sk_forward_alloc_add() skb_set_owner_r sk_mem_charge sk_forward_alloc_add() __kfree_skb skb_release_all skb_release_head_state sock_rfree sk_mem_uncharge sk_forward_alloc_add() sk_mem_reclaim // set local var reclaimable __sk_mem_reclaim sk_forward_alloc_add() In this syzkaller testcase, two threads call tcp_v6_do_rcv() with skb->truesize=768, the sk_forward_alloc changes like this: (cpu 1) | (cpu 2) | sk_forward_alloc ... | ... | 0 __sk_mem_schedule() | | +4096 = 4096 | __sk_mem_schedule() | +4096 = 8192 sk_mem_charge() | | -768 = 7424 | sk_mem_charge() | -768 = 6656 ... | ... | sk_mem_uncharge() | | +768 = 7424 reclaimable=7424 | | | sk_mem_uncharge() | +768 = 8192 | reclaimable=8192 | __sk_mem_reclaim() | | -4096 = 4096 | __sk_mem_reclaim() | -8192 = -4096 != 0 The skb_clone_and_charge_r() should not be called in tcp_v6_do_rcv() when sk->sk_state is TCP_LISTEN, it happens later in tcp_v6_syn_recv_sock(). Fix the same issue in dccp_v6_do_rcv().",
      "id": "CVE-2024-53124",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:54Z"
      },
      "bom-ref": "1d10de57-2829-4216-a1c1-05e63a08ab8a",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: cope racing subflow creation in mptcp_rcv_space_adjust Additional active subflows - i.e. created by the in kernel path manager - are included into the subflow list before starting the 3whs. A racing recvmsg() spooling data received on an already established subflow would unconditionally call tcp_cleanup_rbuf() on all the current subflows, potentially hitting a divide by zero error on the newly created ones. Explicitly check that the subflow is in a suitable state before invoking tcp_cleanup_rbuf().",
      "id": "CVE-2024-53122",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:56Z"
      },
      "bom-ref": "6253867f-f98f-4c40-920e-2870d88b91d9",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: fs, lock FTE when checking if active The referenced commits introduced a two-step process for deleting FTEs: - Lock the FTE, delete it from hardware, set the hardware deletion function to NULL and unlock the FTE. - Lock the parent flow group, delete the software copy of the FTE, and remove it from the xarray. However, this approach encounters a race condition if a rule with the same match value is added simultaneously. In this scenario, fs_core may set the hardware deletion function to NULL prematurely, causing a panic during subsequent rule deletions. To prevent this, ensure the active flag of the FTE is checked under a lock, which will prevent the fs_core layer from attaching a new steering rule to an FTE that is in the process of deletion. [ 438.967589] MOSHE: 2496 mlx5_del_flow_rules del_hw_func [ 438.968205] ------------[ cut here ]------------ [ 438.968654] refcount_t: decrement hit 0; leaking memory. [ 438.969249] WARNING: CPU: 0 PID: 8957 at lib/refcount.c:31 refcount_warn_saturate+0xfb/0x110 [ 438.970054] Modules linked in: act_mirred cls_flower act_gact sch_ingress openvswitch nsh mlx5_vdpa vringh vhost_iotlb vdpa mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core zram zsmalloc fuse [last unloaded: cls_flower] [ 438.973288] CPU: 0 UID: 0 PID: 8957 Comm: tc Not tainted 6.12.0-rc1+ #8 [ 438.973888] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 [ 438.974874] RIP: 0010:refcount_warn_saturate+0xfb/0x110 [ 438.975363] Code: 40 66 3b 82 c6 05 16 e9 4d 01 01 e8 1f 7c a0 ff 0f 0b c3 cc cc cc cc 48 c7 c7 10 66 3b 82 c6 05 fd e8 4d 01 01 e8 05 7c a0 ff <0f> 0b c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 90 [ 438.976947] RSP: 0018:ffff888124a53610 EFLAGS: 00010286 [ 438.977446] RAX: 0000000000000000 RBX: ffff888119d56de0 RCX: 0000000000000000 [ 438.978090] RDX: ffff88852c828700 RSI: ffff88852c81b3c0 RDI: ffff88852c81b3c0 [ 438.978721] RBP: ffff888120fa0e88 R08: 0000000000000000 R09: ffff888124a534b0 [ 438.979353] R10: 0000000000000001 R11: 0000000000000001 R12: ffff888119d56de0 [ 438.979979] R13: ffff888120fa0ec0 R14: ffff888120fa0ee8 R15: ffff888119d56de0 [ 438.980607] FS: 00007fe6dcc0f800(0000) GS:ffff88852c800000(0000) knlGS:0000000000000000 [ 438.983984] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 438.984544] CR2: 00000000004275e0 CR3: 0000000186982001 CR4: 0000000000372eb0 [ 438.985205] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 438.985842] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 438.986507] Call Trace: [ 438.986799] <TASK> [ 438.987070] ? __warn+0x7d/0x110 [ 438.987426] ? refcount_warn_saturate+0xfb/0x110 [ 438.987877] ? report_bug+0x17d/0x190 [ 438.988261] ? prb_read_valid+0x17/0x20 [ 438.988659] ? handle_bug+0x53/0x90 [ 438.989054] ? exc_invalid_op+0x14/0x70 [ 438.989458] ? asm_exc_invalid_op+0x16/0x20 [ 438.989883] ? refcount_warn_saturate+0xfb/0x110 [ 438.990348] mlx5_del_flow_rules+0x2f7/0x340 [mlx5_core] [ 438.990932] __mlx5_eswitch_del_rule+0x49/0x170 [mlx5_core] [ 438.991519] ? mlx5_lag_is_sriov+0x3c/0x50 [mlx5_core] [ 438.992054] ? xas_load+0x9/0xb0 [ 438.992407] mlx5e_tc_rule_unoffload+0x45/0xe0 [mlx5_core] [ 438.993037] mlx5e_tc_del_fdb_flow+0x2a6/0x2e0 [mlx5_core] [ 438.993623] mlx5e_flow_put+0x29/0x60 [mlx5_core] [ 438.994161] mlx5e_delete_flower+0x261/0x390 [mlx5_core] [ 438.994728] tc_setup_cb_destroy+0xb9/0x190 [ 438.995150] fl_hw_destroy_filter+0x94/0xc0 [cls_flower] [ 438.995650] fl_change+0x11a4/0x13c0 [cls_flower] [ 438.996105] tc_new_tfilter+0x347/0xbc0 [ 438.996503] ? __ ---truncated---",
      "id": "CVE-2024-53121",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_NET_VENDOR_MELLANOX not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "537ab547-db4f-4def-9128-91966dddd01e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: CT: Fix null-ptr-deref in add rule err flow In error flow of mlx5_tc_ct_entry_add_rule(), in case ct_rule_add() callback returns error, zone_rule->attr is used uninitiated. Fix it to use attr which has the needed pointer value. Kernel log: BUG: kernel NULL pointer dereference, address: 0000000000000110 RIP: 0010:mlx5_tc_ct_entry_add_rule+0x2b1/0x2f0 [mlx5_core] \u2026 Call Trace: <TASK> ? __die+0x20/0x70 ? page_fault_oops+0x150/0x3e0 ? exc_page_fault+0x74/0x140 ? asm_exc_page_fault+0x22/0x30 ? mlx5_tc_ct_entry_add_rule+0x2b1/0x2f0 [mlx5_core] ? mlx5_tc_ct_entry_add_rule+0x1d5/0x2f0 [mlx5_core] mlx5_tc_ct_block_flow_offload+0xc6a/0xf90 [mlx5_core] ? nf_flow_offload_tuple+0xd8/0x190 [nf_flow_table] nf_flow_offload_tuple+0xd8/0x190 [nf_flow_table] flow_offload_work_handler+0x142/0x320 [nf_flow_table] ? finish_task_switch.isra.0+0x15b/0x2b0 process_one_work+0x16c/0x320 worker_thread+0x28c/0x3a0 ? __pfx_worker_thread+0x10/0x10 kthread+0xb8/0xf0 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2d/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>",
      "id": "CVE-2024-53120",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:57Z"
      },
      "bom-ref": "b89cc6e6-2462-4134-87b1-1fd9f8cc86a0",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: virtio/vsock: Fix accept_queue memory leak As the final stages of socket destruction may be delayed, it is possible that virtio_transport_recv_listen() will be called after the accept_queue has been flushed, but before the SOCK_DONE flag has been set. As a result, sockets enqueued after the flush would remain unremoved, leading to a memory leak. vsock_release __vsock_release lock virtio_transport_release virtio_transport_close schedule_delayed_work(close_work) sk_shutdown = SHUTDOWN_MASK (!) flush accept_queue release virtio_transport_recv_pkt vsock_find_bound_socket lock if flag(SOCK_DONE) return virtio_transport_recv_listen child = vsock_create_connected (!) vsock_enqueue_accept(child) release close_work lock virtio_transport_do_close set_flag(SOCK_DONE) virtio_transport_remove_sock vsock_remove_sock vsock_remove_bound release Introduce a sk_shutdown check to disallow vsock_enqueue_accept() during socket destruction. unreferenced object 0xffff888109e3f800 (size 2040): comm \"kworker/5:2\", pid 371, jiffies 4294940105 hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 28 00 0b 40 00 00 00 00 00 00 00 00 00 00 00 00 (..@............ backtrace (crc 9e5f4e84): [<ffffffff81418ff1>] kmem_cache_alloc_noprof+0x2c1/0x360 [<ffffffff81d27aa0>] sk_prot_alloc+0x30/0x120 [<ffffffff81d2b54c>] sk_alloc+0x2c/0x4b0 [<ffffffff81fe049a>] __vsock_create.constprop.0+0x2a/0x310 [<ffffffff81fe6d6c>] virtio_transport_recv_pkt+0x4dc/0x9a0 [<ffffffff81fe745d>] vsock_loopback_work+0xfd/0x140 [<ffffffff810fc6ac>] process_one_work+0x20c/0x570 [<ffffffff810fce3f>] worker_thread+0x1bf/0x3a0 [<ffffffff811070dd>] kthread+0xdd/0x110 [<ffffffff81044fdd>] ret_from_fork+0x2d/0x50 [<ffffffff8100785a>] ret_from_fork_asm+0x1a/0x30",
      "id": "CVE-2024-53119",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-19T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:55:59Z"
      },
      "bom-ref": "e67efc6e-cd97-4e76-b0a2-b7713f3d97ad",
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/CPU/AMD: Clear virtualized VMLOAD/VMSAVE on Zen4 client A number of Zen4 client SoCs advertise the ability to use virtualized VMLOAD/VMSAVE, but using these instructions is reported to be a cause of a random host reboot. These instructions aren't intended to be advertised on Zen4 client so clear the capability.",
      "id": "CVE-2024-53114",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T20:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:00Z"
      },
      "bom-ref": "c319d202-8a56-4a0a-ba94-86c88fe0b19f",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm: fix NULL pointer dereference in alloc_pages_bulk_noprof We triggered a NULL pointer dereference for ac.preferred_zoneref->zone in alloc_pages_bulk_noprof() when the task is migrated between cpusets. When cpuset is enabled, in prepare_alloc_pages(), ac->nodemask may be &current->mems_allowed. when first_zones_zonelist() is called to find preferred_zoneref, the ac->nodemask may be modified concurrently if the task is migrated between different cpusets. Assuming we have 2 NUMA Node, when traversing Node1 in ac->zonelist, the nodemask is 2, and when traversing Node2 in ac->zonelist, the nodemask is 1. As a result, the ac->preferred_zoneref points to NULL zone. In alloc_pages_bulk_noprof(), for_each_zone_zonelist_nodemask() finds a allowable zone and calls zonelist_node_idx(ac.preferred_zoneref), leading to NULL pointer dereference. __alloc_pages_noprof() fixes this issue by checking NULL pointer in commit ea57485af8f4 (\"mm, page_alloc: fix check for NULL preferred_zone\") and commit df76cee6bbeb (\"mm, page_alloc: remove redundant checks from alloc fastpath\"). To fix it, check NULL pointer for preferred_zoneref->zone.",
      "id": "CVE-2024-53113",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:02Z"
      },
      "bom-ref": "9e84ca7e-aad0-490a-a271-a81fcd7c3125",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: uncache inode which has failed entering the group Syzbot has reported the following BUG: kernel BUG at fs/ocfs2/uptodate.c:509! ... Call Trace: <TASK> ? __die_body+0x5f/0xb0 ? die+0x9e/0xc0 ? do_trap+0x15a/0x3a0 ? ocfs2_set_new_buffer_uptodate+0x145/0x160 ? do_error_trap+0x1dc/0x2c0 ? ocfs2_set_new_buffer_uptodate+0x145/0x160 ? __pfx_do_error_trap+0x10/0x10 ? handle_invalid_op+0x34/0x40 ? ocfs2_set_new_buffer_uptodate+0x145/0x160 ? exc_invalid_op+0x38/0x50 ? asm_exc_invalid_op+0x1a/0x20 ? ocfs2_set_new_buffer_uptodate+0x2e/0x160 ? ocfs2_set_new_buffer_uptodate+0x144/0x160 ? ocfs2_set_new_buffer_uptodate+0x145/0x160 ocfs2_group_add+0x39f/0x15a0 ? __pfx_ocfs2_group_add+0x10/0x10 ? __pfx_lock_acquire+0x10/0x10 ? mnt_get_write_access+0x68/0x2b0 ? __pfx_lock_release+0x10/0x10 ? rcu_read_lock_any_held+0xb7/0x160 ? __pfx_rcu_read_lock_any_held+0x10/0x10 ? smack_log+0x123/0x540 ? mnt_get_write_access+0x68/0x2b0 ? mnt_get_write_access+0x68/0x2b0 ? mnt_get_write_access+0x226/0x2b0 ocfs2_ioctl+0x65e/0x7d0 ? __pfx_ocfs2_ioctl+0x10/0x10 ? smack_file_ioctl+0x29e/0x3a0 ? __pfx_smack_file_ioctl+0x10/0x10 ? lockdep_hardirqs_on_prepare+0x43d/0x780 ? __pfx_lockdep_hardirqs_on_prepare+0x10/0x10 ? __pfx_ocfs2_ioctl+0x10/0x10 __se_sys_ioctl+0xfb/0x170 do_syscall_64+0xf3/0x230 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... </TASK> When 'ioctl(OCFS2_IOC_GROUP_ADD, ...)' has failed for the particular inode in 'ocfs2_verify_group_and_input()', corresponding buffer head remains cached and subsequent call to the same 'ioctl()' for the same inode issues the BUG() in 'ocfs2_set_new_buffer_uptodate()' (trying to cache the same buffer head of that inode). Fix this by uncaching the buffer head with 'ocfs2_remove_from_cache()' on error path in 'ocfs2_group_add()'.",
      "id": "CVE-2024-53112",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "requires_dependency",
        "state": "not_affected"
      },
      "bom-ref": "5344a4f9-99a8-4e74-9880-31287c9df945",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Adjust VSDB parser for replay feature At some point, the IEEE ID identification for the replay check in the AMD EDID was added. However, this check causes the following out-of-bounds issues when using KASAN: [ 27.804016] BUG: KASAN: slab-out-of-bounds in amdgpu_dm_update_freesync_caps+0xefa/0x17a0 [amdgpu] [ 27.804788] Read of size 1 at addr ffff8881647fdb00 by task systemd-udevd/383 ... [ 27.821207] Memory state around the buggy address: [ 27.821215] ffff8881647fda00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 27.821224] ffff8881647fda80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 27.821234] >ffff8881647fdb00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 27.821243] ^ [ 27.821250] ffff8881647fdb80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [ 27.821259] ffff8881647fdc00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [ 27.821268] ================================================================== This is caused because the ID extraction happens outside of the range of the edid lenght. This commit addresses this issue by considering the amd_vsdb_block size. (cherry picked from commit b7e381b1ccd5e778e3d9c44c669ad38439a861d8)",
      "id": "CVE-2024-53108",
      "published": "2024-12-02T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-12T16:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:03Z"
      },
      "bom-ref": "7fea7b0e-9709-4b5b-bd30-ebb6640b1768",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netlink: terminate outstanding dump on socket close Netlink supports iterative dumping of data. It provides the families the following ops: - start - (optional) kicks off the dumping process - dump - actual dump helper, keeps getting called until it returns 0 - done - (optional) pairs with .start, can be used for cleanup The whole process is asynchronous and the repeated calls to .dump don't actually happen in a tight loop, but rather are triggered in response to recvmsg() on the socket. This gives the user full control over the dump, but also means that the user can close the socket without getting to the end of the dump. To make sure .start is always paired with .done we check if there is an ongoing dump before freeing the socket, and if so call .done. The complication is that sockets can get freed from BH and .done is allowed to sleep. So we use a workqueue to defer the call, when needed. Unfortunately this does not work correctly. What we defer is not the cleanup but rather releasing a reference on the socket. We have no guarantee that we own the last reference, if someone else holds the socket they may release it in BH and we're back to square one. The whole dance, however, appears to be unnecessary. Only the user can interact with dumps, so we can clean up when socket is closed. And close always happens in process context. Some async code may still access the socket after close, queue notification skbs to it etc. but no dumps can start, end or otherwise make progress. Delete the workqueue and flush the dump state directly from the release handler. Note that further cleanup is possible in -next, for instance we now always call .done before releasing the main module reference, so dump doesn't have to take a reference of its own.",
      "id": "CVE-2024-53140",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:05Z"
      },
      "bom-ref": "89da79ed-4000-4f6e-892d-2ce759f6e8f7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5e: kTLS, Fix incorrect page refcounting The kTLS tx handling code is using a mix of get_page() and page_ref_inc() APIs to increment the page reference. But on the release path (mlx5e_ktls_tx_handle_resync_dump_comp()), only put_page() is used. This is an issue when using pages from large folios: the get_page() references are stored on the folio page while the page_ref_inc() references are stored directly in the given page. On release the folio page will be dereferenced too many times. This was found while doing kTLS testing with sendfile() + ZC when the served file was read from NFS on a kernel with NFS large folios support (commit 49b29a573da8 (\"nfs: add support for large folios\")).",
      "id": "CVE-2024-53138",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:06Z"
      },
      "bom-ref": "321acf3d-eebc-4960-ba32-e832df8958df",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm: revert \"mm: shmem: fix data-race in shmem_getattr()\" Revert d949d1d14fa2 (\"mm: shmem: fix data-race in shmem_getattr()\") as suggested by Chuck [1]. It is causing deadlocks when accessing tmpfs over NFS. As Hugh commented, \"added just to silence a syzbot sanitizer splat: added where there has never been any practical problem\".",
      "id": "CVE-2024-53136",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:08Z"
      },
      "bom-ref": "3239982b-9875-499e-b40a-d310d76f9f6e",
      "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: VMX: Bury Intel PT virtualization (guest/host mode) behind CONFIG_BROKEN Hide KVM's pt_mode module param behind CONFIG_BROKEN, i.e. disable support for virtualizing Intel PT via guest/host mode unless BROKEN=y. There are myriad bugs in the implementation, some of which are fatal to the guest, and others which put the stability and health of the host at risk. For guest fatalities, the most glaring issue is that KVM fails to ensure tracing is disabled, and *stays* disabled prior to VM-Enter, which is necessary as hardware disallows loading (the guest's) RTIT_CTL if tracing is enabled (enforced via a VMX consistency check). Per the SDM: If the logical processor is operating with Intel PT enabled (if IA32_RTIT_CTL.TraceEn = 1) at the time of VM entry, the \"load IA32_RTIT_CTL\" VM-entry control must be 0. On the host side, KVM doesn't validate the guest CPUID configuration provided by userspace, and even worse, uses the guest configuration to decide what MSRs to save/load at VM-Enter and VM-Exit. E.g. configuring guest CPUID to enumerate more address ranges than are supported in hardware will result in KVM trying to passthrough, save, and load non-existent MSRs, which generates a variety of WARNs, ToPA ERRORs in the host, a potential deadlock, etc.",
      "id": "CVE-2024-53135",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_AMD_GPU not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "dcdd4246-ad43-4b29-893f-df1e43ac877a",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Handle dml allocation failure to avoid crash [Why] In the case where a dml allocation fails for any reason, the current state's dml contexts would no longer be valid. Then subsequent calls dc_state_copy_internal would shallow copy invalid memory and if the new state was released, a double free would occur. [How] Reset dml pointers in new_state to NULL and avoid invalid pointer (cherry picked from commit bcafdc61529a48f6f06355d78eb41b3aeda5296c)",
      "id": "CVE-2024-53133",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T17:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:09Z"
      },
      "bom-ref": "82219ea2-2acb-4476-8b42-78908c99f004",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix null-ptr-deref in block_touch_buffer tracepoint Patch series \"nilfs2: fix null-ptr-deref bugs on block tracepoints\". This series fixes null pointer dereference bugs that occur when using nilfs2 and two block-related tracepoints. This patch (of 2): It has been reported that when using \"block:block_touch_buffer\" tracepoint, touch_buffer() called from __nilfs_get_folio_block() causes a NULL pointer dereference, or a general protection fault when KASAN is enabled. This happens because since the tracepoint was added in touch_buffer(), it references the dev_t member bh->b_bdev->bd_dev regardless of whether the buffer head has a pointer to a block_device structure. In the current implementation, the block_device structure is set after the function returns to the caller. Here, touch_buffer() is used to mark the folio/page that owns the buffer head as accessed, but the common search helper for folio/page used by the caller function was optimized to mark the folio/page as accessed when it was reimplemented a long time ago, eliminating the need to call touch_buffer() here in the first place. So this solves the issue by eliminating the touch_buffer() call itself.",
      "id": "CVE-2024-53131",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:11Z"
      },
      "bom-ref": "725c22e9-ddf5-469f-be53-cd9c37257af6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix null-ptr-deref in block_dirty_buffer tracepoint When using the \"block:block_dirty_buffer\" tracepoint, mark_buffer_dirty() may cause a NULL pointer dereference, or a general protection fault when KASAN is enabled. This happens because, since the tracepoint was added in mark_buffer_dirty(), it references the dev_t member bh->b_bdev->bd_dev regardless of whether the buffer head has a pointer to a block_device structure. In the current implementation, nilfs_grab_buffer(), which grabs a buffer to read (or create) a block of metadata, including b-tree node blocks, does not set the block device, but instead does so only if the buffer is not in the \"uptodate\" state for each of its caller block reading functions. However, if the uptodate flag is set on a folio/page, and the buffer heads are detached from it by try_to_free_buffers(), and new buffer heads are then attached by create_empty_buffers(), the uptodate flag may be restored to each buffer without the block device being set to bh->b_bdev, and mark_buffer_dirty() may be called later in that state, resulting in the bug mentioned above. Fix this issue by making nilfs_grab_buffer() always set the block device of the super block structure to the buffer head, regardless of the state of the buffer's uptodate flag.",
      "id": "CVE-2024-53130",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:12Z"
      },
      "bom-ref": "efb92fa8-621b-41d0-a582-4296e04e7ebb",
      "description": "In the Linux kernel, the following vulnerability has been resolved: sched/task_stack: fix object_is_on_stack() for KASAN tagged pointers When CONFIG_KASAN_SW_TAGS and CONFIG_KASAN_STACK are enabled, the object_is_on_stack() function may produce incorrect results due to the presence of tags in the obj pointer, while the stack pointer does not have tags. This discrepancy can lead to incorrect stack object detection and subsequently trigger warnings if CONFIG_DEBUG_OBJECTS is also enabled. Example of the warning: ODEBUG: object 3eff800082ea7bb0 is NOT on stack ffff800082ea0000, but annotated. ------------[ cut here ]------------ WARNING: CPU: 0 PID: 1 at lib/debugobjects.c:557 __debug_object_init+0x330/0x364 Modules linked in: CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-rc5 #4 Hardware name: linux,dummy-virt (DT) pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : __debug_object_init+0x330/0x364 lr : __debug_object_init+0x330/0x364 sp : ffff800082ea7b40 x29: ffff800082ea7b40 x28: 98ff0000c0164518 x27: 98ff0000c0164534 x26: ffff800082d93ec8 x25: 0000000000000001 x24: 1cff0000c00172a0 x23: 0000000000000000 x22: ffff800082d93ed0 x21: ffff800081a24418 x20: 3eff800082ea7bb0 x19: efff800000000000 x18: 0000000000000000 x17: 00000000000000ff x16: 0000000000000047 x15: 206b63617473206e x14: 0000000000000018 x13: ffff800082ea7780 x12: 0ffff800082ea78e x11: 0ffff800082ea790 x10: 0ffff800082ea79d x9 : 34d77febe173e800 x8 : 34d77febe173e800 x7 : 0000000000000001 x6 : 0000000000000001 x5 : feff800082ea74b8 x4 : ffff800082870a90 x3 : ffff80008018d3c4 x2 : 0000000000000001 x1 : ffff800082858810 x0 : 0000000000000050 Call trace: __debug_object_init+0x330/0x364 debug_object_init_on_stack+0x30/0x3c schedule_hrtimeout_range_clock+0xac/0x26c schedule_hrtimeout+0x1c/0x30 wait_task_inactive+0x1d4/0x25c kthread_bind_mask+0x28/0x98 init_rescuer+0x1e8/0x280 workqueue_init+0x1a0/0x3cc kernel_init_freeable+0x118/0x200 kernel_init+0x28/0x1f0 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]--- ODEBUG: object 3eff800082ea7bb0 is NOT on stack ffff800082ea0000, but annotated. ------------[ cut here ]------------",
      "id": "CVE-2024-53128",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_VDPA is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "01416d27-5e55-49b5-a02c-8e9243049e25",
      "description": "In the Linux kernel, the following vulnerability has been resolved: vdpa: solidrun: Fix UB bug with devres In psnet_open_pf_bar() and snet_open_vf_bar() a string later passed to pcim_iomap_regions() is placed on the stack. Neither pcim_iomap_regions() nor the functions it calls copy that string. Should the string later ever be used, this, consequently, causes undefined behavior since the stack frame will by then have disappeared. Fix the bug by allocating the strings on the heap through devm_kasprintf().",
      "id": "CVE-2024-53126",
      "published": "2024-12-04T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-11T17:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "3532610e-3fe2-4a96-90ce-92d1551acaa3",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: initramfs: avoid filename buffer overrun The initramfs filename field is defined in Documentation/driver-api/early-userspace/buffer-format.rst as: 37 cpio_file := ALGN(4) + cpio_header + filename + \"\\0\" + ALGN(4) + data ... 55 ============= ================== ========================= 56 Field name Field size Meaning 57 ============= ================== ========================= ... 70 c_namesize 8 bytes Length of filename, including final \\0 When extracting an initramfs cpio archive, the kernel's do_name() path handler assumes a zero-terminated path at @collected, passing it directly to filp_open() / init_mkdir() / init_mknod(). If a specially crafted cpio entry carries a non-zero-terminated filename and is followed by uninitialized memory, then a file may be created with trailing characters that represent the uninitialized memory. The ability to create an initramfs entry would imply already having full control of the system, so the buffer overrun shouldn't be considered a security vulnerability. Append the output of the following bash script to an existing initramfs and observe any created /initramfs_test_fname_overrunAA* path. E.g. ./reproducer.sh | gzip >> /myinitramfs It's easiest to observe non-zero uninitialized memory when the output is gzipped, as it'll overflow the heap allocated @out_buf in __gunzip(), rather than the initrd_start+initrd_size block. ---- reproducer.sh ---- nilchar=\"A\" # change to \"\\0\" to properly zero terminate / pad magic=\"070701\" ino=1 mode=$(( 0100777 )) uid=0 gid=0 nlink=1 mtime=1 filesize=0 devmajor=0 devminor=1 rdevmajor=0 rdevminor=0 csum=0 fname=\"initramfs_test_fname_overrun\" namelen=$(( ${#fname} + 1 )) # plus one to account for terminator printf \"%s%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%s\" \\ $magic $ino $mode $uid $gid $nlink $mtime $filesize \\ $devmajor $devminor $rdevmajor $rdevminor $namelen $csum $fname termpadlen=$(( 1 + ((4 - ((110 + $namelen) & 3)) % 4) )) printf \"%.s${nilchar}\" $(seq 1 $termpadlen) ---- reproducer.sh ---- Symlink filename fields handled in do_symlink() won't overrun past the data segment, due to the explicit zero-termination of the symlink target. Fix filename buffer overrun by aborting the initramfs FSM if any cpio entry doesn't carry a zero-terminator at the expected (name_len - 1) offset.",
      "id": "CVE-2024-53142",
      "published": "2024-12-06T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_IP_SET is not set in kernel config.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "a57c9bbe-dce5-4948-9d67-76c9664772cf",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: ipset: add missing range check in bitmap_ip_uadt When tb[IPSET_ATTR_IP_TO] is not present but tb[IPSET_ATTR_CIDR] exists, the values of ip and ip_to are slightly swapped. Therefore, the range check for ip should be done later, but this part is missing and it seems that the vulnerability occurs. So we should add missing range checks and remove unnecessary range checks.",
      "id": "CVE-2024-53141",
      "published": "2024-12-06T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-14T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "282f81f4-c556-4789-b8db-eef7d3c60e1b",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: blk-cgroup: Fix UAF in blkcg_unpin_online() blkcg_unpin_online() walks up the blkcg hierarchy putting the online pin. To walk up, it uses blkcg_parent(blkcg) but it was calling that after blkcg_destroy_blkgs(blkcg) which could free the blkcg, leading to the following UAF: ================================================================== BUG: KASAN: slab-use-after-free in blkcg_unpin_online+0x15a/0x270 Read of size 8 at addr ffff8881057678c0 by task kworker/9:1/117 CPU: 9 UID: 0 PID: 117 Comm: kworker/9:1 Not tainted 6.13.0-rc1-work-00182-gb8f52214c61a-dirty #48 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS unknown 02/02/2022 Workqueue: cgwb_release cgwb_release_workfn Call Trace: <TASK> dump_stack_lvl+0x27/0x80 print_report+0x151/0x710 kasan_report+0xc0/0x100 blkcg_unpin_online+0x15a/0x270 cgwb_release_workfn+0x194/0x480 process_scheduled_works+0x71b/0xe20 worker_thread+0x82a/0xbd0 kthread+0x242/0x2c0 ret_from_fork+0x33/0x70 ret_from_fork_asm+0x1a/0x30 </TASK> ... Freed by task 1944: kasan_save_track+0x2b/0x70 kasan_save_free_info+0x3c/0x50 __kasan_slab_free+0x33/0x50 kfree+0x10c/0x330 css_free_rwork_fn+0xe6/0xb30 process_scheduled_works+0x71b/0xe20 worker_thread+0x82a/0xbd0 kthread+0x242/0x2c0 ret_from_fork+0x33/0x70 ret_from_fork_asm+0x1a/0x30 Note that the UAF is not easy to trigger as the free path is indirected behind a couple RCU grace periods and a work item execution. I could only trigger it with artifical msleep() injected in blkcg_unpin_online(). Fix it by reading the parent pointer before destroying the blkcg's blkg's.",
      "id": "CVE-2024-56672",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-10T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:14Z"
      },
      "bom-ref": "f755d3ce-4cf0-49d2-93da-29c7a7b79dbd",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf,perf: Fix invalid prog_array access in perf_event_detach_bpf_prog Syzbot reported [1] crash that happens for following tracing scenario: - create tracepoint perf event with attr.inherit=1, attach it to the process and set bpf program to it - attached process forks -> chid creates inherited event the new child event shares the parent's bpf program and tp_event (hence prog_array) which is global for tracepoint - exit both process and its child -> release both events - first perf_event_detach_bpf_prog call will release tp_event->prog_array and second perf_event_detach_bpf_prog will crash, because tp_event->prog_array is NULL The fix makes sure the perf_event_detach_bpf_prog checks prog_array is valid before it tries to remove the bpf program from it. [1] https://lore.kernel.org/bpf/Z1MR6dCIKajNS6nU@krava/T/#m91dbf0688221ec7a7fc95e896a7ef9ff93b0b8ad",
      "id": "CVE-2024-56665",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T18:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "8a995259-b04d-4058-bc95-daee3b690fe9",
      "cwes": [
        362,
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf, sockmap: Fix race between element replace and close() Element replace (with a socket different from the one stored) may race with socket's close() link popping & unlinking. __sock_map_delete() unconditionally unrefs the (wrong) element: // set map[0] = s0 map_update_elem(map, 0, s0) // drop fd of s0 close(s0) sock_map_close() lock_sock(sk) (s0!) sock_map_remove_links(sk) link = sk_psock_link_pop() sock_map_unlink(sk, link) sock_map_delete_from_link // replace map[0] with s1 map_update_elem(map, 0, s1) sock_map_update_elem (s1!) lock_sock(sk) sock_map_update_common psock = sk_psock(sk) spin_lock(&stab->lock) osk = stab->sks[idx] sock_map_add_link(..., &stab->sks[idx]) sock_map_unref(osk, &stab->sks[idx]) psock = sk_psock(osk) sk_psock_put(sk, psock) if (refcount_dec_and_test(&psock)) sk_psock_drop(sk, psock) spin_unlock(&stab->lock) unlock_sock(sk) __sock_map_delete spin_lock(&stab->lock) sk = *psk // s1 replaced s0; sk == s1 if (!sk_test || sk_test == sk) // sk_test (s0) != sk (s1); no branch sk = xchg(psk, NULL) if (sk) sock_map_unref(sk, psk) // unref s1; sks[idx] will dangle psock = sk_psock(sk) sk_psock_put(sk, psock) if (refcount_dec_and_test()) sk_psock_drop(sk, psock) spin_unlock(&stab->lock) release_sock(sk) Then close(map) enqueues bpf_map_free_deferred, which finally calls sock_map_free(). This results in some refcount_t warnings along with a KASAN splat [1]. Fix __sock_map_delete(), do not allow sock_map_unref() on elements that may have been replaced. [1]: BUG: KASAN: slab-use-after-free in sock_map_free+0x10e/0x330 Write of size 4 at addr ffff88811f5b9100 by task kworker/u64:12/1063 CPU: 14 UID: 0 PID: 1063 Comm: kworker/u64:12 Not tainted 6.12.0+ #125 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014 Workqueue: events_unbound bpf_map_free_deferred Call Trace: <TASK> dump_stack_lvl+0x68/0x90 print_report+0x174/0x4f6 kasan_report+0xb9/0x190 kasan_check_range+0x10f/0x1e0 sock_map_free+0x10e/0x330 bpf_map_free_deferred+0x173/0x320 process_one_work+0x846/0x1420 worker_thread+0x5b3/0xf80 kthread+0x29e/0x360 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 1202: kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 __kasan_slab_alloc+0x85/0x90 kmem_cache_alloc_noprof+0x131/0x450 sk_prot_alloc+0x5b/0x220 sk_alloc+0x2c/0x870 unix_create1+0x88/0x8a0 unix_create+0xc5/0x180 __sock_create+0x241/0x650 __sys_socketpair+0x1ce/0x420 __x64_sys_socketpair+0x92/0x100 do_syscall_64+0x93/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 46: kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x60 __kasan_slab_free+0x4b/0x70 kmem_cache_free+0x1a1/0x590 __sk_destruct+0x388/0x5a0 sk_psock_destroy+0x73e/0xa50 process_one_work+0x846/0x1420 worker_thread+0x5b3/0xf80 kthread+0x29e/0x360 ret_from_fork+0x2d/0x70 ret_from_fork_asm+0x1a/0x30 The bu ---truncated---",
      "id": "CVE-2024-56664",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "81350b4f-ff01-44e2-855b-908a0ed1d95f",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: defer final 'struct net' free in netns dismantle Ilya reported a slab-use-after-free in dst_destroy [1] Issue is in xfrm6_net_init() and xfrm4_net_init() : They copy xfrm[46]_dst_ops_template into net->xfrm.xfrm[46]_dst_ops. But net structure might be freed before all the dst callbacks are called. So when dst_destroy() calls later : if (dst->ops->destroy) dst->ops->destroy(dst); dst->ops points to the old net->xfrm.xfrm[46]_dst_ops, which has been freed. See a relevant issue fixed in : ac888d58869b (\"net: do not delay dst_entries_add() in dst_release()\") A fix is to queue the 'struct net' to be freed after one another cleanup_net() round (and existing rcu_barrier()) [1] BUG: KASAN: slab-use-after-free in dst_destroy (net/core/dst.c:112) Read of size 8 at addr ffff8882137ccab0 by task swapper/37/0 Dec 03 05:46:18 kernel: CPU: 37 UID: 0 PID: 0 Comm: swapper/37 Kdump: loaded Not tainted 6.12.0 #67 Hardware name: Red Hat KVM/RHEL, BIOS 1.16.1-1.el9 04/01/2014 Call Trace: <IRQ> dump_stack_lvl (lib/dump_stack.c:124) print_address_description.constprop.0 (mm/kasan/report.c:378) ? dst_destroy (net/core/dst.c:112) print_report (mm/kasan/report.c:489) ? dst_destroy (net/core/dst.c:112) ? kasan_addr_to_slab (mm/kasan/common.c:37) kasan_report (mm/kasan/report.c:603) ? dst_destroy (net/core/dst.c:112) ? rcu_do_batch (kernel/rcu/tree.c:2567) dst_destroy (net/core/dst.c:112) rcu_do_batch (kernel/rcu/tree.c:2567) ? __pfx_rcu_do_batch (kernel/rcu/tree.c:2491) ? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4339 kernel/locking/lockdep.c:4406) rcu_core (kernel/rcu/tree.c:2825) handle_softirqs (kernel/softirq.c:554) __irq_exit_rcu (kernel/softirq.c:589 kernel/softirq.c:428 kernel/softirq.c:637) irq_exit_rcu (kernel/softirq.c:651) sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1049 arch/x86/kernel/apic/apic.c:1049) </IRQ> <TASK> asm_sysvec_apic_timer_interrupt (./arch/x86/include/asm/idtentry.h:702) RIP: 0010:default_idle (./arch/x86/include/asm/irqflags.h:37 ./arch/x86/include/asm/irqflags.h:92 arch/x86/kernel/process.c:743) Code: 00 4d 29 c8 4c 01 c7 4c 29 c2 e9 6e ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 90 0f 00 2d c7 c9 27 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90 RSP: 0018:ffff888100d2fe00 EFLAGS: 00000246 RAX: 00000000001870ed RBX: 1ffff110201a5fc2 RCX: ffffffffb61a3e46 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffb3d4d123 RBP: 0000000000000000 R08: 0000000000000001 R09: ffffed11c7e1835d R10: ffff888e3f0c1aeb R11: 0000000000000000 R12: 0000000000000000 R13: ffff888100d20000 R14: dffffc0000000000 R15: 0000000000000000 ? ct_kernel_exit.constprop.0 (kernel/context_tracking.c:148) ? cpuidle_idle_call (kernel/sched/idle.c:186) default_idle_call (./include/linux/cpuidle.h:143 kernel/sched/idle.c:118) cpuidle_idle_call (kernel/sched/idle.c:186) ? __pfx_cpuidle_idle_call (kernel/sched/idle.c:168) ? lock_release (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5848) ? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4347 kernel/locking/lockdep.c:4406) ? tsc_verify_tsc_adjust (arch/x86/kernel/tsc_sync.c:59) do_idle (kernel/sched/idle.c:326) cpu_startup_entry (kernel/sched/idle.c:423 (discriminator 1)) start_secondary (arch/x86/kernel/smpboot.c:202 arch/x86/kernel/smpboot.c:282) ? __pfx_start_secondary (arch/x86/kernel/smpboot.c:232) ? soft_restart_cpu (arch/x86/kernel/head_64.S:452) common_startup_64 (arch/x86/kernel/head_64.S:414) </TASK> Dec 03 05:46:18 kernel: Allocated by task 12184: kasan_save_stack (mm/kasan/common.c:48) kasan_save_track (./arch/x86/include/asm/current.h:49 mm/kasan/common.c:60 mm/kasan/common.c:69) __kasan_slab_alloc (mm/kasan/common.c:319 mm/kasan/common.c:345) kmem_cache_alloc_noprof (mm/slub.c:4085 mm/slub.c:4134 mm/slub.c:4141) copy_net_ns (net/core/net_namespace.c:421 net/core/net_namespace.c:480) create_new_namespaces ---truncated---",
      "id": "CVE-2024-56658",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:15Z"
      },
      "bom-ref": "ba642bbe-7763-4f73-94a6-2cc03bdd6a5c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ALSA: control: Avoid WARN() for symlink errors Using WARN() for showing the error of symlink creations don't give more information than telling that something goes wrong, since the usual code path is a lregister callback from each control element creation. More badly, the use of WARN() rather confuses fuzzer as if it were serious issues. This patch downgrades the warning messages to use the normal dev_err() instead of WARN(). For making it clearer, add the function name to the prefix, too.",
      "id": "CVE-2024-56657",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T19:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "01a02a69-6740-464b-b0ed-11de36eb36e6",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: can: hi311x: hi3110_can_ist(): fix potential use-after-free The commit a22bd630cfff (\"can: hi311x: do not report txerr and rxerr during bus-off\") removed the reporting of rxerr and txerr even in case of correct operation (i. e. not bus-off). The error count information added to the CAN frame after netif_rx() is a potential use after free, since there is no guarantee that the skb is in the same state. It might be freed or reused. Fix the issue by postponing the netif_rx() call in case of txerr and rxerr reporting.",
      "id": "CVE-2024-56651",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:17Z"
      },
      "bom-ref": "900d1d6a-6c8a-4d3c-95d5-83335e229cfc",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: Fix icmp host relookup triggering ip_rt_bug arp link failure may trigger ip_rt_bug while xfrm enabled, call trace is: WARNING: CPU: 0 PID: 0 at net/ipv4/route.c:1241 ip_rt_bug+0x14/0x20 Modules linked in: CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc6-00077-g2e1b3cc9d7f7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 RIP: 0010:ip_rt_bug+0x14/0x20 Call Trace: <IRQ> ip_send_skb+0x14/0x40 __icmp_send+0x42d/0x6a0 ipv4_link_failure+0xe2/0x1d0 arp_error_report+0x3c/0x50 neigh_invalidate+0x8d/0x100 neigh_timer_handler+0x2e1/0x330 call_timer_fn+0x21/0x120 __run_timer_base.part.0+0x1c9/0x270 run_timer_softirq+0x4c/0x80 handle_softirqs+0xac/0x280 irq_exit_rcu+0x62/0x80 sysvec_apic_timer_interrupt+0x77/0x90 The script below reproduces this scenario: ip xfrm policy add src 0.0.0.0/0 dst 0.0.0.0/0 \\ dir out priority 0 ptype main flag localok icmp ip l a veth1 type veth ip a a 192.168.141.111/24 dev veth0 ip l s veth0 up ping 192.168.141.155 -c 1 icmp_route_lookup() create input routes for locally generated packets while xfrm relookup ICMP traffic.Then it will set input route (dst->out = ip_rt_bug) to skb for DESTUNREACH. For ICMP err triggered by locally generated packets, dst->dev of output route is loopback. Generally, xfrm relookup verification is not required on loopback interfaces (net.ipv4.conf.lo.disable_xfrm = 1). Skip icmp relookup for locally generated packets to fix it.",
      "id": "CVE-2024-56647",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T19:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "407e3c64-86d2-4c9b-95de-69fff5f55338",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: sg: Fix slab-use-after-free read in sg_release() Fix a use-after-free bug in sg_release(), detected by syzbot with KASAN: BUG: KASAN: slab-use-after-free in lock_release+0x151/0xa30 kernel/locking/lockdep.c:5838 __mutex_unlock_slowpath+0xe2/0x750 kernel/locking/mutex.c:912 sg_release+0x1f4/0x2e0 drivers/scsi/sg.c:407 In sg_release(), the function kref_put(&sfp->f_ref, sg_remove_sfp) is called before releasing the open_rel_lock mutex. The kref_put() call may decrement the reference count of sfp to zero, triggering its cleanup through sg_remove_sfp(). This cleanup includes scheduling deferred work via sg_remove_sfp_usercontext(), which ultimately frees sfp. After kref_put(), sg_release() continues to unlock open_rel_lock and may reference sfp or sdp. If sfp has already been freed, this results in a slab-use-after-free error. Move the kref_put(&sfp->f_ref, sg_remove_sfp) call after unlocking the open_rel_lock mutex. This ensures: - No references to sfp or sdp occur after the reference count is decremented. - Cleanup functions such as sg_remove_sfp() and sg_remove_sfp_usercontext() can safely execute without impacting the mutex handling in sg_release(). The fix has been tested and validated by syzbot. This patch closes the bug reported at the following syzkaller link and ensures proper sequencing of resource cleanup and mutex operations, eliminating the risk of use-after-free errors in sg_release().",
      "id": "CVE-2024-56631",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:18Z"
      },
      "bom-ref": "e5fdf638-88bd-4422-aa12-898c3faed8e5",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm/mempolicy: fix migrate_to_node() assuming there is at least one VMA in a MM We currently assume that there is at least one VMA in a MM, which isn't true. So we might end up having find_vma() return NULL, to then de-reference NULL. So properly handle find_vma() returning NULL. This fixes the report: Oops: general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007] CPU: 1 UID: 0 PID: 6021 Comm: syz-executor284 Not tainted 6.12.0-rc7-syzkaller-00187-gf868cd251776 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024 RIP: 0010:migrate_to_node mm/mempolicy.c:1090 [inline] RIP: 0010:do_migrate_pages+0x403/0x6f0 mm/mempolicy.c:1194 Code: ... RSP: 0018:ffffc9000375fd08 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffc9000375fd78 RCX: 0000000000000000 RDX: ffff88807e171300 RSI: dffffc0000000000 RDI: ffff88803390c044 RBP: ffff88807e171428 R08: 0000000000000014 R09: fffffbfff2039ef1 R10: ffffffff901cf78f R11: 0000000000000000 R12: 0000000000000003 R13: ffffc9000375fe90 R14: ffffc9000375fe98 R15: ffffc9000375fdf8 FS: 00005555919e1380(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005555919e1ca8 CR3: 000000007f12a000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> kernel_migrate_pages+0x5b2/0x750 mm/mempolicy.c:1709 __do_sys_migrate_pages mm/mempolicy.c:1727 [inline] __se_sys_migrate_pages mm/mempolicy.c:1723 [inline] __x64_sys_migrate_pages+0x96/0x100 mm/mempolicy.c:1723 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f [akpm@linux-foundation.org: add unlikely()]",
      "id": "CVE-2024-56611",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T17:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "76741781-5322-4e9d-899c-7d82129e5a84",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix out-of-bounds access in 'dcn21_link_encoder_create' An issue was identified in the dcn21_link_encoder_create function where an out-of-bounds access could occur when the hpd_source index was used to reference the link_enc_hpd_regs array. This array has a fixed size and the index was not being checked against the array's bounds before accessing it. This fix adds a conditional check to ensure that the hpd_source index is within the valid range of the link_enc_hpd_regs array. If the index is out of bounds, the function now returns NULL to prevent undefined behavior. References: [ 65.920507] ------------[ cut here ]------------ [ 65.920510] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn21/dcn21_resource.c:1312:29 [ 65.920519] index 7 is out of range for type 'dcn10_link_enc_hpd_registers [5]' [ 65.920523] CPU: 3 PID: 1178 Comm: modprobe Tainted: G OE 6.8.0-cleanershaderfeatureresetasdntipmi200nv2132 #13 [ 65.920525] Hardware name: AMD Majolica-RN/Majolica-RN, BIOS WMJ0429N_Weekly_20_04_2 04/29/2020 [ 65.920527] Call Trace: [ 65.920529] <TASK> [ 65.920532] dump_stack_lvl+0x48/0x70 [ 65.920541] dump_stack+0x10/0x20 [ 65.920543] __ubsan_handle_out_of_bounds+0xa2/0xe0 [ 65.920549] dcn21_link_encoder_create+0xd9/0x140 [amdgpu] [ 65.921009] link_create+0x6d3/0xed0 [amdgpu] [ 65.921355] create_links+0x18a/0x4e0 [amdgpu] [ 65.921679] dc_create+0x360/0x720 [amdgpu] [ 65.921999] ? dmi_matches+0xa0/0x220 [ 65.922004] amdgpu_dm_init+0x2b6/0x2c90 [amdgpu] [ 65.922342] ? console_unlock+0x77/0x120 [ 65.922348] ? dev_printk_emit+0x86/0xb0 [ 65.922354] dm_hw_init+0x15/0x40 [amdgpu] [ 65.922686] amdgpu_device_init+0x26a8/0x33a0 [amdgpu] [ 65.922921] amdgpu_driver_load_kms+0x1b/0xa0 [amdgpu] [ 65.923087] amdgpu_pci_probe+0x1b7/0x630 [amdgpu] [ 65.923087] local_pci_probe+0x4b/0xb0 [ 65.923087] pci_device_probe+0xc8/0x280 [ 65.923087] really_probe+0x187/0x300 [ 65.923087] __driver_probe_device+0x85/0x130 [ 65.923087] driver_probe_device+0x24/0x110 [ 65.923087] __driver_attach+0xac/0x1d0 [ 65.923087] ? __pfx___driver_attach+0x10/0x10 [ 65.923087] bus_for_each_dev+0x7d/0xd0 [ 65.923087] driver_attach+0x1e/0x30 [ 65.923087] bus_add_driver+0xf2/0x200 [ 65.923087] driver_register+0x64/0x130 [ 65.923087] ? __pfx_amdgpu_init+0x10/0x10 [amdgpu] [ 65.923087] __pci_register_driver+0x61/0x70 [ 65.923087] amdgpu_init+0x7d/0xff0 [amdgpu] [ 65.923087] do_one_initcall+0x49/0x310 [ 65.923087] ? kmalloc_trace+0x136/0x360 [ 65.923087] do_init_module+0x6a/0x270 [ 65.923087] load_module+0x1fce/0x23a0 [ 65.923087] init_module_from_file+0x9c/0xe0 [ 65.923087] ? init_module_from_file+0x9c/0xe0 [ 65.923087] idempotent_init_module+0x179/0x230 [ 65.923087] __x64_sys_finit_module+0x5d/0xa0 [ 65.923087] do_syscall_64+0x76/0x120 [ 65.923087] entry_SYSCALL_64_after_hwframe+0x6e/0x76 [ 65.923087] RIP: 0033:0x7f2d80f1e88d [ 65.923087] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48 [ 65.923087] RSP: 002b:00007ffc7bc1aa78 EFLAGS: 00000246 ORIG_RAX: 0000000000000139 [ 65.923087] RAX: ffffffffffffffda RBX: 0000564c9c1db130 RCX: 00007f2d80f1e88d [ 65.923087] RDX: 0000000000000000 RSI: 0000564c9c1e5480 RDI: 000000000000000f [ 65.923087] RBP: 0000000000040000 R08: 0000000000000000 R09: 0000000000000002 [ 65.923087] R10: 000000000000000f R11: 0000000000000246 R12: 0000564c9c1e5480 [ 65.923087] R13: 0000564c9c1db260 R14: 0000000000000000 R15: 0000564c9c1e54b0 [ 65.923087] </TASK> [ 65.923927] ---[ end trace ]---",
      "id": "CVE-2024-56608",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "212fdf90-3fb2-432f-87e6-27da418ef6a4",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc() bt_sock_alloc() attaches allocated sk object to the provided sock object. If rfcomm_dlc_alloc() fails, we release the sk object, but leave the dangling pointer in the sock object, which may cause use-after-free. Fix this by swapping calls to bt_sock_alloc() and rfcomm_dlc_alloc().",
      "id": "CVE-2024-56604",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:20Z"
      },
      "bom-ref": "ddd10960-84fd-46f2-8c64-2c036f9434ff",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath10k: avoid NULL pointer error during sdio remove When running 'rmmod ath10k', ath10k_sdio_remove() will free sdio workqueue by destroy_workqueue(). But if CONFIG_INIT_ON_FREE_DEFAULT_ON is set to yes, kernel panic will happen: Call trace: destroy_workqueue+0x1c/0x258 ath10k_sdio_remove+0x84/0x94 sdio_bus_remove+0x50/0x16c device_release_driver_internal+0x188/0x25c device_driver_detach+0x20/0x2c This is because during 'rmmod ath10k', ath10k_sdio_remove() will call ath10k_core_destroy() before destroy_workqueue(). wiphy_dev_release() will finally be called in ath10k_core_destroy(). This function will free struct cfg80211_registered_device *rdev and all its members, including wiphy, dev and the pointer of sdio workqueue. Then the pointer of sdio workqueue will be set to NULL due to CONFIG_INIT_ON_FREE_DEFAULT_ON. After device release, destroy_workqueue() will use NULL pointer then the kernel panic happen. Call trace: ath10k_sdio_remove ->ath10k_core_unregister \u2026\u2026 ->ath10k_core_stop ->ath10k_hif_stop ->ath10k_sdio_irq_disable ->ath10k_hif_power_down ->del_timer_sync(&ar_sdio->sleep_timer) ->ath10k_core_destroy ->ath10k_mac_destroy ->ieee80211_free_hw ->wiphy_free \u2026\u2026 ->wiphy_dev_release ->destroy_workqueue Need to call destroy_workqueue() before ath10k_core_destroy(), free the work queue buffer first and then free pointer of work queue by ath10k_core_destroy(). This order matches the error path order in ath10k_sdio_probe(). No work will be queued on sdio workqueue between it is destroyed and ath10k_core_destroy() is called. Based on the call_stack above, the reason is: Only ath10k_sdio_sleep_timer_handler(), ath10k_sdio_hif_tx_sg() and ath10k_sdio_irq_disable() will queue work on sdio workqueue. Sleep timer will be deleted before ath10k_core_destroy() in ath10k_hif_power_down(). ath10k_sdio_irq_disable() only be called in ath10k_hif_stop(). ath10k_core_unregister() will call ath10k_hif_power_down() to stop hif bus, so ath10k_sdio_hif_tx_sg() won't be called anymore. Tested-on: QCA6174 hw3.2 SDIO WLAN.RMH.4.4.1-00189",
      "id": "CVE-2024-56599",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:21Z"
      },
      "bom-ref": "f09688fa-af46-48ab-bc1a-5a716ad7335c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: hisi_sas: Create all dump files during debugfs initialization For the current debugfs of hisi_sas, after user triggers dump, the driver allocate memory space to save the register information and create debugfs files to display the saved information. In this process, the debugfs files created after each dump. Therefore, when the dump is triggered while the driver is unbind, the following hang occurs: [67840.853907] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0 [67840.862947] Mem abort info: [67840.865855] ESR = 0x0000000096000004 [67840.869713] EC = 0x25: DABT (current EL), IL = 32 bits [67840.875125] SET = 0, FnV = 0 [67840.878291] EA = 0, S1PTW = 0 [67840.881545] FSC = 0x04: level 0 translation fault [67840.886528] Data abort info: [67840.889524] ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 [67840.895117] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [67840.900284] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [67840.905709] user pgtable: 4k pages, 48-bit VAs, pgdp=0000002803a1f000 [67840.912263] [00000000000000a0] pgd=0000000000000000, p4d=0000000000000000 [67840.919177] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [67840.996435] pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [67841.003628] pc : down_write+0x30/0x98 [67841.007546] lr : start_creating.part.0+0x60/0x198 [67841.012495] sp : ffff8000b979ba20 [67841.016046] x29: ffff8000b979ba20 x28: 0000000000000010 x27: 0000000000024b40 [67841.023412] x26: 0000000000000012 x25: ffff20202b355ae8 x24: ffff20202b35a8c8 [67841.030779] x23: ffffa36877928208 x22: ffffa368b4972240 x21: ffff8000b979bb18 [67841.038147] x20: ffff00281dc1e3c0 x19: fffffffffffffffe x18: 0000000000000020 [67841.045515] x17: 0000000000000000 x16: ffffa368b128a530 x15: ffffffffffffffff [67841.052888] x14: ffff8000b979bc18 x13: ffffffffffffffff x12: ffff8000b979bb18 [67841.060263] x11: 0000000000000000 x10: 0000000000000000 x9 : ffffa368b1289b18 [67841.067640] x8 : 0000000000000012 x7 : 0000000000000000 x6 : 00000000000003a9 [67841.075014] x5 : 0000000000000000 x4 : ffff002818c5cb00 x3 : 0000000000000001 [67841.082388] x2 : 0000000000000000 x1 : ffff002818c5cb00 x0 : 00000000000000a0 [67841.089759] Call trace: [67841.092456] down_write+0x30/0x98 [67841.096017] start_creating.part.0+0x60/0x198 [67841.100613] debugfs_create_dir+0x48/0x1f8 [67841.104950] debugfs_create_files_v3_hw+0x88/0x348 [hisi_sas_v3_hw] [67841.111447] debugfs_snapshot_regs_v3_hw+0x708/0x798 [hisi_sas_v3_hw] [67841.118111] debugfs_trigger_dump_v3_hw_write+0x9c/0x120 [hisi_sas_v3_hw] [67841.125115] full_proxy_write+0x68/0xc8 [67841.129175] vfs_write+0xd8/0x3f0 [67841.132708] ksys_write+0x70/0x108 [67841.136317] __arm64_sys_write+0x24/0x38 [67841.140440] invoke_syscall+0x50/0x128 [67841.144385] el0_svc_common.constprop.0+0xc8/0xf0 [67841.149273] do_el0_svc+0x24/0x38 [67841.152773] el0_svc+0x38/0xd8 [67841.156009] el0t_64_sync_handler+0xc0/0xc8 [67841.160361] el0t_64_sync+0x1a4/0x1a8 [67841.164189] Code: b9000882 d2800002 d2800023 f9800011 (c85ffc05) [67841.170443] ---[ end trace 0000000000000000 ]--- To fix this issue, create all directories and files during debugfs initialization. In this way, the driver only needs to allocate memory space to save information each time the user triggers dumping.",
      "id": "CVE-2024-56588",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:23Z"
      },
      "bom-ref": "1407d889-4bce-4493-9b50-dc8a50431c18",
      "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: ad7923: Fix buffer overflow for tx_buf and ring_xfer The AD7923 was updated to support devices with 8 channels, but the size of tx_buf and ring_xfer was not increased accordingly, leading to a potential buffer overflow in ad7923_update_scan_mode().",
      "id": "CVE-2024-56557",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "c36b1ab3-f763-4eb1-88c3-766180e612fe",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: fix usage slab after free [ +0.000021] BUG: KASAN: slab-use-after-free in drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000027] Read of size 8 at addr ffff8881b8605f88 by task amd_pci_unplug/2147 [ +0.000023] CPU: 6 PID: 2147 Comm: amd_pci_unplug Not tainted 6.10.0+ #1 [ +0.000016] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020 [ +0.000016] Call Trace: [ +0.000008] <TASK> [ +0.000009] dump_stack_lvl+0x76/0xa0 [ +0.000017] print_report+0xce/0x5f0 [ +0.000017] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000019] ? srso_return_thunk+0x5/0x5f [ +0.000015] ? kasan_complete_mode_report_info+0x72/0x200 [ +0.000016] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000019] kasan_report+0xbe/0x110 [ +0.000015] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000023] __asan_report_load8_noabort+0x14/0x30 [ +0.000014] drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched] [ +0.000020] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? __kasan_check_write+0x14/0x30 [ +0.000016] ? __pfx_drm_sched_entity_flush+0x10/0x10 [gpu_sched] [ +0.000020] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? __kasan_check_write+0x14/0x30 [ +0.000013] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? enable_work+0x124/0x220 [ +0.000015] ? __pfx_enable_work+0x10/0x10 [ +0.000013] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? free_large_kmalloc+0x85/0xf0 [ +0.000016] drm_sched_entity_destroy+0x18/0x30 [gpu_sched] [ +0.000020] amdgpu_vce_sw_fini+0x55/0x170 [amdgpu] [ +0.000735] ? __kasan_check_read+0x11/0x20 [ +0.000016] vce_v4_0_sw_fini+0x80/0x110 [amdgpu] [ +0.000726] amdgpu_device_fini_sw+0x331/0xfc0 [amdgpu] [ +0.000679] ? mutex_unlock+0x80/0xe0 [ +0.000017] ? __pfx_amdgpu_device_fini_sw+0x10/0x10 [amdgpu] [ +0.000662] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? __kasan_check_write+0x14/0x30 [ +0.000013] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? mutex_unlock+0x80/0xe0 [ +0.000016] amdgpu_driver_release_kms+0x16/0x80 [amdgpu] [ +0.000663] drm_minor_release+0xc9/0x140 [drm] [ +0.000081] drm_release+0x1fd/0x390 [drm] [ +0.000082] __fput+0x36c/0xad0 [ +0.000018] __fput_sync+0x3c/0x50 [ +0.000014] __x64_sys_close+0x7d/0xe0 [ +0.000014] x64_sys_call+0x1bc6/0x2680 [ +0.000014] do_syscall_64+0x70/0x130 [ +0.000014] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? irqentry_exit_to_user_mode+0x60/0x190 [ +0.000015] ? srso_return_thunk+0x5/0x5f [ +0.000014] ? irqentry_exit+0x43/0x50 [ +0.000012] ? srso_return_thunk+0x5/0x5f [ +0.000013] ? exc_page_fault+0x7c/0x110 [ +0.000015] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ +0.000014] RIP: 0033:0x7ffff7b14f67 [ +0.000013] Code: ff e8 0d 16 02 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 73 ba f7 ff [ +0.000026] RSP: 002b:00007fffffffe378 EFLAGS: 00000246 ORIG_RAX: 0000000000000003 [ +0.000019] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffff7b14f67 [ +0.000014] RDX: 0000000000000000 RSI: 00007ffff7f6f47a RDI: 0000000000000003 [ +0.000014] RBP: 00007fffffffe3a0 R08: 0000555555569890 R09: 0000000000000000 [ +0.000014] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fffffffe5c8 [ +0.000013] R13: 00005555555552a9 R14: 0000555555557d48 R15: 00007ffff7ffd040 [ +0.000020] </TASK> [ +0.000016] Allocated by task 383 on cpu 7 at 26.880319s: [ +0.000014] kasan_save_stack+0x28/0x60 [ +0.000008] kasan_save_track+0x18/0x70 [ +0.000007] kasan_save_alloc_info+0x38/0x60 [ +0.000007] __kasan_kmalloc+0xc1/0xd0 [ +0.000007] kmalloc_trace_noprof+0x180/0x380 [ +0.000007] drm_sched_init+0x411/0xec0 [gpu_sched] [ +0.000012] amdgpu_device_init+0x695f/0xa610 [amdgpu] [ +0.000658] amdgpu_driver_load_kms+0x1a/0x120 [amdgpu] [ +0.000662] amdgpu_pci_p ---truncated---",
      "id": "CVE-2024-56551",
      "published": "2024-12-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_UDMABUF is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "556f0a2d-b88c-43c8-9d38-6e5c78b45f24",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: udmabuf: change folios array from kmalloc to kvmalloc When PAGE_SIZE 4096, MAX_PAGE_ORDER 10, 64bit machine, page_alloc only support 4MB. If above this, trigger this warn and return NULL. udmabuf can change size limit, if change it to 3072(3GB), and then alloc 3GB udmabuf, will fail create. [ 4080.876581] ------------[ cut here ]------------ [ 4080.876843] WARNING: CPU: 3 PID: 2015 at mm/page_alloc.c:4556 __alloc_pages+0x2c8/0x350 [ 4080.878839] RIP: 0010:__alloc_pages+0x2c8/0x350 [ 4080.879470] Call Trace: [ 4080.879473] <TASK> [ 4080.879473] ? __alloc_pages+0x2c8/0x350 [ 4080.879475] ? __warn.cold+0x8e/0xe8 [ 4080.880647] ? __alloc_pages+0x2c8/0x350 [ 4080.880909] ? report_bug+0xff/0x140 [ 4080.881175] ? handle_bug+0x3c/0x80 [ 4080.881556] ? exc_invalid_op+0x17/0x70 [ 4080.881559] ? asm_exc_invalid_op+0x1a/0x20 [ 4080.882077] ? udmabuf_create+0x131/0x400 Because MAX_PAGE_ORDER, kmalloc can max alloc 4096 * (1 << 10), 4MB memory, each array entry is pointer(8byte), so can save 524288 pages(2GB). Further more, costly order(order 3) may not be guaranteed that it can be applied for, due to fragmentation. This patch change udmabuf array use kvmalloc_array, this can fallback alloc into vmalloc, which can guarantee allocation for any size and does not affect the performance of kmalloc allocations.",
      "id": "CVE-2024-56544",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T15:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "5d55f514-bcd0-4542-afd5-6aed7e07a548",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm: zynqmp_kms: Unplug DRM device before removal Prevent userspace accesses to the DRM device from causing use-after-frees by unplugging the device before we remove it. This causes any further userspace accesses to result in an error without further calls into this driver's internals.",
      "id": "CVE-2024-56538",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:24Z"
      },
      "bom-ref": "c64b800e-1603-4ba2-ba88-fe5bae16001c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Move events notifier registration to be after device registration Move pkey change work initialization and cleanup from device resources stage to notifier stage, since this is the stage which handles this work events. Fix a race between the device deregistration and pkey change work by moving MLX5_IB_STAGE_DEVICE_NOTIFIER to be after MLX5_IB_STAGE_IB_REG in order to ensure that the notifier is deregistered before the device during cleanup. Which ensures there are no works that are being executed after the device has already unregistered which can cause the panic below. BUG: kernel NULL pointer dereference, address: 0000000000000000 PGD 0 P4D 0 Oops: 0000 [#1] PREEMPT SMP PTI CPU: 1 PID: 630071 Comm: kworker/1:2 Kdump: loaded Tainted: G W OE --------- --- 5.14.0-162.6.1.el9_1.x86_64 #1 Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS 090008 02/27/2023 Workqueue: events pkey_change_handler [mlx5_ib] RIP: 0010:setup_qp+0x38/0x1f0 [mlx5_ib] Code: ee 41 54 45 31 e4 55 89 f5 53 48 89 fb 48 83 ec 20 8b 77 08 65 48 8b 04 25 28 00 00 00 48 89 44 24 18 48 8b 07 48 8d 4c 24 16 <4c> 8b 38 49 8b 87 80 0b 00 00 4c 89 ff 48 8b 80 08 05 00 00 8b 40 RSP: 0018:ffffbcc54068be20 EFLAGS: 00010282 RAX: 0000000000000000 RBX: ffff954054494128 RCX: ffffbcc54068be36 RDX: ffff954004934000 RSI: 0000000000000001 RDI: ffff954054494128 RBP: 0000000000000023 R08: ffff954001be2c20 R09: 0000000000000001 R10: ffff954001be2c20 R11: ffff9540260133c0 R12: 0000000000000000 R13: 0000000000000023 R14: 0000000000000000 R15: ffff9540ffcb0905 FS: 0000000000000000(0000) GS:ffff9540ffc80000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000000000 CR3: 000000010625c001 CR4: 00000000003706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: mlx5_ib_gsi_pkey_change+0x20/0x40 [mlx5_ib] process_one_work+0x1e8/0x3c0 worker_thread+0x50/0x3b0 ? rescuer_thread+0x380/0x380 kthread+0x149/0x170 ? set_kthread_struct+0x50/0x50 ret_from_fork+0x22/0x30 Modules linked in: rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) mlx5_fwctl(OE) fwctl(OE) ib_uverbs(OE) mlx5_core(OE) mlxdevm(OE) ib_core(OE) mlx_compat(OE) psample mlxfw(OE) tls knem(OE) netconsole nfsv3 nfs_acl nfs lockd grace fscache netfs qrtr rfkill sunrpc intel_rapl_msr intel_rapl_common rapl hv_balloon hv_utils i2c_piix4 pcspkr joydev fuse ext4 mbcache jbd2 sr_mod sd_mod cdrom t10_pi sg ata_generic pci_hyperv pci_hyperv_intf hyperv_drm drm_shmem_helper drm_kms_helper hv_storvsc syscopyarea hv_netvsc sysfillrect sysimgblt hid_hyperv fb_sys_fops scsi_transport_fc hyperv_keyboard drm ata_piix crct10dif_pclmul crc32_pclmul crc32c_intel libata ghash_clmulni_intel hv_vmbus serio_raw [last unloaded: ib_core] CR2: 0000000000000000 ---[ end trace f6f8be4eae12f7bc ]---",
      "id": "CVE-2024-53224",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T15:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:26Z"
      },
      "bom-ref": "7e181c3e-d50c-40e7-8941-b9d988f55b3e",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix null-ptr-deref in f2fs_submit_page_bio() There's issue as follows when concurrently installing the f2fs.ko module and mounting the f2fs file system: KASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027] RIP: 0010:__bio_alloc+0x2fb/0x6c0 [f2fs] Call Trace: <TASK> f2fs_submit_page_bio+0x126/0x8b0 [f2fs] __get_meta_page+0x1d4/0x920 [f2fs] get_checkpoint_version.constprop.0+0x2b/0x3c0 [f2fs] validate_checkpoint+0xac/0x290 [f2fs] f2fs_get_valid_checkpoint+0x207/0x950 [f2fs] f2fs_fill_super+0x1007/0x39b0 [f2fs] mount_bdev+0x183/0x250 legacy_get_tree+0xf4/0x1e0 vfs_get_tree+0x88/0x340 do_new_mount+0x283/0x5e0 path_mount+0x2b2/0x15b0 __x64_sys_mount+0x1fe/0x270 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Above issue happens as the biset of the f2fs file system is not initialized before register \"f2fs_fs_type\". To address above issue just register \"f2fs_fs_type\" at the last in init_f2fs_fs(). Ensure that all f2fs file system resources are initialized.",
      "id": "CVE-2024-53221",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-17T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:27Z"
      },
      "bom-ref": "19556e95-5b63-42a3-93e1-40a016fb5096",
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix race in concurrent f2fs_stop_gc_thread In my test case, concurrent calls to f2fs shutdown report the following stack trace: Oops: general protection fault, probably for non-canonical address 0xc6cfff63bb5513fc: 0000 [#1] PREEMPT SMP PTI CPU: 0 UID: 0 PID: 678 Comm: f2fs_rep_shutdo Not tainted 6.12.0-rc5-next-20241029-g6fb2fa9805c5-dirty #85 Call Trace: <TASK> ? show_regs+0x8b/0xa0 ? __die_body+0x26/0xa0 ? die_addr+0x54/0x90 ? exc_general_protection+0x24b/0x5c0 ? asm_exc_general_protection+0x26/0x30 ? kthread_stop+0x46/0x390 f2fs_stop_gc_thread+0x6c/0x110 f2fs_do_shutdown+0x309/0x3a0 f2fs_ioc_shutdown+0x150/0x1c0 __f2fs_ioctl+0xffd/0x2ac0 f2fs_ioctl+0x76/0xe0 vfs_ioctl+0x23/0x60 __x64_sys_ioctl+0xce/0xf0 x64_sys_call+0x2b1b/0x4540 do_syscall_64+0xa7/0x240 entry_SYSCALL_64_after_hwframe+0x76/0x7e The root cause is a race condition in f2fs_stop_gc_thread() called from different f2fs shutdown paths: [CPU0] [CPU1] ---------------------- ----------------------- f2fs_stop_gc_thread f2fs_stop_gc_thread gc_th = sbi->gc_thread gc_th = sbi->gc_thread kfree(gc_th) sbi->gc_thread = NULL < gc_th != NULL > kthread_stop(gc_th->f2fs_gc_task) //UAF The commit c7f114d864ac (\"f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()\") attempted to fix this issue by using a read semaphore to prevent races between shutdown and remount threads, but it fails to prevent all race conditions. Fix it by converting to write lock of s_umount in f2fs_do_shutdown().",
      "id": "CVE-2024-53218",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:29Z"
      },
      "bom-ref": "4eb267be-c450-4a7b-ba4f-dc84143bcb96",
      "description": "In the Linux kernel, the following vulnerability has been resolved: nfsd: release svc_expkey/svc_export with rcu_work The last reference for `cache_head` can be reduced to zero in `c_show` and `e_show`(using `rcu_read_lock` and `rcu_read_unlock`). Consequently, `svc_export_put` and `expkey_put` will be invoked, leading to two issues: 1. The `svc_export_put` will directly free ex_uuid. However, `e_show`/`c_show` will access `ex_uuid` after `cache_put`, which can trigger a use-after-free issue, shown below. ================================================================== BUG: KASAN: slab-use-after-free in svc_export_show+0x362/0x430 [nfsd] Read of size 1 at addr ff11000010fdc120 by task cat/870 CPU: 1 UID: 0 PID: 870 Comm: cat Not tainted 6.12.0-rc3+ #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014 Call Trace: <TASK> dump_stack_lvl+0x53/0x70 print_address_description.constprop.0+0x2c/0x3a0 print_report+0xb9/0x280 kasan_report+0xae/0xe0 svc_export_show+0x362/0x430 [nfsd] c_show+0x161/0x390 [sunrpc] seq_read_iter+0x589/0x770 seq_read+0x1e5/0x270 proc_reg_read+0xe1/0x140 vfs_read+0x125/0x530 ksys_read+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Allocated by task 830: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 __kasan_kmalloc+0x8f/0xa0 __kmalloc_node_track_caller_noprof+0x1bc/0x400 kmemdup_noprof+0x22/0x50 svc_export_parse+0x8a9/0xb80 [nfsd] cache_do_downcall+0x71/0xa0 [sunrpc] cache_write_procfs+0x8e/0xd0 [sunrpc] proc_reg_write+0xe1/0x140 vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 868: kasan_save_stack+0x20/0x40 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x37/0x50 kfree+0xf3/0x3e0 svc_export_put+0x87/0xb0 [nfsd] cache_purge+0x17f/0x1f0 [sunrpc] nfsd_destroy_serv+0x226/0x2d0 [nfsd] nfsd_svc+0x125/0x1e0 [nfsd] write_threads+0x16a/0x2a0 [nfsd] nfsctl_transaction_write+0x74/0xa0 [nfsd] vfs_write+0x1a5/0x6d0 ksys_write+0xc1/0x160 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e 2. We cannot sleep while using `rcu_read_lock`/`rcu_read_unlock`. However, `svc_export_put`/`expkey_put` will call path_put, which subsequently triggers a sleeping operation due to the following `dput`. ============================= WARNING: suspicious RCU usage 5.10.0-dirty #141 Not tainted ----------------------------- ... Call Trace: dump_stack+0x9a/0xd0 ___might_sleep+0x231/0x240 dput+0x39/0x600 path_put+0x1b/0x30 svc_export_put+0x17/0x80 e_show+0x1c9/0x200 seq_read_iter+0x63f/0x7c0 seq_read+0x226/0x2d0 vfs_read+0x113/0x2c0 ksys_read+0xc9/0x170 do_syscall_64+0x33/0x40 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Fix these issues by using `rcu_work` to help release `svc_expkey`/`svc_export`. This approach allows for an asynchronous context to invoke `path_put` and also facilitates the freeing of `uuid/exp/key` after an RCU grace period.",
      "id": "CVE-2024-53216",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "S390 architecture not used",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "4c81b361-7ab9-4543-b732-8ebcc9a38769",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: s390/iucv: MSG_PEEK causes memory leak in iucv_sock_destruct() Passing MSG_PEEK flag to skb_recv_datagram() increments skb refcount (skb->users) and iucv_sock_recvmsg() does not decrement skb refcount at exit. This results in skb memory leak in skb_queue_purge() and WARN_ON in iucv_sock_destruct() during socket close. To fix this decrease skb refcount by one if MSG_PEEK is set in order to prevent memory leak and WARN_ON. WARNING: CPU: 2 PID: 6292 at net/iucv/af_iucv.c:286 iucv_sock_destruct+0x144/0x1a0 [af_iucv] CPU: 2 PID: 6292 Comm: afiucv_test_msg Kdump: loaded Tainted: G W 6.10.0-rc7 #1 Hardware name: IBM 3931 A01 704 (z/VM 7.3.0) Call Trace: [<001587c682c4aa98>] iucv_sock_destruct+0x148/0x1a0 [af_iucv] [<001587c682c4a9d0>] iucv_sock_destruct+0x80/0x1a0 [af_iucv] [<001587c704117a32>] __sk_destruct+0x52/0x550 [<001587c704104a54>] __sock_release+0xa4/0x230 [<001587c704104c0c>] sock_close+0x2c/0x40 [<001587c702c5f5a8>] __fput+0x2e8/0x970 [<001587c7024148c4>] task_work_run+0x1c4/0x2c0 [<001587c7023b0716>] do_exit+0x996/0x1050 [<001587c7023b13aa>] do_group_exit+0x13a/0x360 [<001587c7023b1626>] __s390x_sys_exit_group+0x56/0x60 [<001587c7022bccca>] do_syscall+0x27a/0x380 [<001587c7049a6a0c>] __do_syscall+0x9c/0x160 [<001587c7049ce8a8>] system_call+0x70/0x98 Last Breaking-Event-Address: [<001587c682c4a9d4>] iucv_sock_destruct+0x84/0x1a0 [af_iucv]",
      "id": "CVE-2024-53210",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-14T15:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "1b9d40cc-ab6e-4c4d-ae4a-c02d3a21993b",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: typec: fix potential array underflow in ucsi_ccg_sync_control() The \"command\" variable can be controlled by the user via debugfs. The worry is that if con_index is zero then \"&uc->ucsi->connector[con_index - 1]\" would be an array underflow.",
      "id": "CVE-2024-53203",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:30Z"
      },
      "bom-ref": "1e7efb05-15a8-41ce-8a4b-a952ed13843a",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring: check for overflows in io_pin_pages WARNING: CPU: 0 PID: 5834 at io_uring/memmap.c:144 io_pin_pages+0x149/0x180 io_uring/memmap.c:144 CPU: 0 UID: 0 PID: 5834 Comm: syz-executor825 Not tainted 6.12.0-next-20241118-syzkaller #0 Call Trace: <TASK> __io_uaddr_map+0xfb/0x2d0 io_uring/memmap.c:183 io_rings_map io_uring/io_uring.c:2611 [inline] io_allocate_scq_urings+0x1c0/0x650 io_uring/io_uring.c:3470 io_uring_create+0x5b5/0xc00 io_uring/io_uring.c:3692 io_uring_setup io_uring/io_uring.c:3781 [inline] ... </TASK> io_pin_pages()'s uaddr parameter came directly from the user and can be garbage. Don't just add size to it as it can overflow.",
      "id": "CVE-2024-53187",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-16T16:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "fa440b71-d56f-446a-8c79-389210afd208",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix use-after-free of signing key Customers have reported use-after-free in @ses->auth_key.response with SMB2.1 + sign mounts which occurs due to following race: task A task B cifs_mount() dfs_mount_share() get_session() cifs_mount_get_session() cifs_send_recv() cifs_get_smb_ses() compound_send_recv() cifs_setup_session() smb2_setup_request() kfree_sensitive() smb2_calc_signature() crypto_shash_setkey() *UAF* Fix this by ensuring that we have a valid @ses->auth_key.response by checking whether @ses->ses_status is SES_GOOD or SES_EXITING with @ses->ses_lock held. After commit 24a9799aa8ef (\"smb: client: fix UAF in smb2_reconnect_server()\"), we made sure to call ->logoff() only when @ses was known to be good (e.g. valid ->auth_key.response), so it's safe to access signing key when @ses->ses_status == SES_EXITING.",
      "id": "CVE-2024-53179",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-10T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:32Z"
      },
      "bom-ref": "7e05dc4f-d58b-48de-a4a0-f0dfe6c746dc",
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: prevent use-after-free due to open_cached_dir error paths If open_cached_dir() encounters an error parsing the lease from the server, the error handling may race with receiving a lease break, resulting in open_cached_dir() freeing the cfid while the queued work is pending. Update open_cached_dir() to drop refs rather than directly freeing the cfid. Have cached_dir_lease_break(), cfids_laundromat_worker(), and invalidate_all_cached_dirs() clear has_lease immediately while still holding cfids->cfid_list_lock, and then use this to also simplify the reference counting in cfids_laundromat_worker() and invalidate_all_cached_dirs(). Fixes this KASAN splat (which manually injects an error and lease break in open_cached_dir()): ================================================================== BUG: KASAN: slab-use-after-free in smb2_cached_lease_break+0x27/0xb0 Read of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65 CPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Workqueue: cifsiod smb2_cached_lease_break Call Trace: <TASK> dump_stack_lvl+0x77/0xb0 print_report+0xce/0x660 kasan_report+0xd3/0x110 smb2_cached_lease_break+0x27/0xb0 process_one_work+0x50a/0xc50 worker_thread+0x2ba/0x530 kthread+0x17c/0x1c0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30 </TASK> Allocated by task 2464: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 __kasan_kmalloc+0xaa/0xb0 open_cached_dir+0xa7d/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 2464: kasan_save_stack+0x33/0x60 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x51/0x70 kfree+0x174/0x520 open_cached_dir+0x97f/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e Last potentially related work creation: kasan_save_stack+0x33/0x60 __kasan_record_aux_stack+0xad/0xc0 insert_work+0x32/0x100 __queue_work+0x5c9/0x870 queue_work_on+0x82/0x90 open_cached_dir+0x1369/0x1fb0 smb2_query_path_info+0x43c/0x6e0 cifs_get_fattr+0x346/0xf10 cifs_get_inode_info+0x157/0x210 cifs_revalidate_dentry_attr+0x2d1/0x460 cifs_getattr+0x173/0x470 vfs_statx_path+0x10f/0x160 vfs_statx+0xe9/0x150 vfs_fstatat+0x5e/0xc0 __do_sys_newfstatat+0x91/0xf0 do_syscall_64+0x95/0x1a0 entry_SYSCALL_64_after_hwframe+0x76/0x7e The buggy address belongs to the object at ffff88811cc24c00 which belongs to the cache kmalloc-1k of size 1024 The buggy address is located 16 bytes inside of freed 1024-byte region [ffff88811cc24c00, ffff88811cc25000)",
      "id": "CVE-2024-53177",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "54e461fc-b7bd-4890-972d-4b519e6e037a",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: sunrpc: fix one UAF issue caused by sunrpc kernel tcp socket BUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0 Read of size 1 at addr ffff888111f322cd by task swapper/0/0 CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 Call Trace: <IRQ> dump_stack_lvl+0x68/0xa0 print_address_description.constprop.0+0x2c/0x3d0 print_report+0xb4/0x270 kasan_report+0xbd/0xf0 tcp_write_timer_handler+0x156/0x3e0 tcp_write_timer+0x66/0x170 call_timer_fn+0xfb/0x1d0 __run_timers+0x3f8/0x480 run_timer_softirq+0x9b/0x100 handle_softirqs+0x153/0x390 __irq_exit_rcu+0x103/0x120 irq_exit_rcu+0xe/0x20 sysvec_apic_timer_interrupt+0x76/0x90 </IRQ> <TASK> asm_sysvec_apic_timer_interrupt+0x1a/0x20 RIP: 0010:default_idle+0xf/0x20 Code: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90 RSP: 0018:ffffffffa2007e28 EFLAGS: 00000242 RAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196 RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590f RBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835d R10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000 R13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0 default_idle_call+0x6b/0xa0 cpuidle_idle_call+0x1af/0x1f0 do_idle+0xbc/0x130 cpu_startup_entry+0x33/0x40 rest_init+0x11f/0x210 start_kernel+0x39a/0x420 x86_64_start_reservations+0x18/0x30 x86_64_start_kernel+0x97/0xa0 common_startup_64+0x13e/0x141 </TASK> Allocated by task 595: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 __kasan_slab_alloc+0x87/0x90 kmem_cache_alloc_noprof+0x12b/0x3f0 copy_net_ns+0x94/0x380 create_new_namespaces+0x24c/0x500 unshare_nsproxy_namespaces+0x75/0xf0 ksys_unshare+0x24e/0x4f0 __x64_sys_unshare+0x1f/0x30 do_syscall_64+0x70/0x180 entry_SYSCALL_64_after_hwframe+0x76/0x7e Freed by task 100: kasan_save_stack+0x24/0x50 kasan_save_track+0x14/0x30 kasan_save_free_info+0x3b/0x60 __kasan_slab_free+0x54/0x70 kmem_cache_free+0x156/0x5d0 cleanup_net+0x5d3/0x670 process_one_work+0x776/0xa90 worker_thread+0x2e2/0x560 kthread+0x1a8/0x1f0 ret_from_fork+0x34/0x60 ret_from_fork_asm+0x1a/0x30 Reproduction script: mkdir -p /mnt/nfsshare mkdir -p /mnt/nfs/netns_1 mkfs.ext4 /dev/sdb mount /dev/sdb /mnt/nfsshare systemctl restart nfs-server chmod 777 /mnt/nfsshare exportfs -i -o rw,no_root_squash *:/mnt/nfsshare ip netns add netns_1 ip link add name veth_1_peer type veth peer veth_1 ifconfig veth_1_peer 11.11.0.254 up ip link set veth_1 netns netns_1 ip netns exec netns_1 ifconfig veth_1 11.11.0.1 ip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp \\ --tcp-flags FIN FIN -j DROP (note: In my environment, a DESTROY_CLIENTID operation is always sent immediately, breaking the nfs tcp connection.) ip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1 \\ 11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1 ip netns del netns_1 The reason here is that the tcp socket in netns_1 (nfs side) has been shutdown and closed (done in xs_destroy), but the FIN message (with ack) is discarded, and the nfsd side keeps sending retransmission messages. As a result, when the tcp sock in netns_1 processes the received message, it sends the message (FIN message) in the sending queue, and the tcp timer is re-established. When the network namespace is deleted, the net structure accessed by tcp's timer handler function causes problems. To fix this problem, let's hold netns refcnt for the tcp kernel socket as done in other modules. This is an ugly hack which can easily be backported to earlier kernels. A proper fix which cleans up the interfaces will follow, but may not be so easy to backport.",
      "id": "CVE-2024-53168",
      "published": "2024-12-27T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-10T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:33Z"
      },
      "bom-ref": "e61040dd-fbc5-4ba4-9821-cd72a844b5cc",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: Fix soft lockups in fib6_select_path under high next hop churn Soft lockups have been observed on a cluster of Linux-based edge routers located in a highly dynamic environment. Using the `bird` service, these routers continuously update BGP-advertised routes due to frequently changing nexthop destinations, while also managing significant IPv6 traffic. The lockups occur during the traversal of the multipath circular linked-list in the `fib6_select_path` function, particularly while iterating through the siblings in the list. The issue typically arises when the nodes of the linked list are unexpectedly deleted concurrently on a different core\u2014indicated by their 'next' and 'previous' elements pointing back to the node itself and their reference count dropping to zero. This results in an infinite loop, leading to a soft lockup that triggers a system panic via the watchdog timer. Apply RCU primitives in the problematic code sections to resolve the issue. Where necessary, update the references to fib6_siblings to annotate or use the RCU APIs. Include a test script that reproduces the issue. The script periodically updates the routing table while generating a heavy load of outgoing IPv6 traffic through multiple iperf3 clients. It consistently induces infinite soft lockups within a couple of minutes. Kernel log: 0 [ffffbd13003e8d30] machine_kexec at ffffffff8ceaf3eb 1 [ffffbd13003e8d90] __crash_kexec at ffffffff8d0120e3 2 [ffffbd13003e8e58] panic at ffffffff8cef65d4 3 [ffffbd13003e8ed8] watchdog_timer_fn at ffffffff8d05cb03 4 [ffffbd13003e8f08] __hrtimer_run_queues at ffffffff8cfec62f 5 [ffffbd13003e8f70] hrtimer_interrupt at ffffffff8cfed756 6 [ffffbd13003e8fd0] __sysvec_apic_timer_interrupt at ffffffff8cea01af 7 [ffffbd13003e8ff0] sysvec_apic_timer_interrupt at ffffffff8df1b83d -- <IRQ stack> -- 8 [ffffbd13003d3708] asm_sysvec_apic_timer_interrupt at ffffffff8e000ecb [exception RIP: fib6_select_path+299] RIP: ffffffff8ddafe7b RSP: ffffbd13003d37b8 RFLAGS: 00000287 RAX: ffff975850b43600 RBX: ffff975850b40200 RCX: 0000000000000000 RDX: 000000003fffffff RSI: 0000000051d383e4 RDI: ffff975850b43618 RBP: ffffbd13003d3800 R8: 0000000000000000 R9: ffff975850b40200 R10: 0000000000000000 R11: 0000000000000000 R12: ffffbd13003d3830 R13: ffff975850b436a8 R14: ffff975850b43600 R15: 0000000000000007 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 9 [ffffbd13003d3808] ip6_pol_route at ffffffff8ddb030c 10 [ffffbd13003d3888] ip6_pol_route_input at ffffffff8ddb068c 11 [ffffbd13003d3898] fib6_rule_lookup at ffffffff8ddf02b5 12 [ffffbd13003d3928] ip6_route_input at ffffffff8ddb0f47 13 [ffffbd13003d3a18] ip6_rcv_finish_core.constprop.0 at ffffffff8dd950d0 14 [ffffbd13003d3a30] ip6_list_rcv_finish.constprop.0 at ffffffff8dd96274 15 [ffffbd13003d3a98] ip6_sublist_rcv at ffffffff8dd96474 16 [ffffbd13003d3af8] ipv6_list_rcv at ffffffff8dd96615 17 [ffffbd13003d3b60] __netif_receive_skb_list_core at ffffffff8dc16fec 18 [ffffbd13003d3be0] netif_receive_skb_list_internal at ffffffff8dc176b3 19 [ffffbd13003d3c50] napi_gro_receive at ffffffff8dc565b9 20 [ffffbd13003d3c80] ice_receive_skb at ffffffffc087e4f5 [ice] 21 [ffffbd13003d3c90] ice_clean_rx_irq at ffffffffc0881b80 [ice] 22 [ffffbd13003d3d20] ice_napi_poll at ffffffffc088232f [ice] 23 [ffffbd13003d3d80] __napi_poll at ffffffff8dc18000 24 [ffffbd13003d3db8] net_rx_action at ffffffff8dc18581 25 [ffffbd13003d3e40] __do_softirq at ffffffff8df352e9 26 [ffffbd13003d3eb0] run_ksoftirqd at ffffffff8ceffe47 27 [ffffbd13003d3ec0] smpboot_thread_fn at ffffffff8cf36a30 28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39f 29 [ffffbd13003d3f28] ret_from_fork at ffffffff8ce5fa64 30 [ffffbd13003d3f50] ret_from_fork_asm at ffffffff8ce03cbb",
      "id": "CVE-2024-56703",
      "published": "2024-12-28T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-28T18:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:35Z"
      },
      "bom-ref": "6b51baab-9d57-4b45-b303-72ecf224d846",
      "cwes": [
        754
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: fix to do sanity check on node blkaddr in truncate_node() syzbot reports a f2fs bug as below: ------------[ cut here ]------------ kernel BUG at fs/f2fs/segment.c:2534! RIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534 Call Trace: truncate_node+0x1ae/0x8c0 fs/f2fs/node.c:909 f2fs_remove_inode_page+0x5c2/0x870 fs/f2fs/node.c:1288 f2fs_evict_inode+0x879/0x15c0 fs/f2fs/inode.c:856 evict+0x4e8/0x9b0 fs/inode.c:723 f2fs_handle_failed_inode+0x271/0x2e0 fs/f2fs/inode.c:986 f2fs_create+0x357/0x530 fs/f2fs/namei.c:394 lookup_open fs/namei.c:3595 [inline] open_last_lookups fs/namei.c:3694 [inline] path_openat+0x1c03/0x3590 fs/namei.c:3930 do_filp_open+0x235/0x490 fs/namei.c:3960 do_sys_openat2+0x13e/0x1d0 fs/open.c:1415 do_sys_open fs/open.c:1430 [inline] __do_sys_openat fs/open.c:1446 [inline] __se_sys_openat fs/open.c:1441 [inline] __x64_sys_openat+0x247/0x2a0 fs/open.c:1441 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f RIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534 The root cause is: on a fuzzed image, blkaddr in nat entry may be corrupted, then it will cause system panic when using it in f2fs_invalidate_blocks(), to avoid this, let's add sanity check on nat blkaddr in truncate_node().",
      "id": "CVE-2024-56692",
      "published": "2024-12-28T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-16T16:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:36Z"
      },
      "bom-ref": "88662050-da9c-4727-8ebe-5c2d594fc708",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: release nexthop on device removal The CI is hitting some aperiodic hangup at device removal time in the pmtu.sh self-test: unregister_netdevice: waiting for veth_A-R1 to become free. Usage count = 6 ref_tracker: veth_A-R1@ffff888013df15d8 has 1/5 users at dst_init+0x84/0x4a0 dst_alloc+0x97/0x150 ip6_dst_alloc+0x23/0x90 ip6_rt_pcpu_alloc+0x1e6/0x520 ip6_pol_route+0x56f/0x840 fib6_rule_lookup+0x334/0x630 ip6_route_output_flags+0x259/0x480 ip6_dst_lookup_tail.constprop.0+0x5c2/0x940 ip6_dst_lookup_flow+0x88/0x190 udp_tunnel6_dst_lookup+0x2a7/0x4c0 vxlan_xmit_one+0xbde/0x4a50 [vxlan] vxlan_xmit+0x9ad/0xf20 [vxlan] dev_hard_start_xmit+0x10e/0x360 __dev_queue_xmit+0xf95/0x18c0 arp_solicit+0x4a2/0xe00 neigh_probe+0xaa/0xf0 While the first suspect is the dst_cache, explicitly tracking the dst owing the last device reference via probes proved such dst is held by the nexthop in the originating fib6_info. Similar to commit f5b51fe804ec (\"ipv6: route: purge exception on removal\"), we need to explicitly release the originating fib info when disconnecting a to-be-removed device from a live ipv6 dst: move the fib6_info cleanup into ip6_dst_ifdown(). Tested running: ./pmtu.sh cleanup_ipv6_exception in a tight loop for more than 400 iterations with no spat, running an unpatched kernel I observed a splat every ~10 iterations.",
      "id": "CVE-2024-56751",
      "published": "2024-12-29T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:38Z"
      },
      "bom-ref": "a77c4bcc-e54b-4924-94b4-3c770792f17c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: octeontx2-pf: handle otx2_mbox_get_rsp errors in otx2_flows.c Adding error pointer check after calling otx2_mbox_get_rsp().",
      "id": "CVE-2024-56727",
      "published": "2024-12-29T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-06T17:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:39Z"
      },
      "bom-ref": "e6985d8e-c93b-4ee4-b13a-c84015927a87",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix cpu stuck caused by printings during reset During reset, cmd to destroy resources such as qp, cq, and mr may fail, and error logs will be printed. When a large number of resources are destroyed, there will be lots of printings, and it may lead to a cpu stuck. Delete some unnecessary printings and replace other printing functions in these paths with the ratelimited version.",
      "id": "CVE-2024-56722",
      "published": "2024-12-29T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T20:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:41Z"
      },
      "bom-ref": "6008180e-4d23-4a94-8f7d-81f4d5180344",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: stmmac: fix TSO DMA API usage causing oops Commit 66600fac7a98 (\"net: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB data\") moved the assignment of tx_skbuff_dma[]'s members to be later in stmmac_tso_xmit(). The buf (dma cookie) and len stored in this structure are passed to dma_unmap_single() by stmmac_tx_clean(). The DMA API requires that the dma cookie passed to dma_unmap_single() is the same as the value returned from dma_map_single(). However, by moving the assignment later, this is not the case when priv->dma_cap.addr64 > 32 as \"des\" is offset by proto_hdr_len. This causes problems such as: dwc-eth-dwmac 2490000.ethernet eth0: Tx DMA map failed and with DMA_API_DEBUG enabled: DMA-API: dwc-eth-dwmac 2490000.ethernet: device driver tries to +free DMA memory it has not allocated [device address=0x000000ffffcf65c0] [size=66 bytes] Fix this by maintaining \"des\" as the original DMA cookie, and use tso_des to pass the offset DMA cookie to stmmac_tso_allocator(). Full details of the crashes can be found at: https://lore.kernel.org/all/d8112193-0386-4e14-b516-37c2d838171a@nvidia.com/ https://lore.kernel.org/all/klkzp5yn5kq5efgtrow6wbvnc46bcqfxs65nz3qy77ujr5turc@bwwhelz2l4dw/",
      "id": "CVE-2024-56719",
      "published": "2024-12-29T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T20:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:42Z"
      },
      "bom-ref": "81f077b6-dedd-4cf1-864e-c81eff8cf078",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/smc: protect link down work from execute after lgr freed link down work may be scheduled before lgr freed but execute after lgr freed, which may result in crash. So it is need to hold a reference before shedule link down work, and put the reference after work executed or canceled. The relevant crash call stack as follows: list_del corruption. prev->next should be ffffb638c9c0fe20, but was 0000000000000000 ------------[ cut here ]------------ kernel BUG at lib/list_debug.c:51! invalid opcode: 0000 [#1] SMP NOPTI CPU: 6 PID: 978112 Comm: kworker/6:119 Kdump: loaded Tainted: G #1 Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 2221b89 04/01/2014 Workqueue: events smc_link_down_work [smc] RIP: 0010:__list_del_entry_valid.cold+0x31/0x47 RSP: 0018:ffffb638c9c0fdd8 EFLAGS: 00010086 RAX: 0000000000000054 RBX: ffff942fb75e5128 RCX: 0000000000000000 RDX: ffff943520930aa0 RSI: ffff94352091fc80 RDI: ffff94352091fc80 RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb638c9c0fc38 R10: ffffb638c9c0fc30 R11: ffffffffa015eb28 R12: 0000000000000002 R13: ffffb638c9c0fe20 R14: 0000000000000001 R15: ffff942f9cd051c0 FS: 0000000000000000(0000) GS:ffff943520900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f4f25214000 CR3: 000000025fbae004 CR4: 00000000007706e0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 PKRU: 55555554 Call Trace: rwsem_down_write_slowpath+0x17e/0x470 smc_link_down_work+0x3c/0x60 [smc] process_one_work+0x1ac/0x350 worker_thread+0x49/0x2f0 ? rescuer_thread+0x360/0x360 kthread+0x118/0x140 ? __kthread_bind_mask+0x60/0x60 ret_from_fork+0x1f/0x30",
      "id": "CVE-2024-56718",
      "published": "2024-12-29T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-10T17:35:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:44Z"
      },
      "bom-ref": "3a0ae3a1-bc85-4b45-b2b1-7b1f09bf08ec",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: udmabuf: fix memory leak on last export_udmabuf() error path In export_udmabuf(), if dma_buf_fd() fails because the FD table is full, a dma_buf owning the udmabuf has already been created; but the error handling in udmabuf_create() will tear down the udmabuf without doing anything about the containing dma_buf. This leaves a dma_buf in memory that contains a dangling pointer; though that doesn't seem to lead to anything bad except a memory leak. Fix it by moving the dma_buf_fd() call out of export_udmabuf() so that we can give it different error handling. Note that the shape of this code changed a lot in commit 5e72b2b41a21 (\"udmabuf: convert udmabuf driver to use folios\"); but the memory leak seems to have existed since the introduction of udmabuf.",
      "id": "CVE-2024-56712",
      "published": "2024-12-29T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-17T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_MEDIA_SUPPORT not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "7ba96681-57e5-4a34-9243-03b42d715abd",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: dvb-frontends: dib3000mb: fix uninit-value in dib3000_write_reg Syzbot reports [1] an uninitialized value issue found by KMSAN in dib3000_read_reg(). Local u8 rb[2] is used in i2c_transfer() as a read buffer; in case that call fails, the buffer may end up with some undefined values. Since no elaborate error handling is expected in dib3000_write_reg(), simply zero out rb buffer to mitigate the problem. [1] Syzkaller report dvb-usb: bulk message failed: -22 (6/0) ===================================================== BUG: KMSAN: uninit-value in dib3000mb_attach+0x2d8/0x3c0 drivers/media/dvb-frontends/dib3000mb.c:758 dib3000mb_attach+0x2d8/0x3c0 drivers/media/dvb-frontends/dib3000mb.c:758 dibusb_dib3000mb_frontend_attach+0x155/0x2f0 drivers/media/usb/dvb-usb/dibusb-mb.c:31 dvb_usb_adapter_frontend_init+0xed/0x9a0 drivers/media/usb/dvb-usb/dvb-usb-dvb.c:290 dvb_usb_adapter_init drivers/media/usb/dvb-usb/dvb-usb-init.c:90 [inline] dvb_usb_init drivers/media/usb/dvb-usb/dvb-usb-init.c:186 [inline] dvb_usb_device_init+0x25a8/0x3760 drivers/media/usb/dvb-usb/dvb-usb-init.c:310 dibusb_probe+0x46/0x250 drivers/media/usb/dvb-usb/dibusb-mb.c:110 ... Local variable rb created at: dib3000_read_reg+0x86/0x4e0 drivers/media/dvb-frontends/dib3000mb.c:54 dib3000mb_attach+0x123/0x3c0 drivers/media/dvb-frontends/dib3000mb.c:758 ...",
      "id": "CVE-2024-56769",
      "published": "2025-01-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:45Z"
      },
      "bom-ref": "47d1ea29-bd12-46b9-a8d7-2bd16c824673",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: dmaengine: at_xdmac: avoid null_prt_deref in at_xdmac_prep_dma_memset The at_xdmac_memset_create_desc may return NULL, which will lead to a null pointer dereference. For example, the len input is error, or the atchan->free_descs_list is empty and memory is exhausted. Therefore, add check to avoid this.",
      "id": "CVE-2024-56767",
      "published": "2025-01-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "5ca5b5f7-e37b-4e63-a2ef-c979f90bb9e7",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mtd: rawnand: fix double free in atmel_pmecc_create_user() The \"user\" pointer was converted from being allocated with kzalloc() to being allocated by devm_kzalloc(). Calling kfree(user) will lead to a double free.",
      "id": "CVE-2024-56766",
      "published": "2025-01-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:47Z"
      },
      "bom-ref": "48f380e3-1892-41f5-a6ef-0700ee01dbce",
      "description": "In the Linux kernel, the following vulnerability has been resolved: tracing: Prevent bad count for tracing_cpumask_write If a large count is provided, it will trigger a warning in bitmap_parse_user. Also check zero for it.",
      "id": "CVE-2024-56763",
      "published": "2025-01-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T16:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "2df12a49-3fa1-4bf2-bbbd-100738e55f1b",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix use-after-free when COWing tree bock and tracing is enabled When a COWing a tree block, at btrfs_cow_block(), and we have the tracepoint trace_btrfs_cow_block() enabled and preemption is also enabled (CONFIG_PREEMPT=y), we can trigger a use-after-free in the COWed extent buffer while inside the tracepoint code. This is because in some paths that call btrfs_cow_block(), such as btrfs_search_slot(), we are holding the last reference on the extent buffer @buf so btrfs_force_cow_block() drops the last reference on the @buf extent buffer when it calls free_extent_buffer_stale(buf), which schedules the release of the extent buffer with RCU. This means that if we are on a kernel with preemption, the current task may be preempted before calling trace_btrfs_cow_block() and the extent buffer already released by the time trace_btrfs_cow_block() is called, resulting in a use-after-free. Fix this by moving the trace_btrfs_cow_block() from btrfs_cow_block() to btrfs_force_cow_block() before the COWed extent buffer is freed. This also has a side effect of invoking the tracepoint in the tree defrag code, at defrag.c:btrfs_realloc_node(), since btrfs_force_cow_block() is called there, but this is fine and it was actually missing there.",
      "id": "CVE-2024-56759",
      "published": "2025-01-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ARCH_MEDIATEK is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "707dc65d-1dfc-4cca-a253-8da2835a4245",
      "cwes": [
        404
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btusb: mediatek: add intf release flow when usb disconnect MediaTek claim an special usb intr interface for ISO data transmission. The interface need to be released before unregistering hci device when usb disconnect. Removing BT usb dongle without properly releasing the interface may cause Kernel panic while unregister hci device.",
      "id": "CVE-2024-56757",
      "published": "2025-01-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-07T22:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:56:48Z"
      },
      "bom-ref": "e312af31-bebf-41bc-8449-d15bdeaf3b17",
      "description": "Rejected reason: This CVE ID has been rejected or withdrawn by its CVE Numbering Authority.",
      "id": "CVE-2024-56786",
      "published": "2025-01-08T18:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-19T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "requires_environment",
        "state": "not_affected"
      },
      "bom-ref": "b372bd27-b8f2-4aa6-88fa-d5a72f6088f2",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Adding array index check to prevent memory corruption [Why & How] Array indices out of bound caused memory corruption. Adding checks to ensure that array index stays in bound.",
      "id": "CVE-2024-56784",
      "published": "2025-01-08T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T21:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:50Z"
      },
      "bom-ref": "cf38cacf-066d-4cf6-bccc-da2c9fb99819",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ACPI: x86: Add adev NULL check to acpi_quirk_skip_serdev_enumeration() acpi_dev_hid_match() does not check for adev == NULL, dereferencing it unconditional. Add a check for adev being NULL before calling acpi_dev_hid_match(). At the moment acpi_quirk_skip_serdev_enumeration() is never called with a controller_parent without an ACPI companion, but better safe than sorry.",
      "id": "CVE-2024-56782",
      "published": "2025-01-08T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T21:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "e4d0d72e-19ee-4d56-b044-4a35c9ee2bc8",
      "cwes": [
        415,
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Fix handling of plane refcount [Why] The mechanism to backup and restore plane states doesn't maintain refcount, which can cause issues if the refcount of the plane changes in between backup and restore operations, such as memory leaks if the refcount was supposed to go down, or double frees / invalid memory accesses if the refcount was supposed to go up. [How] Cache and re-apply current refcount when restoring plane states.",
      "id": "CVE-2024-56775",
      "published": "2025-01-08T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-09T21:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:51Z"
      },
      "bom-ref": "a0dd27cd-24a7-485f-8232-4f812bdb94fc",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: pltfrm: Dellocate HBA during ufshcd_pltfrm_remove() This will ensure that the scsi host is cleaned up properly using scsi_host_dev_release(). Otherwise, it may lead to memory leaks.",
      "id": "CVE-2024-57872",
      "published": "2025-01-11T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-16T15:19:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "c627ad1f-f3d9-44a7-9d06-9501da638bfc",
      "cwes": [
        476,
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req() While receiving an MST up request message from one thread in drm_dp_mst_handle_up_req(), the MST topology could be removed from another thread via drm_dp_mst_topology_mgr_set_mst(false), freeing mst_primary and setting drm_dp_mst_topology_mgr::mst_primary to NULL. This could lead to a NULL deref/use-after-free of mst_primary in drm_dp_mst_handle_up_req(). Avoid the above by holding a reference for mst_primary in drm_dp_mst_handle_up_req() while it's used. v2: Fix kfreeing the request if getting an mst_primary reference fails.",
      "id": "CVE-2024-57798",
      "published": "2025-01-11T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T14:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:53Z"
      },
      "bom-ref": "65471d3d-1027-4437-9243-4adf1003e154",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: IDLETIMER: Fix for possible ABBA deadlock Deletion of the last rule referencing a given idletimer may happen at the same time as a read of its file in sysfs: | ====================================================== | WARNING: possible circular locking dependency detected | 6.12.0-rc7-01692-g5e9a28f41134-dirty #594 Not tainted | ------------------------------------------------------ | iptables/3303 is trying to acquire lock: | ffff8881057e04b8 (kn->active#48){++++}-{0:0}, at: __kernfs_remove+0x20 | | but task is already holding lock: | ffffffffa0249068 (list_mutex){+.+.}-{3:3}, at: idletimer_tg_destroy_v] | | which lock already depends on the new lock. A simple reproducer is: | #!/bin/bash | | while true; do | iptables -A INPUT -i foo -j IDLETIMER --timeout 10 --label \"testme\" | iptables -D INPUT -i foo -j IDLETIMER --timeout 10 --label \"testme\" | done & | while true; do | cat /sys/class/xt_idletimer/timers/testme >/dev/null | done Avoid this by freeing list_mutex right after deleting the element from the list, then continuing with the teardown.",
      "id": "CVE-2024-54683",
      "published": "2025-01-11T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-16T15:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:54Z"
      },
      "bom-ref": "d34ab1bc-3c08-4c98-b868-107b5e7c80c1",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: don't take dev_replace rwsem on task already holding it Running fstests btrfs/011 with MKFS_OPTIONS=\"-O rst\" to force the usage of the RAID stripe-tree, we get the following splat from lockdep: BTRFS info (device sdd): dev_replace from /dev/sdd (devid 1) to /dev/sdb started ============================================ WARNING: possible recursive locking detected 6.11.0-rc3-btrfs-for-next #599 Not tainted -------------------------------------------- btrfs/2326 is trying to acquire lock: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250 but task is already holding lock: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250 other info that might help us debug this: Possible unsafe locking scenario: CPU0 ---- lock(&fs_info->dev_replace.rwsem); lock(&fs_info->dev_replace.rwsem); *** DEADLOCK *** May be due to missing lock nesting notation 1 lock held by btrfs/2326: #0: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3}, at: btrfs_map_block+0x39f/0x2250 stack backtrace: CPU: 1 UID: 0 PID: 2326 Comm: btrfs Not tainted 6.11.0-rc3-btrfs-for-next #599 Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011 Call Trace: <TASK> dump_stack_lvl+0x5b/0x80 __lock_acquire+0x2798/0x69d0 ? __pfx___lock_acquire+0x10/0x10 ? __pfx___lock_acquire+0x10/0x10 lock_acquire+0x19d/0x4a0 ? btrfs_map_block+0x39f/0x2250 ? __pfx_lock_acquire+0x10/0x10 ? find_held_lock+0x2d/0x110 ? lock_is_held_type+0x8f/0x100 down_read+0x8e/0x440 ? btrfs_map_block+0x39f/0x2250 ? __pfx_down_read+0x10/0x10 ? do_raw_read_unlock+0x44/0x70 ? _raw_read_unlock+0x23/0x40 btrfs_map_block+0x39f/0x2250 ? btrfs_dev_replace_by_ioctl+0xd69/0x1d00 ? btrfs_bio_counter_inc_blocked+0xd9/0x2e0 ? __kasan_slab_alloc+0x6e/0x70 ? __pfx_btrfs_map_block+0x10/0x10 ? __pfx_btrfs_bio_counter_inc_blocked+0x10/0x10 ? kmem_cache_alloc_noprof+0x1f2/0x300 ? mempool_alloc_noprof+0xed/0x2b0 btrfs_submit_chunk+0x28d/0x17e0 ? __pfx_btrfs_submit_chunk+0x10/0x10 ? bvec_alloc+0xd7/0x1b0 ? bio_add_folio+0x171/0x270 ? __pfx_bio_add_folio+0x10/0x10 ? __kasan_check_read+0x20/0x20 btrfs_submit_bio+0x37/0x80 read_extent_buffer_pages+0x3df/0x6c0 btrfs_read_extent_buffer+0x13e/0x5f0 read_tree_block+0x81/0xe0 read_block_for_search+0x4bd/0x7a0 ? __pfx_read_block_for_search+0x10/0x10 btrfs_search_slot+0x78d/0x2720 ? __pfx_btrfs_search_slot+0x10/0x10 ? lock_is_held_type+0x8f/0x100 ? kasan_save_track+0x14/0x30 ? __kasan_slab_alloc+0x6e/0x70 ? kmem_cache_alloc_noprof+0x1f2/0x300 btrfs_get_raid_extent_offset+0x181/0x820 ? __pfx_lock_acquire+0x10/0x10 ? __pfx_btrfs_get_raid_extent_offset+0x10/0x10 ? down_read+0x194/0x440 ? __pfx_down_read+0x10/0x10 ? do_raw_read_unlock+0x44/0x70 ? _raw_read_unlock+0x23/0x40 btrfs_map_block+0x5b5/0x2250 ? __pfx_btrfs_map_block+0x10/0x10 scrub_submit_initial_read+0x8fe/0x11b0 ? __pfx_scrub_submit_initial_read+0x10/0x10 submit_initial_group_read+0x161/0x3a0 ? lock_release+0x20e/0x710 ? __pfx_submit_initial_group_read+0x10/0x10 ? __pfx_lock_release+0x10/0x10 scrub_simple_mirror.isra.0+0x3eb/0x580 scrub_stripe+0xe4d/0x1440 ? lock_release+0x20e/0x710 ? __pfx_scrub_stripe+0x10/0x10 ? __pfx_lock_release+0x10/0x10 ? do_raw_read_unlock+0x44/0x70 ? _raw_read_unlock+0x23/0x40 scrub_chunk+0x257/0x4a0 scrub_enumerate_chunks+0x64c/0xf70 ? __mutex_unlock_slowpath+0x147/0x5f0 ? __pfx_scrub_enumerate_chunks+0x10/0x10 ? bit_wait_timeout+0xb0/0x170 ? __up_read+0x189/0x700 ? scrub_workers_get+0x231/0x300 ? up_write+0x490/0x4f0 btrfs_scrub_dev+0x52e/0xcd0 ? create_pending_snapshots+0x230/0x250 ? __pfx_btrfs_scrub_dev+0x10/0x10 btrfs_dev_replace_by_ioctl+0xd69/0x1d00 ? lock_acquire+0x19d/0x4a0 ? __pfx_btrfs_dev_replace_by_ioctl+0x10/0x10 ? ---truncated---",
      "id": "CVE-2024-48875",
      "published": "2025-01-11T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T15:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:56Z"
      },
      "bom-ref": "f29db57c-a252-4c8e-9a0a-bbf49e1b25e6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: dlm: fix possible lkb_resource null dereference This patch fixes a possible null pointer dereference when this function is called from request_lock() as lkb->lkb_resource is not assigned yet, only after validate_lock_args() by calling attach_lkb(). Another issue is that a resource name could be a non printable bytearray and we cannot assume to be ASCII coded. The log functionality is probably never being hit when DLM is used in normal way and no debug logging is enabled. The null pointer dereference can only occur on a new created lkb that does not have the resource assigned yet, it probably never hits the null pointer dereference but we should be sure that other changes might not change this behaviour and we actually can hit the mentioned null pointer dereference. In this patch we just drop the printout of the resource name, the lkb id is enough to make a possible connection to a resource name if this exists.",
      "id": "CVE-2024-47809",
      "published": "2025-01-11T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-31T15:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:57Z"
      },
      "bom-ref": "9b18dc0e-575d-4b18-917b-249cc96d1864",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: pinmux: Use sequential access to access desc->pinmux data When two client of the same gpio call pinctrl_select_state() for the same functionality, we are seeing NULL pointer issue while accessing desc->mux_owner. Let's say two processes A, B executing in pin_request() for the same pin and process A updates the desc->mux_usecount but not yet updated the desc->mux_owner while process B see the desc->mux_usecount which got updated by A path and further executes strcmp and while accessing desc->mux_owner it crashes with NULL pointer. Serialize the access to mux related setting with a mutex lock. cpu0 (process A) cpu1(process B) pinctrl_select_state() { pinctrl_select_state() { pin_request() { pin_request() { ... .... } else { desc->mux_usecount++; desc->mux_usecount && strcmp(desc->mux_owner, owner)) { if (desc->mux_usecount > 1) return 0; desc->mux_owner = owner; } }",
      "id": "CVE-2024-47141",
      "published": "2025-01-11T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-31T15:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:56:59Z"
      },
      "bom-ref": "47841b77-2215-4d00-8012-08c8e00506b6",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: set ATTR_CTIME flags when setting mtime David reported that the new warning from setattr_copy_mgtime is coming like the following. [ 113.215316] ------------[ cut here ]------------ [ 113.215974] WARNING: CPU: 1 PID: 31 at fs/attr.c:300 setattr_copy+0x1ee/0x200 [ 113.219192] CPU: 1 UID: 0 PID: 31 Comm: kworker/1:1 Not tainted 6.13.0-rc1+ #234 [ 113.220127] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014 [ 113.221530] Workqueue: ksmbd-io handle_ksmbd_work [ksmbd] [ 113.222220] RIP: 0010:setattr_copy+0x1ee/0x200 [ 113.222833] Code: 24 28 49 8b 44 24 30 48 89 53 58 89 43 6c 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 48 89 df e8 77 d6 ff ff e9 cd fe ff ff <0f> 0b e9 be fe ff ff 66 0 [ 113.225110] RSP: 0018:ffffaf218010fb68 EFLAGS: 00010202 [ 113.225765] RAX: 0000000000000120 RBX: ffffa446815f8568 RCX: 0000000000000003 [ 113.226667] RDX: ffffaf218010fd38 RSI: ffffa446815f8568 RDI: ffffffff94eb03a0 [ 113.227531] RBP: ffffaf218010fb90 R08: 0000001a251e217d R09: 00000000675259fa [ 113.228426] R10: 0000000002ba8a6d R11: ffffa4468196c7a8 R12: ffffaf218010fd38 [ 113.229304] R13: 0000000000000120 R14: ffffffff94eb03a0 R15: 0000000000000000 [ 113.230210] FS: 0000000000000000(0000) GS:ffffa44739d00000(0000) knlGS:0000000000000000 [ 113.231215] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 113.232055] CR2: 00007efe0053d27e CR3: 000000000331a000 CR4: 00000000000006b0 [ 113.232926] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [ 113.233812] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [ 113.234797] Call Trace: [ 113.235116] <TASK> [ 113.235393] ? __warn+0x73/0xd0 [ 113.235802] ? setattr_copy+0x1ee/0x200 [ 113.236299] ? report_bug+0xf3/0x1e0 [ 113.236757] ? handle_bug+0x4d/0x90 [ 113.237202] ? exc_invalid_op+0x13/0x60 [ 113.237689] ? asm_exc_invalid_op+0x16/0x20 [ 113.238185] ? setattr_copy+0x1ee/0x200 [ 113.238692] btrfs_setattr+0x80/0x820 [btrfs] [ 113.239285] ? get_stack_info_noinstr+0x12/0xf0 [ 113.239857] ? __module_address+0x22/0xa0 [ 113.240368] ? handle_ksmbd_work+0x6e/0x460 [ksmbd] [ 113.240993] ? __module_text_address+0x9/0x50 [ 113.241545] ? __module_address+0x22/0xa0 [ 113.242033] ? unwind_next_frame+0x10e/0x920 [ 113.242600] ? __pfx_stack_trace_consume_entry+0x10/0x10 [ 113.243268] notify_change+0x2c2/0x4e0 [ 113.243746] ? stack_depot_save_flags+0x27/0x730 [ 113.244339] ? set_file_basic_info+0x130/0x2b0 [ksmbd] [ 113.244993] set_file_basic_info+0x130/0x2b0 [ksmbd] [ 113.245613] ? process_scheduled_works+0xbe/0x310 [ 113.246181] ? worker_thread+0x100/0x240 [ 113.246696] ? kthread+0xc8/0x100 [ 113.247126] ? ret_from_fork+0x2b/0x40 [ 113.247606] ? ret_from_fork_asm+0x1a/0x30 [ 113.248132] smb2_set_info+0x63f/0xa70 [ksmbd] ksmbd is trying to set the atime and mtime via notify_change without also setting the ctime. so This patch add ATTR_CTIME flags when setting mtime to avoid a warning.",
      "id": "CVE-2024-57895",
      "published": "2025-01-15T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-21T17:47:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "52498bf2-8580-4aa9-8dc8-a90f096d06ed",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ocfs2: fix slab-use-after-free due to dangling pointer dqi_priv When mounting ocfs2 and then remounting it as read-only, a slab-use-after-free occurs after the user uses a syscall to quota_getnextquota. Specifically, sb_dqinfo(sb, type)->dqi_priv is the dangling pointer. During the remounting process, the pointer dqi_priv is freed but is never set as null leaving it to be accessed. Additionally, the read-only option for remounting sets the DQUOT_SUSPENDED flag instead of setting the DQUOT_USAGE_ENABLED flags. Moreover, later in the process of getting the next quota, the function ocfs2_get_next_id is called and only checks the quota usage flags and not the quota suspended flags. To fix this, I set dqi_priv to null when it is freed after remounting with read-only and put a check for DQUOT_SUSPENDED in ocfs2_get_next_id. [akpm@linux-foundation.org: coding-style cleanups]",
      "id": "CVE-2024-57892",
      "published": "2025-01-15T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-13T14:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "412c02d4-7620-4207-af9b-1d637292ee81",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm: adv7511: Fix use-after-free in adv7533_attach_dsi() The host_node pointer was assigned and freed in adv7533_parse_dt(), and later, adv7533_attach_dsi() uses the same. Fix this use-after-free issue by\u00a0dropping of_node_put() in adv7533_parse_dt() and calling of_node_put() in error path of probe() and also in the remove().",
      "id": "CVE-2024-57887",
      "published": "2025-01-15T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-11T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:00Z"
      },
      "bom-ref": "d3275e06-7b79-4546-a519-707a8059589c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: fix TCP options overflow. Syzbot reported the following splat: Oops: general protection fault, probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f] CPU: 1 UID: 0 PID: 5836 Comm: sshd Not tainted 6.13.0-rc3-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/25/2024 RIP: 0010:_compound_head include/linux/page-flags.h:242 [inline] RIP: 0010:put_page+0x23/0x260 include/linux/mm.h:1552 Code: 90 90 90 90 90 90 90 55 41 57 41 56 53 49 89 fe 48 bd 00 00 00 00 00 fc ff df e8 f8 5e 12 f8 49 8d 5e 08 48 89 d8 48 c1 e8 03 <80> 3c 28 00 74 08 48 89 df e8 8f c7 78 f8 48 8b 1b 48 89 de 48 83 RSP: 0000:ffffc90003916c90 EFLAGS: 00010202 RAX: 0000000000000001 RBX: 0000000000000008 RCX: ffff888030458000 RDX: 0000000000000100 RSI: 0000000000000000 RDI: 0000000000000000 RBP: dffffc0000000000 R08: ffffffff898ca81d R09: 1ffff110054414ac R10: dffffc0000000000 R11: ffffed10054414ad R12: 0000000000000007 R13: ffff88802a20a542 R14: 0000000000000000 R15: 0000000000000000 FS: 00007f34f496e800(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f9d6ec9ec28 CR3: 000000004d260000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> skb_page_unref include/linux/skbuff_ref.h:43 [inline] __skb_frag_unref include/linux/skbuff_ref.h:56 [inline] skb_release_data+0x483/0x8a0 net/core/skbuff.c:1119 skb_release_all net/core/skbuff.c:1190 [inline] __kfree_skb+0x55/0x70 net/core/skbuff.c:1204 tcp_clean_rtx_queue net/ipv4/tcp_input.c:3436 [inline] tcp_ack+0x2442/0x6bc0 net/ipv4/tcp_input.c:4032 tcp_rcv_state_process+0x8eb/0x44e0 net/ipv4/tcp_input.c:6805 tcp_v4_do_rcv+0x77d/0xc70 net/ipv4/tcp_ipv4.c:1939 tcp_v4_rcv+0x2dc0/0x37f0 net/ipv4/tcp_ipv4.c:2351 ip_protocol_deliver_rcu+0x22e/0x440 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x341/0x5f0 net/ipv4/ip_input.c:233 NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314 NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314 __netif_receive_skb_one_core net/core/dev.c:5672 [inline] __netif_receive_skb+0x2bf/0x650 net/core/dev.c:5785 process_backlog+0x662/0x15b0 net/core/dev.c:6117 __napi_poll+0xcb/0x490 net/core/dev.c:6883 napi_poll net/core/dev.c:6952 [inline] net_rx_action+0x89b/0x1240 net/core/dev.c:7074 handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561 __do_softirq kernel/softirq.c:595 [inline] invoke_softirq kernel/softirq.c:435 [inline] __irq_exit_rcu+0xf7/0x220 kernel/softirq.c:662 irq_exit_rcu+0x9/0x30 kernel/softirq.c:678 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline] sysvec_apic_timer_interrupt+0x57/0xc0 arch/x86/kernel/apic/apic.c:1049 asm_sysvec_apic_timer_interrupt+0x1a/0x20 arch/x86/include/asm/idtentry.h:702 RIP: 0033:0x7f34f4519ad5 Code: 85 d2 74 0d 0f 10 02 48 8d 54 24 20 0f 11 44 24 20 64 8b 04 25 18 00 00 00 85 c0 75 27 41 b8 08 00 00 00 b8 0f 01 00 00 0f 05 <48> 3d 00 f0 ff ff 76 75 48 8b 15 24 73 0d 00 f7 d8 64 89 02 48 83 RSP: 002b:00007ffec5b32ce0 EFLAGS: 00000246 RAX: 0000000000000001 RBX: 00000000000668a0 RCX: 00007f34f4519ad5 RDX: 00007ffec5b32d00 RSI: 0000000000000004 RDI: 0000564f4bc6cae0 RBP: 0000564f4bc6b5a0 R08: 0000000000000008 R09: 0000000000000000 R10: 00007ffec5b32de8 R11: 0000000000000246 R12: 0000564f48ea8aa4 R13: 0000000000000001 R14: 0000564f48ea93e8 R15: 00007ffec5b32d68 </TASK> Eric noted a probable shinfo->nr_frags corruption, which indeed occurs. The root cause is a buggy MPTCP option len computation in some circumstances: the ADD_ADDR option should be mutually exclusive with DSS since the blamed commit. Still, mptcp_established_options_add_addr() tries to set the relevant info in mptcp_out_options, if ---truncated---",
      "id": "CVE-2024-57882",
      "published": "2025-01-15T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-02T22:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:02Z"
      },
      "bom-ref": "d014786f-a04a-4b6c-8801-6c00e11cae1c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/siw: Remove direct link to net_device Do not manage a per device direct link to net_device. Rely on associated ib_devices net_device management, not doubling the effort locally. A badly managed local link to net_device was causing a 'KASAN: slab-use-after-free' exception during siw_query_port() call.",
      "id": "CVE-2024-57857",
      "published": "2025-01-15T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:03Z"
      },
      "bom-ref": "b2128503-b52c-44c3-9e8d-efcc25882fa1",
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/rxe: Remove the direct link to net_device The similar patch in siw is in the link: https://git.kernel.org/rdma/rdma/c/16b87037b48889 This problem also occurred in RXE. The following analyze this problem. In the following Call Traces: \" BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 net/core/dev.c:8782 Read of size 4 at addr ffff8880554640b0 by task kworker/1:4/5295 CPU: 1 UID: 0 PID: 5295 Comm: kworker/1:4 Not tainted 6.12.0-rc3-syzkaller-00399-g9197b73fd7bb #0 Hardware name: Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: infiniband ib_cache_event_task Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:377 [inline] print_report+0x169/0x550 mm/kasan/report.c:488 kasan_report+0x143/0x180 mm/kasan/report.c:601 dev_get_flags+0x188/0x1d0 net/core/dev.c:8782 rxe_query_port+0x12d/0x260 drivers/infiniband/sw/rxe/rxe_verbs.c:60 __ib_query_port drivers/infiniband/core/device.c:2111 [inline] ib_query_port+0x168/0x7d0 drivers/infiniband/core/device.c:2143 ib_cache_update+0x1a9/0xb80 drivers/infiniband/core/cache.c:1494 ib_cache_event_task+0xf3/0x1e0 drivers/infiniband/core/cache.c:1568 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f2/0x390 kernel/kthread.c:389 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> \" 1). In the link [1], \" infiniband syz2: set down \" This means that on 839.350575, the event ib_cache_event_task was sent andi queued in ib_wq. 2). In the link [1], \" team0 (unregistering): Port device team_slave_0 removed \" It indicates that before 843.251853, the net device should be freed. 3). In the link [1], \" BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 \" This means that on 850.559070, this slab-use-after-free problem occurred. In all, on 839.350575, the event ib_cache_event_task was sent and queued in ib_wq, before 843.251853, the net device veth was freed. on 850.559070, this event was executed, and the mentioned freed net device was called. Thus, the above call trace occurred. [1] https://syzkaller.appspot.com/x/log.txt?x=12e7025f980000",
      "id": "CVE-2024-57795",
      "published": "2025-01-15T13:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Assessed to not be affected as CONFIG_SMB_SERVER not set in kernel config.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "5dc0f43b-436d-483c-9b54-cc7f7b3f83b9",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix a missing return value check bug In the smb2_send_interim_resp(), if ksmbd_alloc_work_struct() fails to allocate a node, it returns a NULL pointer to the in_work pointer. This can lead to an illegal memory write of in_work->response_buf when allocate_interim_rsp_buf() attempts to perform a kzalloc() on it. To address this issue, incorporating a check for the return value of ksmbd_alloc_work_struct() ensures that the function returns immediately upon allocation failure, thereby preventing the aforementioned illegal memory access.",
      "id": "CVE-2024-57925",
      "published": "2025-01-19T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-27T21:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "cd187f8c-985e-4249-b78d-06337f6d3a8c",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iio: pressure: zpa2326: fix information leak in triggered buffer The 'sample' local struct is used to push data to user space from a triggered buffer, but it has a hole between the temperature and the timestamp (u32 pressure, u16 temperature, GAP, u64 timestamp). This hole is never initialized. Initialize the struct to zero before using it to avoid pushing uninitialized information to userspace.",
      "id": "CVE-2024-57912",
      "published": "2025-01-19T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-18T13:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "de323f91-5e32-419d-aa25-6530251fbdbf",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iio: imu: kmx61: fix information leak in triggered buffer The 'buffer' local array is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the array to zero before using it to avoid pushing uninitialized information to userspace.",
      "id": "CVE-2024-57908",
      "published": "2025-01-19T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-18T13:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "a162077f-fad3-4fec-9ec3-0676b3079d06",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: rockchip_saradc: fix information leak in triggered buffer The 'data' local struct is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the struct to zero before using it to avoid pushing uninitialized information to userspace.",
      "id": "CVE-2024-57907",
      "published": "2025-01-19T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-18T13:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "b7834b29-29bd-4b29-8f2e-e02bbb953ad3",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iio: adc: ti-ads8688: fix information leak in triggered buffer The 'buffer' local array is used to push data to user space from a triggered buffer, but it does not set values for inactive channels, as it only uses iio_for_each_active_channel() to assign new values. Initialize the array to zero before using it to avoid pushing uninitialized information to userspace.",
      "id": "CVE-2024-57906",
      "published": "2025-01-19T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-18T13:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:05Z"
      },
      "bom-ref": "5d529df5-e29d-4700-8f9a-96df004ecd45",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: hns3: fix kernel crash when 1588 is sent on HIP08 devices Currently, HIP08 devices does not register the ptp devices, so the hdev->ptp is NULL. But the tx process would still try to set hardware time stamp info with SKBTX_HW_TSTAMP flag and cause a kernel crash. [ 128.087798] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000018 ... [ 128.280251] pc : hclge_ptp_set_tx_info+0x2c/0x140 [hclge] [ 128.286600] lr : hclge_ptp_set_tx_info+0x20/0x140 [hclge] [ 128.292938] sp : ffff800059b93140 [ 128.297200] x29: ffff800059b93140 x28: 0000000000003280 [ 128.303455] x27: ffff800020d48280 x26: ffff0cb9dc814080 [ 128.309715] x25: ffff0cb9cde93fa0 x24: 0000000000000001 [ 128.315969] x23: 0000000000000000 x22: 0000000000000194 [ 128.322219] x21: ffff0cd94f986000 x20: 0000000000000000 [ 128.328462] x19: ffff0cb9d2a166c0 x18: 0000000000000000 [ 128.334698] x17: 0000000000000000 x16: ffffcf1fc523ed24 [ 128.340934] x15: 0000ffffd530a518 x14: 0000000000000000 [ 128.347162] x13: ffff0cd6bdb31310 x12: 0000000000000368 [ 128.353388] x11: ffff0cb9cfbc7070 x10: ffff2cf55dd11e02 [ 128.359606] x9 : ffffcf1f85a212b4 x8 : ffff0cd7cf27dab0 [ 128.365831] x7 : 0000000000000a20 x6 : ffff0cd7cf27d000 [ 128.372040] x5 : 0000000000000000 x4 : 000000000000ffff [ 128.378243] x3 : 0000000000000400 x2 : ffffcf1f85a21294 [ 128.384437] x1 : ffff0cb9db520080 x0 : ffff0cb9db500080 [ 128.390626] Call trace: [ 128.393964] hclge_ptp_set_tx_info+0x2c/0x140 [hclge] [ 128.399893] hns3_nic_net_xmit+0x39c/0x4c4 [hns3] [ 128.405468] xmit_one.constprop.0+0xc4/0x200 [ 128.410600] dev_hard_start_xmit+0x54/0xf0 [ 128.415556] sch_direct_xmit+0xe8/0x634 [ 128.420246] __dev_queue_xmit+0x224/0xc70 [ 128.425101] dev_queue_xmit+0x1c/0x40 [ 128.429608] ovs_vport_send+0xac/0x1a0 [openvswitch] [ 128.435409] do_output+0x60/0x17c [openvswitch] [ 128.440770] do_execute_actions+0x898/0x8c4 [openvswitch] [ 128.446993] ovs_execute_actions+0x64/0xf0 [openvswitch] [ 128.453129] ovs_dp_process_packet+0xa0/0x224 [openvswitch] [ 128.459530] ovs_vport_receive+0x7c/0xfc [openvswitch] [ 128.465497] internal_dev_xmit+0x34/0xb0 [openvswitch] [ 128.471460] xmit_one.constprop.0+0xc4/0x200 [ 128.476561] dev_hard_start_xmit+0x54/0xf0 [ 128.481489] __dev_queue_xmit+0x968/0xc70 [ 128.486330] dev_queue_xmit+0x1c/0x40 [ 128.490856] ip_finish_output2+0x250/0x570 [ 128.495810] __ip_finish_output+0x170/0x1e0 [ 128.500832] ip_finish_output+0x3c/0xf0 [ 128.505504] ip_output+0xbc/0x160 [ 128.509654] ip_send_skb+0x58/0xd4 [ 128.513892] udp_send_skb+0x12c/0x354 [ 128.518387] udp_sendmsg+0x7a8/0x9c0 [ 128.522793] inet_sendmsg+0x4c/0x8c [ 128.527116] __sock_sendmsg+0x48/0x80 [ 128.531609] __sys_sendto+0x124/0x164 [ 128.536099] __arm64_sys_sendto+0x30/0x5c [ 128.540935] invoke_syscall+0x50/0x130 [ 128.545508] el0_svc_common.constprop.0+0x10c/0x124 [ 128.551205] do_el0_svc+0x34/0xdc [ 128.555347] el0_svc+0x20/0x30 [ 128.559227] el0_sync_handler+0xb8/0xc0 [ 128.563883] el0_sync+0x160/0x180",
      "id": "CVE-2025-21649",
      "published": "2025-01-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-31T15:56:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:06Z"
      },
      "bom-ref": "3b93f0cb-5983-4627-9a52-fa141070c8dc",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: sctp: sysctl: cookie_hmac_alg: avoid using current->nsproxy As mentioned in a previous commit of this series, using the 'net' structure via 'current' is not recommended for different reasons: - Inconsistency: getting info from the reader's/writer's netns vs only from the opener's netns. - current->nsproxy can be NULL in some cases, resulting in an 'Oops' (null-ptr-deref), e.g. when the current task is exiting, as spotted by syzbot [1] using acct(2). The 'net' structure can be obtained from the table->data using container_of(). Note that table->data could also be used directly, as this is the only member needed from the 'net' structure, but that would increase the size of this fix, to use '*data' everywhere 'net->sctp.sctp_hmac_alg' is used.",
      "id": "CVE-2025-21640",
      "published": "2025-01-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_IP_SCTP is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "ce942184-1f12-47a7-8553-aadd0d90b481",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: sctp: sysctl: rto_min/max: avoid using current->nsproxy As mentioned in a previous commit of this series, using the 'net' structure via 'current' is not recommended for different reasons: - Inconsistency: getting info from the reader's/writer's netns vs only from the opener's netns. - current->nsproxy can be NULL in some cases, resulting in an 'Oops' (null-ptr-deref), e.g. when the current task is exiting, as spotted by syzbot [1] using acct(2). The 'net' structure can be obtained from the table->data using container_of(). Note that table->data could also be used directly, as this is the only member needed from the 'net' structure, but that would increase the size of this fix, to use '*data' everywhere 'net->sctp.rto_min/max' is used.",
      "id": "CVE-2025-21639",
      "published": "2025-01-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-27T22:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:08Z"
      },
      "bom-ref": "cff7eda5-cb24-4532-925c-0001ef3eafce",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: rds: sysctl: rds_tcp_{rcv,snd}buf: avoid using current->nsproxy As mentioned in a previous commit of this series, using the 'net' structure via 'current' is not recommended for different reasons: - Inconsistency: getting info from the reader's/writer's netns vs only from the opener's netns. - current->nsproxy can be NULL in some cases, resulting in an 'Oops' (null-ptr-deref), e.g. when the current task is exiting, as spotted by syzbot [1] using acct(2). The per-netns structure can be obtained from the table->data using container_of(), then the 'net' one can be retrieved from the listen socket (if available).",
      "id": "CVE-2025-21635",
      "published": "2025-01-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-28T18:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:09Z"
      },
      "bom-ref": "f0366c34-4207-436b-baa3-7d97e3f988c2",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cgroup/cpuset: remove kernfs active break A warning was found: WARNING: CPU: 10 PID: 3486953 at fs/kernfs/file.c:828 CPU: 10 PID: 3486953 Comm: rmdir Kdump: loaded Tainted: G RIP: 0010:kernfs_should_drain_open_files+0x1a1/0x1b0 RSP: 0018:ffff8881107ef9e0 EFLAGS: 00010202 RAX: 0000000080000002 RBX: ffff888154738c00 RCX: dffffc0000000000 RDX: 0000000000000007 RSI: 0000000000000004 RDI: ffff888154738c04 RBP: ffff888154738c04 R08: ffffffffaf27fa15 R09: ffffed102a8e7180 R10: ffff888154738c07 R11: 0000000000000000 R12: ffff888154738c08 R13: ffff888750f8c000 R14: ffff888750f8c0e8 R15: ffff888154738ca0 FS: 00007f84cd0be740(0000) GS:ffff8887ddc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000555f9fbe00c8 CR3: 0000000153eec001 CR4: 0000000000370ee0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: kernfs_drain+0x15e/0x2f0 __kernfs_remove+0x165/0x300 kernfs_remove_by_name_ns+0x7b/0xc0 cgroup_rm_file+0x154/0x1c0 cgroup_addrm_files+0x1c2/0x1f0 css_clear_dir+0x77/0x110 kill_css+0x4c/0x1b0 cgroup_destroy_locked+0x194/0x380 cgroup_rmdir+0x2a/0x140 It can be explained by: rmdir echo 1 > cpuset.cpus kernfs_fop_write_iter // active=0 cgroup_rm_file kernfs_remove_by_name_ns kernfs_get_active // active=1 __kernfs_remove // active=0x80000002 kernfs_drain cpuset_write_resmask wait_event //waiting (active == 0x80000001) kernfs_break_active_protection // active = 0x80000001 // continue kernfs_unbreak_active_protection // active = 0x80000002 ... kernfs_should_drain_open_files // warning occurs kernfs_put_active This warning is caused by 'kernfs_break_active_protection' when it is writing to cpuset.cpus, and the cgroup is removed concurrently. The commit 3a5a6d0c2b03 (\"cpuset: don't nest cgroup_mutex inside get_online_cpus()\") made cpuset_hotplug_workfn asynchronous, This change involves calling flush_work(), which can create a multiple processes circular locking dependency that involve cgroup_mutex, potentially leading to a deadlock. To avoid deadlock. the commit 76bb5ab8f6e3 (\"cpuset: break kernfs active protection in cpuset_write_resmask()\") added 'kernfs_break_active_protection' in the cpuset_write_resmask. This could lead to this warning. After the commit 2125c0034c5d (\"cgroup/cpuset: Make cpuset hotplug processing synchronous\"), the cpuset_write_resmask no longer needs to wait the hotplug to finish, which means that concurrent hotplug and cpuset operations are no longer possible. Therefore, the deadlock doesn't exist anymore and it does not have to 'break active protection' now. To fix this warning, just remove kernfs_break_active_protection operation in the 'cpuset_write_resmask'.",
      "id": "CVE-2025-21634",
      "published": "2025-01-19T11:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T14:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:11Z"
      },
      "bom-ref": "163074f8-32a3-4845-bf88-c7e60f7b593a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: avoid NULL pointer dereference if no valid extent tree [BUG] Syzbot reported a crash with the following call trace: BTRFS info (device loop0): scrub: started on devid 1 BUG: kernel NULL pointer dereference, address: 0000000000000208 #PF: supervisor read access in kernel mode #PF: error_code(0x0000) - not-present page PGD 106e70067 P4D 106e70067 PUD 107143067 PMD 0 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 1 UID: 0 PID: 689 Comm: repro Kdump: loaded Tainted: G O 6.13.0-rc4-custom+ #206 Tainted: [O]=OOT_MODULE Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022 RIP: 0010:find_first_extent_item+0x26/0x1f0 [btrfs] Call Trace: <TASK> scrub_find_fill_first_stripe+0x13d/0x3b0 [btrfs] scrub_simple_mirror+0x175/0x260 [btrfs] scrub_stripe+0x5d4/0x6c0 [btrfs] scrub_chunk+0xbb/0x170 [btrfs] scrub_enumerate_chunks+0x2f4/0x5f0 [btrfs] btrfs_scrub_dev+0x240/0x600 [btrfs] btrfs_ioctl+0x1dc8/0x2fa0 [btrfs] ? do_sys_openat2+0xa5/0xf0 __x64_sys_ioctl+0x97/0xc0 do_syscall_64+0x4f/0x120 entry_SYSCALL_64_after_hwframe+0x76/0x7e </TASK> [CAUSE] The reproducer is using a corrupted image where extent tree root is corrupted, thus forcing to use \"rescue=all,ro\" mount option to mount the image. Then it triggered a scrub, but since scrub relies on extent tree to find where the data/metadata extents are, scrub_find_fill_first_stripe() relies on an non-empty extent root. But unfortunately scrub_find_fill_first_stripe() doesn't really expect an NULL pointer for extent root, it use extent_root to grab fs_info and triggered a NULL pointer dereference. [FIX] Add an extra check for a valid extent root at the beginning of scrub_find_fill_first_stripe(). The new error path is introduced by 42437a6386ff (\"btrfs: introduce mount option rescue=ignorebadroots\"), but that's pretty old, and later commit b979547513ff (\"btrfs: scrub: introduce helper to find and fill sector info for a scrub_stripe\") changed how we do scrub. So for kernels older than 6.6, the fix will need manual backport.",
      "id": "CVE-2025-21658",
      "published": "2025-01-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-22T23:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:12Z"
      },
      "bom-ref": "3cca9699-cc07-4863-a086-fa7bce292cc8",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: exfat: fix the infinite loop in exfat_readdir() If the file system is corrupted so that a cluster is linked to itself in the cluster chain, and there is an unused directory entry in the cluster, 'dentry' will not be incremented, causing condition 'dentry < max_dentries' unable to prevent an infinite loop. This infinite loop causes s_lock not to be released, and other tasks will hang, such as exfat_sync_fs(). This commit stops traversing the cluster chain when there is unused directory entry in the cluster to avoid this infinite loop.",
      "id": "CVE-2024-57940",
      "published": "2025-01-21T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-02T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:14Z"
      },
      "bom-ref": "23121d37-869a-4fd0-a233-695d363ad905",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: eth: bnxt: always recalculate features after XDP clearing, fix null-deref Recalculate features when XDP is detached. Before: # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdp # ip li set dev eth0 xdp off # ethtool -k eth0 | grep gro rx-gro-hw: off [requested on] After: # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdp # ip li set dev eth0 xdp off # ethtool -k eth0 | grep gro rx-gro-hw: on The fact that HW-GRO doesn't get re-enabled automatically is just a minor annoyance. The real issue is that the features will randomly come back during another reconfiguration which just happens to invoke netdev_update_features(). The driver doesn't handle reconfiguring two things at a time very robustly. Starting with commit 98ba1d931f61 (\"bnxt_en: Fix RSS logic in __bnxt_reserve_rings()\") we only reconfigure the RSS hash table if the \"effective\" number of Rx rings has changed. If HW-GRO is enabled \"effective\" number of rings is 2x what user sees. So if we are in the bad state, with HW-GRO re-enablement \"pending\" after XDP off, and we lower the rings by / 2 - the HW-GRO rings doing 2x and the ethtool -L doing / 2 may cancel each other out, and the: if (old_rx_rings != bp->hw_resc.resv_rx_rings && condition in __bnxt_reserve_rings() will be false. The RSS map won't get updated, and we'll crash with: BUG: kernel NULL pointer dereference, address: 0000000000000168 RIP: 0010:__bnxt_hwrm_vnic_set_rss+0x13a/0x1a0 bnxt_hwrm_vnic_rss_cfg_p5+0x47/0x180 __bnxt_setup_vnic_p5+0x58/0x110 bnxt_init_nic+0xb72/0xf50 __bnxt_open_nic+0x40d/0xab0 bnxt_open_nic+0x2b/0x60 ethtool_set_channels+0x18c/0x1d0 As we try to access a freed ring. The issue is present since XDP support was added, really, but prior to commit 98ba1d931f61 (\"bnxt_en: Fix RSS logic in __bnxt_reserve_rings()\") it wasn't causing major issues.",
      "id": "CVE-2025-21682",
      "published": "2025-01-31T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-04T15:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:15Z"
      },
      "bom-ref": "464d24cd-2cda-4f80-8094-a05e43f06258",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: smb: client: fix double free of TCP_Server_Info::hostname When shutting down the server in cifs_put_tcp_session(), cifsd thread might be reconnecting to multiple DFS targets before it realizes it should exit the loop, so @server->hostname can't be freed as long as cifsd thread isn't done. Otherwise the following can happen: RIP: 0010:__slab_free+0x223/0x3c0 Code: 5e 41 5f c3 cc cc cc cc 4c 89 de 4c 89 cf 44 89 44 24 08 4c 89 1c 24 e8 fb cf 8e 00 44 8b 44 24 08 4c 8b 1c 24 e9 5f fe ff ff <0f> 0b 41 f7 45 08 00 0d 21 00 0f 85 2d ff ff ff e9 1f ff ff ff 80 RSP: 0018:ffffb26180dbfd08 EFLAGS: 00010246 RAX: ffff8ea34728e510 RBX: ffff8ea34728e500 RCX: 0000000000800068 RDX: 0000000000800068 RSI: 0000000000000000 RDI: ffff8ea340042400 RBP: ffffe112041ca380 R08: 0000000000000001 R09: 0000000000000000 R10: 6170732e31303000 R11: 70726f632e786563 R12: ffff8ea34728e500 R13: ffff8ea340042400 R14: ffff8ea34728e500 R15: 0000000000800068 FS: 0000000000000000(0000) GS:ffff8ea66fd80000(0000) 000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007ffc25376080 CR3: 000000012a2ba001 CR4: PKRU: 55555554 Call Trace: <TASK> ? show_trace_log_lvl+0x1c4/0x2df ? show_trace_log_lvl+0x1c4/0x2df ? __reconnect_target_unlocked+0x3e/0x160 [cifs] ? __die_body.cold+0x8/0xd ? die+0x2b/0x50 ? do_trap+0xce/0x120 ? __slab_free+0x223/0x3c0 ? do_error_trap+0x65/0x80 ? __slab_free+0x223/0x3c0 ? exc_invalid_op+0x4e/0x70 ? __slab_free+0x223/0x3c0 ? asm_exc_invalid_op+0x16/0x20 ? __slab_free+0x223/0x3c0 ? extract_hostname+0x5c/0xa0 [cifs] ? extract_hostname+0x5c/0xa0 [cifs] ? __kmalloc+0x4b/0x140 __reconnect_target_unlocked+0x3e/0x160 [cifs] reconnect_dfs_server+0x145/0x430 [cifs] cifs_handle_standard+0x1ad/0x1d0 [cifs] cifs_demultiplex_thread+0x592/0x730 [cifs] ? __pfx_cifs_demultiplex_thread+0x10/0x10 [cifs] kthread+0xdd/0x100 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x29/0x50 </TASK>",
      "id": "CVE-2025-21673",
      "published": "2025-01-31T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-04T15:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AFS_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "2e9567d3-c5c0-4a7f-8d3f-7fe1313eeb56",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: afs: Fix merge preference rule failure condition syzbot reported a lock held when returning to userspace[1]. This is because if argc is less than 0 and the function returns directly, the held inode lock is not released. Fix this by store the error in ret and jump to done to clean up instead of returning directly. [dh: Modified Lizhi Xu's original patch to make it honour the error code from afs_split_string()] [1] WARNING: lock held when returning to user space! 6.13.0-rc3-syzkaller-00209-g499551201b5f #0 Not tainted ------------------------------------------------ syz-executor133/5823 is leaving the kernel with locks still held! 1 lock held by syz-executor133/5823: #0: ffff888071cffc00 (&sb->s_type->i_mutex_key#9){++++}-{4:4}, at: inode_lock include/linux/fs.h:818 [inline] #0: ffff888071cffc00 (&sb->s_type->i_mutex_key#9){++++}-{4:4}, at: afs_proc_addr_prefs_write+0x2bb/0x14e0 fs/afs/addr_prefs.c:388",
      "id": "CVE-2025-21672",
      "published": "2025-01-31T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T20:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:17Z"
      },
      "bom-ref": "456e1666-7926-4a8b-8c02-a179963db2ff",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iomap: avoid avoid truncating 64-bit offset to 32 bits on 32-bit kernels, iomap_write_delalloc_scan() was inadvertently using a 32-bit position due to folio_next_index() returning an unsigned long. This could lead to an infinite loop when writing to an xfs filesystem.",
      "id": "CVE-2025-21667",
      "published": "2025-01-31T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-03T20:00:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:18Z"
      },
      "bom-ref": "71c710bf-27f5-44c4-917d-8ae932fd8112",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: gpio: xilinx: Convert gpio_lock to raw spinlock irq_chip functions may be called in raw spinlock context. Therefore, we must also use a raw spinlock for our own internal locking. This fixes the following lockdep splat: [ 5.349336] ============================= [ 5.353349] [ BUG: Invalid wait context ] [ 5.357361] 6.13.0-rc5+ #69 Tainted: G W [ 5.363031] ----------------------------- [ 5.367045] kworker/u17:1/44 is trying to lock: [ 5.371587] ffffff88018b02c0 (&chip->gpio_lock){....}-{3:3}, at: xgpio_irq_unmask (drivers/gpio/gpio-xilinx.c:433 (discriminator 8)) [ 5.380079] other info that might help us debug this: [ 5.385138] context-{5:5} [ 5.387762] 5 locks held by kworker/u17:1/44: [ 5.392123] #0: ffffff8800014958 ((wq_completion)events_unbound){+.+.}-{0:0}, at: process_one_work (kernel/workqueue.c:3204) [ 5.402260] #1: ffffffc082fcbdd8 (deferred_probe_work){+.+.}-{0:0}, at: process_one_work (kernel/workqueue.c:3205) [ 5.411528] #2: ffffff880172c900 (&dev->mutex){....}-{4:4}, at: __device_attach (drivers/base/dd.c:1006) [ 5.419929] #3: ffffff88039c8268 (request_class#2){+.+.}-{4:4}, at: __setup_irq (kernel/irq/internals.h:156 kernel/irq/manage.c:1596) [ 5.428331] #4: ffffff88039c80c8 (lock_class#2){....}-{2:2}, at: __setup_irq (kernel/irq/manage.c:1614) [ 5.436472] stack backtrace: [ 5.439359] CPU: 2 UID: 0 PID: 44 Comm: kworker/u17:1 Tainted: G W 6.13.0-rc5+ #69 [ 5.448690] Tainted: [W]=WARN [ 5.451656] Hardware name: xlnx,zynqmp (DT) [ 5.455845] Workqueue: events_unbound deferred_probe_work_func [ 5.461699] Call trace: [ 5.464147] show_stack+0x18/0x24 C [ 5.467821] dump_stack_lvl (lib/dump_stack.c:123) [ 5.471501] dump_stack (lib/dump_stack.c:130) [ 5.474824] __lock_acquire (kernel/locking/lockdep.c:4828 kernel/locking/lockdep.c:4898 kernel/locking/lockdep.c:5176) [ 5.478758] lock_acquire (arch/arm64/include/asm/percpu.h:40 kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5851 kernel/locking/lockdep.c:5814) [ 5.482429] _raw_spin_lock_irqsave (include/linux/spinlock_api_smp.h:111 kernel/locking/spinlock.c:162) [ 5.486797] xgpio_irq_unmask (drivers/gpio/gpio-xilinx.c:433 (discriminator 8)) [ 5.490737] irq_enable (kernel/irq/internals.h:236 kernel/irq/chip.c:170 kernel/irq/chip.c:439 kernel/irq/chip.c:432 kernel/irq/chip.c:345) [ 5.494060] __irq_startup (kernel/irq/internals.h:241 kernel/irq/chip.c:180 kernel/irq/chip.c:250) [ 5.497645] irq_startup (kernel/irq/chip.c:270) [ 5.501143] __setup_irq (kernel/irq/manage.c:1807) [ 5.504728] request_threaded_irq (kernel/irq/manage.c:2208)",
      "id": "CVE-2025-21684",
      "published": "2025-02-09T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:20Z"
      },
      "bom-ref": "3cdbc888-11ef-49bd-867b-d0603e201d98",
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm: zswap: properly synchronize freeing resources during CPU hotunplug In zswap_compress() and zswap_decompress(), the per-CPU acomp_ctx of the current CPU at the beginning of the operation is retrieved and used throughout. However, since neither preemption nor migration are disabled, it is possible that the operation continues on a different CPU. If the original CPU is hotunplugged while the acomp_ctx is still in use, we run into a UAF bug as some of the resources attached to the acomp_ctx are freed during hotunplug in zswap_cpu_comp_dead() (i.e. acomp_ctx.buffer, acomp_ctx.req, or acomp_ctx.acomp). The problem was introduced in commit 1ec3b5fe6eec (\"mm/zswap: move to use crypto_acomp API for hardware acceleration\") when the switch to the crypto_acomp API was made. Prior to that, the per-CPU crypto_comp was retrieved using get_cpu_ptr() which disables preemption and makes sure the CPU cannot go away from under us. Preemption cannot be disabled with the crypto_acomp API as a sleepable context is needed. Use the acomp_ctx.mutex to synchronize CPU hotplug callbacks allocating and freeing resources with compression/decompression paths. Make sure that acomp_ctx.req is NULL when the resources are freed. In the compression/decompression paths, check if acomp_ctx.req is NULL after acquiring the mutex (meaning the CPU was offlined) and retry on the new CPU. The initialization of acomp_ctx.mutex is moved from the CPU hotplug callback to the pool initialization where it belongs (where the mutex is allocated). In addition to adding clarity, this makes sure that CPU hotplug cannot reinitialize a mutex that is already locked by compression/decompression. Previously a fix was attempted by holding cpus_read_lock() [1]. This would have caused a potential deadlock as it is possible for code already holding the lock to fall into reclaim and enter zswap (causing a deadlock). A fix was also attempted using SRCU for synchronization, but Johannes pointed out that synchronize_srcu() cannot be used in CPU hotplug notifiers [2]. Alternative fixes that were considered/attempted and could have worked: - Refcounting the per-CPU acomp_ctx. This involves complexity in handling the race between the refcount dropping to zero in zswap_[de]compress() and the refcount being re-initialized when the CPU is onlined. - Disabling migration before getting the per-CPU acomp_ctx [3], but that's discouraged and is a much bigger hammer than needed, and could result in subtle performance issues. [1]https://lkml.kernel.org/20241219212437.2714151-1-yosryahmed@google.com/ [2]https://lkml.kernel.org/20250107074724.1756696-2-yosryahmed@google.com/ [3]https://lkml.kernel.org/20250107222236.2715883-2-yosryahmed@google.com/ [yosryahmed@google.com: remove comment]",
      "id": "CVE-2025-21693",
      "published": "2025-02-10T16:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-16T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "8f70a287-08bc-4e2a-a8db-f359ecd3a5eb",
      "cwes": [
        369
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amd/display: Initialize denominator defaults to 1 [WHAT & HOW] Variables, used as denominators and maybe not assigned to other values, should be initialized to non-zero to avoid DIVIDE_BY_ZERO, as reported by Coverity. (cherry picked from commit e2c4c6c10542ccfe4a0830bb6c9fd5b177b7bbb7)",
      "id": "CVE-2024-57950",
      "published": "2025-02-10T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-21T16:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:21Z"
      },
      "bom-ref": "905010e9-b988-476f-8135-6b887fe7c4ff",
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm: clear uffd-wp PTE/PMD state on mremap() When mremap()ing a memory region previously registered with userfaultfd as write-protected but without UFFD_FEATURE_EVENT_REMAP, an inconsistency in flag clearing leads to a mismatch between the vma flags (which have uffd-wp cleared) and the pte/pmd flags (which do not have uffd-wp cleared). This mismatch causes a subsequent mprotect(PROT_WRITE) to trigger a warning in page_table_check_pte_flags() due to setting the pte to writable while uffd-wp is still set. Fix this by always explicitly clearing the uffd-wp pte/pmd flags on any such mremap() so that the values are consistent with the existing clearing of VM_UFFD_WP. Be careful to clear the logical flag regardless of its physical form; a PTE bit, a swap PTE bit, or a PTE marker. Cover PTE, huge PMD and hugetlb paths.",
      "id": "CVE-2025-21696",
      "published": "2025-02-12T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-02-14T15:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:23Z"
      },
      "bom-ref": "870f13d7-fab2-4517-941a-47406758679c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: IORING_OP_READ did not correctly consume the provided buffer list when read i/o returned < 0 (except for -EAGAIN and -EIOCBQUEUED return). This can lead to a potential use-after-free when the completion via io_rw_done runs at separate context.",
      "id": "CVE-2023-52926",
      "published": "2025-02-24T09:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:24Z"
      },
      "bom-ref": "3f679fe5-745c-48d7-b8d4-cba08273c5e6",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: Fix signed integer overflow in __ip6_append_data Resurrect ubsan overflow checks and ubsan report this warning, fix it by change the variable [length] type to size_t. UBSAN: signed-integer-overflow in net/ipv6/ip6_output.c:1489:19 2147479552 + 8567 cannot be represented in type 'int' CPU: 0 PID: 253 Comm: err Not tainted 5.16.0+ #1 Hardware name: linux,dummy-virt (DT) Call trace: dump_backtrace+0x214/0x230 show_stack+0x30/0x78 dump_stack_lvl+0xf8/0x118 dump_stack+0x18/0x30 ubsan_epilogue+0x18/0x60 handle_overflow+0xd0/0xf0 __ubsan_handle_add_overflow+0x34/0x44 __ip6_append_data.isra.48+0x1598/0x1688 ip6_append_data+0x128/0x260 udpv6_sendmsg+0x680/0xdd0 inet6_sendmsg+0x54/0x90 sock_sendmsg+0x70/0x88 ____sys_sendmsg+0xe8/0x368 ___sys_sendmsg+0x98/0xe0 __sys_sendmmsg+0xf4/0x3b8 __arm64_sys_sendmmsg+0x34/0x48 invoke_syscall+0x64/0x160 el0_svc_common.constprop.4+0x124/0x300 do_el0_svc+0x44/0xc8 el0_svc+0x3c/0x1e8 el0t_64_sync_handler+0x88/0xb0 el0t_64_sync+0x16c/0x170 Changes since v1: -Change the variable [length] type to unsigned, as Eric Dumazet suggested. Changes since v2: -Don't change exthdrlen type in ip6_make_skb, as Paolo Abeni suggested. Changes since v3: -Don't change ulen type in udpv6_sendmsg and l2tp_ip6_sendmsg, as Jakub Kicinski suggested.",
      "id": "CVE-2022-49728",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:26Z"
      },
      "bom-ref": "e6280015-9c44-4272-bef1-0351e53f4858",
      "description": "In the Linux kernel, the following vulnerability has been resolved: srcu: Tighten cleanup_srcu_struct() GP checks Currently, cleanup_srcu_struct() checks for a grace period in progress, but it does not check for a grace period that has not yet started but which might start at any time. Such a situation could result in a use-after-free bug, so this commit adds a check for a grace period that is needed but not yet started to cleanup_srcu_struct().",
      "id": "CVE-2022-49651",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T19:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:27Z"
      },
      "bom-ref": "89a79738-8987-42d7-b1d5-be4b5cd9a057",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: vlan: fix memory leak in vlan_newlink() Blamed commit added back a bug I fixed in commit 9bbd917e0bec (\"vlan: fix memory leak in vlan_dev_set_egress_priority\") If a memory allocation fails in vlan_changelink() after other allocations succeeded, we need to call vlan_dev_free_egress_priority() to free all allocated memory because after a failed ->newlink() we do not call any methods like ndo_uninit() or dev->priv_destructor(). In following example, if the allocation for last element 2000:2001 fails, we need to free eight prior allocations: ip link add link dummy0 dummy0.100 type vlan id 100 \\ egress-qos-map 1:2 2:3 3:4 4:5 5:6 6:7 7:8 8:9 2000:2001 syzbot report was: BUG: memory leak unreferenced object 0xffff888117bd1060 (size 32): comm \"syz-executor408\", pid 3759, jiffies 4294956555 (age 34.090s) hex dump (first 32 bytes): 09 00 00 00 00 a0 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace: [<ffffffff83fc60ad>] kmalloc include/linux/slab.h:600 [inline] [<ffffffff83fc60ad>] vlan_dev_set_egress_priority+0xed/0x170 net/8021q/vlan_dev.c:193 [<ffffffff83fc6628>] vlan_changelink+0x178/0x1d0 net/8021q/vlan_netlink.c:128 [<ffffffff83fc67c8>] vlan_newlink+0x148/0x260 net/8021q/vlan_netlink.c:185 [<ffffffff838b1278>] rtnl_newlink_create net/core/rtnetlink.c:3363 [inline] [<ffffffff838b1278>] __rtnl_newlink+0xa58/0xdc0 net/core/rtnetlink.c:3580 [<ffffffff838b1629>] rtnl_newlink+0x49/0x70 net/core/rtnetlink.c:3593 [<ffffffff838ac66c>] rtnetlink_rcv_msg+0x21c/0x5c0 net/core/rtnetlink.c:6089 [<ffffffff839f9c37>] netlink_rcv_skb+0x87/0x1d0 net/netlink/af_netlink.c:2501 [<ffffffff839f8da7>] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline] [<ffffffff839f8da7>] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345 [<ffffffff839f9266>] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921 [<ffffffff8384dbf6>] sock_sendmsg_nosec net/socket.c:714 [inline] [<ffffffff8384dbf6>] sock_sendmsg+0x56/0x80 net/socket.c:734 [<ffffffff8384e15c>] ____sys_sendmsg+0x36c/0x390 net/socket.c:2488 [<ffffffff838523cb>] ___sys_sendmsg+0x8b/0xd0 net/socket.c:2542 [<ffffffff838525b8>] __sys_sendmsg net/socket.c:2571 [inline] [<ffffffff838525b8>] __do_sys_sendmsg net/socket.c:2580 [inline] [<ffffffff838525b8>] __se_sys_sendmsg net/socket.c:2578 [inline] [<ffffffff838525b8>] __x64_sys_sendmsg+0x78/0xf0 net/socket.c:2578 [<ffffffff845ad8d5>] do_syscall_x64 arch/x86/entry/common.c:50 [inline] [<ffffffff845ad8d5>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80 [<ffffffff8460006a>] entry_SYSCALL_64_after_hwframe+0x46/0xb0",
      "id": "CVE-2022-49636",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:29Z"
      },
      "bom-ref": "2a8652e1-7ac0-47f9-9f74-3e8afe828e1c",
      "description": "In the Linux kernel, the following vulnerability has been resolved: netfilter: nf_tables: avoid skb access on nf_stolen When verdict is NF_STOLEN, the skb might have been freed. When tracing is enabled, this can result in a use-after-free: 1. access to skb->nf_trace 2. access to skb->mark 3. computation of trace id 4. dump of packet payload To avoid 1, keep a cached copy of skb->nf_trace in the trace state struct. Refresh this copy whenever verdict is != STOLEN. Avoid 2 by skipping skb->mark access if verdict is STOLEN. 3 is avoided by precomputing the trace id. Only dump the packet when verdict is not \"STOLEN\".",
      "id": "CVE-2022-49622",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T19:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:30Z"
      },
      "bom-ref": "0742865d-0e97-4786-b44f-db65ab2c02c9",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix deadlock between concurrent dio writes when low on free data space When reserving data space for a direct IO write we can end up deadlocking if we have multiple tasks attempting a write to the same file range, there are multiple extents covered by that file range, we are low on available space for data and the writes don't expand the inode's i_size. The deadlock can happen like this: 1) We have a file with an i_size of 1M, at offset 0 it has an extent with a size of 128K and at offset 128K it has another extent also with a size of 128K; 2) Task A does a direct IO write against file range [0, 256K), and because the write is within the i_size boundary, it takes the inode's lock (VFS level) in shared mode; 3) Task A locks the file range [0, 256K) at btrfs_dio_iomap_begin(), and then gets the extent map for the extent covering the range [0, 128K). At btrfs_get_blocks_direct_write(), it creates an ordered extent for that file range ([0, 128K)); 4) Before returning from btrfs_dio_iomap_begin(), it unlocks the file range [0, 256K); 5) Task A executes btrfs_dio_iomap_begin() again, this time for the file range [128K, 256K), and locks the file range [128K, 256K); 6) Task B starts a direct IO write against file range [0, 256K) as well. It also locks the inode in shared mode, as it's within the i_size limit, and then tries to lock file range [0, 256K). It is able to lock the subrange [0, 128K) but then blocks waiting for the range [128K, 256K), as it is currently locked by task A; 7) Task A enters btrfs_get_blocks_direct_write() and tries to reserve data space. Because we are low on available free space, it triggers the async data reclaim task, and waits for it to reserve data space; 8) The async reclaim task decides to wait for all existing ordered extents to complete (through btrfs_wait_ordered_roots()). It finds the ordered extent previously created by task A for the file range [0, 128K) and waits for it to complete; 9) The ordered extent for the file range [0, 128K) can not complete because it blocks at btrfs_finish_ordered_io() when trying to lock the file range [0, 128K). This results in a deadlock, because: - task B is holding the file range [0, 128K) locked, waiting for the range [128K, 256K) to be unlocked by task A; - task A is holding the file range [128K, 256K) locked and it's waiting for the async data reclaim task to satisfy its space reservation request; - the async data reclaim task is waiting for ordered extent [0, 128K) to complete, but the ordered extent can not complete because the file range [0, 128K) is currently locked by task B, which is waiting on task A to unlock file range [128K, 256K) and task A waiting on the async data reclaim task. This results in a deadlock between 4 task: task A, task B, the async data reclaim task and the task doing ordered extent completion (a work queue task). This type of deadlock can sporadically be triggered by the test case generic/300 from fstests, and results in a stack trace like the following: [12084.033689] INFO: task kworker/u16:7:123749 blocked for more than 241 seconds. [12084.034877] Not tainted 5.18.0-rc2-btrfs-next-115 #1 [12084.035562] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. [12084.036548] task:kworker/u16:7 state:D stack: 0 pid:123749 ppid: 2 flags:0x00004000 [12084.036554] Workqueue: btrfs-flush_delalloc btrfs_work_helper [btrfs] [12084.036599] Call Trace: [12084.036601] <TASK> [12084.036606] __schedule+0x3cb/0xed0 [12084.036616] schedule+0x4e/0xb0 [12084.036620] btrfs_start_ordered_extent+0x109/0x1c0 [btrfs] [12084.036651] ? prepare_to_wait_exclusive+0xc0/0xc0 [12084.036659] btrfs_run_ordered_extent_work+0x1a/0x30 [btrfs] [12084.036688] btrfs_work_helper+0xf8/0x400 [btrfs] [12084.0367 ---truncated---",
      "id": "CVE-2022-49547",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-10T21:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:32Z"
      },
      "bom-ref": "c9cd1063-1401-4032-9d2d-48bcc829b3aa",
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Fix null pointer dereference after failing to issue FLOGI and PLOGI If lpfc_issue_els_flogi() fails and returns non-zero status, the node reference count is decremented to trigger the release of the nodelist structure. However, if there is a prior registration or dev-loss-evt work pending, the node may be released prematurely. When dev-loss-evt completes, the released node is referenced causing a use-after-free null pointer dereference. Similarly, when processing non-zero ELS PLOGI completion status in lpfc_cmpl_els_plogi(), the ndlp flags are checked for a transport registration before triggering node removal. If dev-loss-evt work is pending, the node may be released prematurely and a subsequent call to lpfc_dev_loss_tmo_handler() results in a use after free ndlp dereference. Add test for pending dev-loss before decrementing the node reference count for FLOGI, PLOGI, PRLI, and ADISC handling.",
      "id": "CVE-2022-49535",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:33Z"
      },
      "bom-ref": "26529d56-4428-474a-a3d2-5770766fe781",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Protect memory leak for NPIV ports sending PLOGI_RJT There is a potential memory leak in lpfc_ignore_els_cmpl() and lpfc_els_rsp_reject() that was allocated from NPIV PLOGI_RJT (lpfc_rcv_plogi()'s login_mbox). Check if cmdiocb->context_un.mbox was allocated in lpfc_ignore_els_cmpl(), and then free it back to phba->mbox_mem_pool along with mbox->ctx_buf for service parameters. For lpfc_els_rsp_reject() failure, free both the ctx_buf for service parameters and the login_mbox.",
      "id": "CVE-2022-49534",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-10T21:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:35Z"
      },
      "bom-ref": "02773b95-81ab-4048-85ed-814bc0229d83",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: loop: implement ->free_disk Ensure that the lo_device which is stored in the gendisk private data is valid until the gendisk is freed. Currently the loop driver uses a lot of effort to make sure a device is not freed when it is still in use, but to to fix a potential deadlock this will be relaxed a bit soon.",
      "id": "CVE-2022-49531",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T19:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_AMD_GPU not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "6f0a90f4-ad3c-47cc-ab4d-2ffd5f6653cb",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu/pm: fix the null pointer while the smu is disabled It needs to check if the pp_funcs is initialized while release the context, otherwise it will trigger null pointer panic while the software smu is not enabled. [ 1109.404555] BUG: kernel NULL pointer dereference, address: 0000000000000078 [ 1109.404609] #PF: supervisor read access in kernel mode [ 1109.404638] #PF: error_code(0x0000) - not-present page [ 1109.404657] PGD 0 P4D 0 [ 1109.404672] Oops: 0000 [#1] PREEMPT SMP NOPTI [ 1109.404701] CPU: 7 PID: 9150 Comm: amdgpu_test Tainted: G OEL 5.16.0-custom #1 [ 1109.404732] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006 [ 1109.404765] RIP: 0010:amdgpu_dpm_force_performance_level+0x1d/0x170 [amdgpu] [ 1109.405109] Code: 5d c3 44 8b a3 f0 80 00 00 eb e5 66 90 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 41 55 41 54 53 48 83 ec 08 4c 8b b7 f0 7d 00 00 <49> 83 7e 78 00 0f 84 f2 00 00 00 80 bf 87 80 00 00 00 48 89 fb 0f [ 1109.405176] RSP: 0018:ffffaf3083ad7c20 EFLAGS: 00010282 [ 1109.405203] RAX: 0000000000000000 RBX: ffff9796b1c14600 RCX: 0000000002862007 [ 1109.405229] RDX: ffff97968591c8c0 RSI: 0000000000000001 RDI: ffff9796a3700000 [ 1109.405260] RBP: ffffaf3083ad7c50 R08: ffffffff9897de00 R09: ffff979688d9db60 [ 1109.405286] R10: 0000000000000000 R11: ffff979688d9db90 R12: 0000000000000001 [ 1109.405316] R13: ffff9796a3700000 R14: 0000000000000000 R15: ffff9796a3708fc0 [ 1109.405345] FS: 00007ff055cff180(0000) GS:ffff9796bfdc0000(0000) knlGS:0000000000000000 [ 1109.405378] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 1109.405400] CR2: 0000000000000078 CR3: 000000000a394000 CR4: 00000000000506e0 [ 1109.405434] Call Trace: [ 1109.405445] <TASK> [ 1109.405456] ? delete_object_full+0x1d/0x20 [ 1109.405480] amdgpu_ctx_set_stable_pstate+0x7c/0xa0 [amdgpu] [ 1109.405698] amdgpu_ctx_fini.part.0+0xcb/0x100 [amdgpu] [ 1109.405911] amdgpu_ctx_do_release+0x71/0x80 [amdgpu] [ 1109.406121] amdgpu_ctx_ioctl+0x52d/0x550 [amdgpu] [ 1109.406327] ? _raw_spin_unlock+0x1a/0x30 [ 1109.406354] ? drm_gem_handle_delete+0x81/0xb0 [drm] [ 1109.406400] ? amdgpu_ctx_get_entity+0x2c0/0x2c0 [amdgpu] [ 1109.406609] drm_ioctl_kernel+0xb6/0x140 [drm]",
      "id": "CVE-2022-49529",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-10T21:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:36Z"
      },
      "bom-ref": "928e140e-c678-4c60-a5b1-46df12caa304",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: always check VF VSI pointer values The ice_get_vf_vsi function can return NULL in some cases, such as if handling messages during a reset where the VSI is being removed and recreated. Several places throughout the driver do not bother to check whether this VSI pointer is valid. Static analysis tools maybe report issues because they detect paths where a potentially NULL pointer could be dereferenced. Fix this by checking the return value of ice_get_vf_vsi everywhere.",
      "id": "CVE-2022-49516",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_VIDEO_MEDIATEK_VCODEC is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "bc2db83e-4e26-4c4c-9795-34d5fd51a5d5",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: mediatek: vcodec: prevent kernel crash when rmmod mtk-vcodec-dec.ko If the driver support subdev mode, the parameter \"dev->pm.dev\" will be NULL in mtk_vcodec_dec_remove. Kernel will crash when try to rmmod mtk-vcodec-dec.ko. [ 4380.702726] pc : do_raw_spin_trylock+0x4/0x80 [ 4380.707075] lr : _raw_spin_lock_irq+0x90/0x14c [ 4380.711509] sp : ffff80000819bc10 [ 4380.714811] x29: ffff80000819bc10 x28: ffff3600c03e4000 x27: 0000000000000000 [ 4380.721934] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000 [ 4380.729057] x23: ffff3600c0f34930 x22: ffffd5e923549000 x21: 0000000000000220 [ 4380.736179] x20: 0000000000000208 x19: ffffd5e9213e8ebc x18: 0000000000000020 [ 4380.743298] x17: 0000002000000000 x16: ffffd5e9213e8e90 x15: 696c346f65646976 [ 4380.750420] x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000040 [ 4380.757542] x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000 [ 4380.764664] x8 : 0000000000000000 x7 : ffff3600c7273ae8 x6 : ffffd5e9213e8ebc [ 4380.771786] x5 : 0000000000000000 x4 : 0000000000000001 x3 : 0000000000000000 [ 4380.778908] x2 : 0000000000000000 x1 : ffff3600c03e4000 x0 : 0000000000000208 [ 4380.786031] Call trace: [ 4380.788465] do_raw_spin_trylock+0x4/0x80 [ 4380.792462] __pm_runtime_disable+0x2c/0x1b0 [ 4380.796723] mtk_vcodec_dec_remove+0x5c/0xa0 [mtk_vcodec_dec] [ 4380.802466] platform_remove+0x2c/0x60 [ 4380.806204] __device_release_driver+0x194/0x250 [ 4380.810810] driver_detach+0xc8/0x15c [ 4380.814462] bus_remove_driver+0x5c/0xb0 [ 4380.818375] driver_unregister+0x34/0x64 [ 4380.822288] platform_driver_unregister+0x18/0x24 [ 4380.826979] mtk_vcodec_dec_driver_exit+0x1c/0x888 [mtk_vcodec_dec] [ 4380.833240] __arm64_sys_delete_module+0x190/0x224 [ 4380.838020] invoke_syscall+0x48/0x114 [ 4380.841760] el0_svc_common.constprop.0+0x60/0x11c [ 4380.846540] do_el0_svc+0x28/0x90 [ 4380.849844] el0_svc+0x4c/0x100 [ 4380.852975] el0t_64_sync_handler+0xec/0xf0 [ 4380.857148] el0t_64_sync+0x190/0x194 [ 4380.860801] Code: 94431515 17ffffca d503201f d503245f (b9400004)",
      "id": "CVE-2022-49496",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:38Z"
      },
      "bom-ref": "dd7d5302-d30b-4987-b735-d33dea8b66bd",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: mt7915: fix possible NULL pointer dereference in mt7915_mac_fill_rx_vector Fix possible NULL pointer dereference in mt7915_mac_fill_rx_vector routine if the chip does not support dbdc and the hw reports band_idx set to 1.",
      "id": "CVE-2022-49484",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:39Z"
      },
      "bom-ref": "7f690b1a-21fc-4398-b3dc-4fdb41ae68b9",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mt76: mt7921: fix kernel crash at mt7921_pci_remove The crash log shown it is possible that mt7921_irq_handler is called while devm_free_irq is being handled so mt76_free_device need to be postponed until devm_free_irq is completed to solve the crash we free the mt76 device too early. [ 9299.339655] BUG: kernel NULL pointer dereference, address: 0000000000000008 [ 9299.339705] #PF: supervisor read access in kernel mode [ 9299.339735] #PF: error_code(0x0000) - not-present page [ 9299.339768] PGD 0 P4D 0 [ 9299.339786] Oops: 0000 [#1] SMP PTI [ 9299.339812] CPU: 1 PID: 1624 Comm: prepare-suspend Not tainted 5.15.14-1.fc32.qubes.x86_64 #1 [ 9299.339863] Hardware name: Xen HVM domU, BIOS 4.14.3 01/20/2022 [ 9299.339901] RIP: 0010:mt7921_irq_handler+0x1e/0x70 [mt7921e] [ 9299.340048] RSP: 0018:ffffa81b80c27cb0 EFLAGS: 00010082 [ 9299.340081] RAX: 0000000000000000 RBX: ffff98a4cb752020 RCX: ffffffffa96211c5 [ 9299.340123] RDX: 0000000000000000 RSI: 00000000000d4204 RDI: ffff98a4cb752020 [ 9299.340165] RBP: ffff98a4c28a62a4 R08: ffff98a4c37a96c0 R09: 0000000080150011 [ 9299.340207] R10: 0000000040000000 R11: 0000000000000000 R12: ffff98a4c4eaa080 [ 9299.340249] R13: ffff98a4c28a6360 R14: ffff98a4cb752020 R15: ffff98a4c28a6228 [ 9299.340297] FS: 00007260840d3740(0000) GS:ffff98a4ef700000(0000) knlGS:0000000000000000 [ 9299.340345] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 9299.340383] CR2: 0000000000000008 CR3: 0000000004c56001 CR4: 0000000000770ee0 [ 9299.340432] PKRU: 55555554 [ 9299.340449] Call Trace: [ 9299.340467] <TASK> [ 9299.340485] __free_irq+0x221/0x350 [ 9299.340527] free_irq+0x30/0x70 [ 9299.340553] devm_free_irq+0x55/0x80 [ 9299.340579] mt7921_pci_remove+0x2f/0x40 [mt7921e] [ 9299.340616] pci_device_remove+0x3b/0xa0 [ 9299.340651] __device_release_driver+0x17a/0x240 [ 9299.340686] device_driver_detach+0x3c/0xa0 [ 9299.340714] unbind_store+0x113/0x130 [ 9299.340740] kernfs_fop_write_iter+0x124/0x1b0 [ 9299.340775] new_sync_write+0x15c/0x1f0 [ 9299.340806] vfs_write+0x1d2/0x270 [ 9299.340831] ksys_write+0x67/0xe0 [ 9299.340857] do_syscall_64+0x3b/0x90 [ 9299.340887] entry_SYSCALL_64_after_hwframe+0x44/0xae",
      "id": "CVE-2022-49476",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "98c20dec-467e-4e2d-9624-63a47661ce75",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: rtw89: cfo: check mac_id to avoid out-of-bounds Somehow, hardware reports incorrect mac_id and pollute memory. Check index before we access the array. UBSAN: array-index-out-of-bounds in rtw89/phy.c:2517:23 index 188 is out of range for type 's32 [64]' CPU: 1 PID: 51550 Comm: irq/35-rtw89_pc Tainted: G OE Call Trace: <IRQ> show_stack+0x52/0x58 dump_stack_lvl+0x4c/0x63 dump_stack+0x10/0x12 ubsan_epilogue+0x9/0x45 __ubsan_handle_out_of_bounds.cold+0x44/0x49 ? __alloc_skb+0x92/0x1d0 rtw89_phy_cfo_parse+0x44/0x7f [rtw89_core] rtw89_core_rx+0x261/0x871 [rtw89_core] ? __alloc_skb+0xee/0x1d0 rtw89_pci_napi_poll+0x3fa/0x4ea [rtw89_pci] __napi_poll+0x33/0x1a0 net_rx_action+0x126/0x260 ? __queue_work+0x217/0x4c0 __do_softirq+0xd9/0x315 ? disable_irq_nosync+0x10/0x10 do_softirq.part.0+0x6d/0x90 </IRQ> <TASK> __local_bh_enable_ip+0x62/0x70 rtw89_pci_interrupt_threadfn+0x182/0x1a6 [rtw89_pci] irq_thread_fn+0x28/0x60 irq_thread+0xc8/0x190 ? irq_thread_fn+0x60/0x60 kthread+0x16b/0x190 ? irq_thread_check_affinity+0xe0/0xe0 ? set_kthread_struct+0x50/0x50 ret_from_fork+0x22/0x30 </TASK>",
      "id": "CVE-2022-49471",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T16:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:41Z"
      },
      "bom-ref": "aab7b8f8-489d-4c4c-9a77-f2e55ddec2f7",
      "description": "In the Linux kernel, the following vulnerability has been resolved: blk-throttle: Set BIO_THROTTLED when bio has been throttled 1.In current process, all bio will set the BIO_THROTTLED flag after __blk_throtl_bio(). 2.If bio needs to be throttled, it will start the timer and stop submit bio directly. Bio will submit in blk_throtl_dispatch_work_fn() when the timer expires.But in the current process, if bio is throttled. The BIO_THROTTLED will be set to bio after timer start. If the bio has been completed, it may cause use-after-free blow. BUG: KASAN: use-after-free in blk_throtl_bio+0x12f0/0x2c70 Read of size 2 at addr ffff88801b8902d4 by task fio/26380 dump_stack+0x9b/0xce print_address_description.constprop.6+0x3e/0x60 kasan_report.cold.9+0x22/0x3a blk_throtl_bio+0x12f0/0x2c70 submit_bio_checks+0x701/0x1550 submit_bio_noacct+0x83/0xc80 submit_bio+0xa7/0x330 mpage_readahead+0x380/0x500 read_pages+0x1c1/0xbf0 page_cache_ra_unbounded+0x471/0x6f0 do_page_cache_ra+0xda/0x110 ondemand_readahead+0x442/0xae0 page_cache_async_ra+0x210/0x300 generic_file_buffered_read+0x4d9/0x2130 generic_file_read_iter+0x315/0x490 blkdev_read_iter+0x113/0x1b0 aio_read+0x2ad/0x450 io_submit_one+0xc8e/0x1d60 __se_sys_io_submit+0x125/0x350 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Allocated by task 26380: kasan_save_stack+0x19/0x40 __kasan_kmalloc.constprop.2+0xc1/0xd0 kmem_cache_alloc+0x146/0x440 mempool_alloc+0x125/0x2f0 bio_alloc_bioset+0x353/0x590 mpage_alloc+0x3b/0x240 do_mpage_readpage+0xddf/0x1ef0 mpage_readahead+0x264/0x500 read_pages+0x1c1/0xbf0 page_cache_ra_unbounded+0x471/0x6f0 do_page_cache_ra+0xda/0x110 ondemand_readahead+0x442/0xae0 page_cache_async_ra+0x210/0x300 generic_file_buffered_read+0x4d9/0x2130 generic_file_read_iter+0x315/0x490 blkdev_read_iter+0x113/0x1b0 aio_read+0x2ad/0x450 io_submit_one+0xc8e/0x1d60 __se_sys_io_submit+0x125/0x350 do_syscall_64+0x2d/0x40 entry_SYSCALL_64_after_hwframe+0x44/0xa9 Freed by task 0: kasan_save_stack+0x19/0x40 kasan_set_track+0x1c/0x30 kasan_set_free_info+0x1b/0x30 __kasan_slab_free+0x111/0x160 kmem_cache_free+0x94/0x460 mempool_free+0xd6/0x320 bio_free+0xe0/0x130 bio_put+0xab/0xe0 bio_endio+0x3a6/0x5d0 blk_update_request+0x590/0x1370 scsi_end_request+0x7d/0x400 scsi_io_completion+0x1aa/0xe50 scsi_softirq_done+0x11b/0x240 blk_mq_complete_request+0xd4/0x120 scsi_mq_done+0xf0/0x200 virtscsi_vq_done+0xbc/0x150 vring_interrupt+0x179/0x390 __handle_irq_event_percpu+0xf7/0x490 handle_irq_event_percpu+0x7b/0x160 handle_irq_event+0xcc/0x170 handle_edge_irq+0x215/0xb20 common_interrupt+0x60/0x120 asm_common_interrupt+0x1e/0x40 Fix this by move BIO_THROTTLED set into the queue_lock.",
      "id": "CVE-2022-49465",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T19:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:42Z"
      },
      "bom-ref": "41ad2758-e7de-4646-be31-f9573617e0cf",
      "description": "In the Linux kernel, the following vulnerability has been resolved: macsec: fix UAF bug for real_dev Create a new macsec device but not get reference to real_dev. That can not ensure that real_dev is freed after macsec. That will trigger the UAF bug for real_dev as following: ================================================================== BUG: KASAN: use-after-free in macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662 Call Trace: ... macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662 dev_get_iflink+0x73/0xe0 net/core/dev.c:637 default_operstate net/core/link_watch.c:42 [inline] rfc2863_policy+0x233/0x2d0 net/core/link_watch.c:54 linkwatch_do_dev+0x2a/0x150 net/core/link_watch.c:161 Allocated by task 22209: ... alloc_netdev_mqs+0x98/0x1100 net/core/dev.c:10549 rtnl_create_link+0x9d7/0xc00 net/core/rtnetlink.c:3235 veth_newlink+0x20e/0xa90 drivers/net/veth.c:1748 Freed by task 8: ... kfree+0xd6/0x4d0 mm/slub.c:4552 kvfree+0x42/0x50 mm/util.c:615 device_release+0x9f/0x240 drivers/base/core.c:2229 kobject_cleanup lib/kobject.c:673 [inline] kobject_release lib/kobject.c:704 [inline] kref_put include/linux/kref.h:65 [inline] kobject_put+0x1c8/0x540 lib/kobject.c:721 netdev_run_todo+0x72e/0x10b0 net/core/dev.c:10327 After commit faab39f63c1f (\"net: allow out-of-order netdev unregistration\") and commit e5f80fcf869a (\"ipv6: give an IPv6 dev to blackhole_netdev\"), we can add dev_hold_track() in macsec_dev_init() and dev_put_track() in macsec_free_netdev() to fix the problem.",
      "id": "CVE-2022-49390",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T13:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:44Z"
      },
      "bom-ref": "0d2f2cc9-0311-4bd7-98aa-4988b432b665",
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/panfrost: Job should reference MMU not file_priv For a while now it's been allowed for a MMU context to outlive it's corresponding panfrost_priv, however the job structure still references panfrost_priv to get hold of the MMU context. If panfrost_priv has been freed this is a use-after-free which I've been able to trigger resulting in a splat. To fix this, drop the reference to panfrost_priv in the job structure and add a direct reference to the MMU structure which is what's actually needed.",
      "id": "CVE-2022-49359",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T14:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:45Z"
      },
      "bom-ref": "a2bf63b2-68b6-4dfe-998b-7077240efb60",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: ethernet: bgmac: Fix refcount leak in bcma_mdio_mii_register of_get_child_by_name() returns a node pointer with refcount incremented, we should use of_node_put() on it when not need anymore. Add missing of_node_put() to avoid refcount leak.",
      "id": "CVE-2022-49342",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:54:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:47Z"
      },
      "bom-ref": "a5ebe2dc-7ddd-4564-8881-600bef6bcbc6",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: avoid infinite loop to flush node pages xfstests/generic/475 can give EIO all the time which give an infinite loop to flush node page like below. Let's avoid it. [16418.518551] Call Trace: [16418.518553] ? dm_submit_bio+0x48/0x400 [16418.518574] ? submit_bio_checks+0x1ac/0x5a0 [16418.525207] __submit_bio+0x1a9/0x230 [16418.525210] ? kmem_cache_alloc+0x29e/0x3c0 [16418.525223] submit_bio_noacct+0xa8/0x2b0 [16418.525226] submit_bio+0x4d/0x130 [16418.525238] __submit_bio+0x49/0x310 [f2fs] [16418.525339] ? bio_add_page+0x6a/0x90 [16418.525344] f2fs_submit_page_bio+0x134/0x1f0 [f2fs] [16418.525365] read_node_page+0x125/0x1b0 [f2fs] [16418.525388] __get_node_page.part.0+0x58/0x3f0 [f2fs] [16418.525409] __get_node_page+0x2f/0x60 [f2fs] [16418.525431] f2fs_get_dnode_of_data+0x423/0x860 [f2fs] [16418.525452] ? asm_sysvec_apic_timer_interrupt+0x12/0x20 [16418.525458] ? __mod_memcg_state.part.0+0x2a/0x30 [16418.525465] ? __mod_memcg_lruvec_state+0x27/0x40 [16418.525467] ? __xa_set_mark+0x57/0x70 [16418.525472] f2fs_do_write_data_page+0x10e/0x7b0 [f2fs] [16418.525493] f2fs_write_single_data_page+0x555/0x830 [f2fs] [16418.525514] ? sysvec_apic_timer_interrupt+0x4e/0x90 [16418.525518] ? asm_sysvec_apic_timer_interrupt+0x12/0x20 [16418.525523] f2fs_write_cache_pages+0x303/0x880 [f2fs] [16418.525545] ? blk_flush_plug_list+0x47/0x100 [16418.525548] f2fs_write_data_pages+0xfd/0x320 [f2fs] [16418.525569] do_writepages+0xd5/0x210 [16418.525648] filemap_fdatawrite_wbc+0x7d/0xc0 [16418.525655] filemap_fdatawrite+0x50/0x70 [16418.525658] f2fs_sync_dirty_inodes+0xa4/0x230 [f2fs] [16418.525679] f2fs_write_checkpoint+0x16d/0x1720 [f2fs] [16418.525699] ? ttwu_do_wakeup+0x1c/0x160 [16418.525709] ? ttwu_do_activate+0x6d/0xd0 [16418.525711] ? __wait_for_common+0x11d/0x150 [16418.525715] kill_f2fs_super+0xca/0x100 [f2fs] [16418.525733] deactivate_locked_super+0x3b/0xb0 [16418.525739] deactivate_super+0x40/0x50 [16418.525741] cleanup_mnt+0x139/0x190 [16418.525747] __cleanup_mnt+0x12/0x20 [16418.525749] task_work_run+0x6d/0xa0 [16418.525765] exit_to_user_mode_prepare+0x1ad/0x1b0 [16418.525771] syscall_exit_to_user_mode+0x27/0x50 [16418.525774] do_syscall_64+0x48/0xc0 [16418.525776] entry_SYSCALL_64_after_hwframe+0x44/0xae",
      "id": "CVE-2022-49317",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T22:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:48Z"
      },
      "bom-ref": "c0188446-498f-4445-9429-68c21c237df2",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drivers: staging: rtl8192eu: Fix deadlock in rtw_joinbss_event_prehandle There is a deadlock in rtw_joinbss_event_prehandle(), which is shown below: (Thread 1) | (Thread 2) | _set_timer() rtw_joinbss_event_prehandle()| mod_timer() spin_lock_bh() //(1) | (wait a time) ... | rtw_join_timeout_handler() | _rtw_join_timeout_handler() del_timer_sync() | spin_lock_bh() //(2) (wait timer to stop) | ... We hold pmlmepriv->lock in position (1) of thread 1 and use del_timer_sync() to wait timer to stop, but timer handler also need pmlmepriv->lock in position (2) of thread 2. As a result, rtw_joinbss_event_prehandle() will block forever. This patch extracts del_timer_sync() from the protection of spin_lock_bh(), which could let timer handler to obtain the needed lock. What`s more, we change spin_lock_bh() to spin_lock_irq() in _rtw_join_timeout_handler() in order to prevent deadlock.",
      "id": "CVE-2022-49303",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:05:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_CEPH_FS is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "bb210d7a-f7df-4d38-ad3b-949cd46e26a4",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ceph: fix possible deadlock when holding Fwb to get inline_data 1, mount with wsync. 2, create a file with O_RDWR, and the request was sent to mds.0: ceph_atomic_open()--> ceph_mdsc_do_request(openc) finish_open(file, dentry, ceph_open)--> ceph_open()--> ceph_init_file()--> ceph_init_file_info()--> ceph_uninline_data()--> { ... if (inline_version == 1 || /* initial version, no data */ inline_version == CEPH_INLINE_NONE) goto out_unlock; ... } The inline_version will be 1, which is the initial version for the new create file. And here the ci->i_inline_version will keep with 1, it's buggy. 3, buffer write to the file immediately: ceph_write_iter()--> ceph_get_caps(file, need=Fw, want=Fb, ...); generic_perform_write()--> a_ops->write_begin()--> ceph_write_begin()--> netfs_write_begin()--> netfs_begin_read()--> netfs_rreq_submit_slice()--> netfs_read_from_server()--> rreq->netfs_ops->issue_read()--> ceph_netfs_issue_read()--> { ... if (ci->i_inline_version != CEPH_INLINE_NONE && ceph_netfs_issue_op_inline(subreq)) return; ... } ceph_put_cap_refs(ci, Fwb); The ceph_netfs_issue_op_inline() will send a getattr(Fsr) request to mds.1. 4, then the mds.1 will request the rd lock for CInode::filelock from the auth mds.0, the mds.0 will do the CInode::filelock state transation from excl --> sync, but it need to revoke the Fxwb caps back from the clients. While the kernel client has aleady held the Fwb caps and waiting for the getattr(Fsr). It's deadlock! URL: https://tracker.ceph.com/issues/55377",
      "id": "CVE-2022-49296",
      "published": "2025-02-26T07:01:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "fba165ab-94ad-4b56-9c05-66f1093595af",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/dp: Fix OOB read when handling Post Cursor2 register The link_status array was not large enough to read the Adjust Request Post Cursor2 register, so remove the common helper function to avoid an OOB read, found with a -Warray-bounds build: drivers/gpu/drm/drm_dp_helper.c: In function 'drm_dp_get_adjust_request_post_cursor': drivers/gpu/drm/drm_dp_helper.c:59:27: error: array subscript 10 is outside array bounds of 'const u8[6]' {aka 'const unsigned char[6]'} [-Werror=array-bounds] 59 | return link_status[r - DP_LANE0_1_STATUS]; | ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~ drivers/gpu/drm/drm_dp_helper.c:147:51: note: while referencing 'link_status' 147 | u8 drm_dp_get_adjust_request_post_cursor(const u8 link_status[DP_LINK_STATUS_SIZE], | ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Replace the only user of the helper with an open-coded fetch and decode, similar to drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c.",
      "id": "CVE-2022-49218",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-18T19:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:50Z"
      },
      "bom-ref": "cbd62d98-c0ba-4a48-9ca1-1c5e1d176678",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: hwrng: cavium - fix NULL but dereferenced coccicheck error Fix following coccicheck warning: ./drivers/char/hw_random/cavium-rng-vf.c:182:17-20: ERROR: pdev is NULL but dereferenced.",
      "id": "CVE-2022-49177",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-17T18:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:51Z"
      },
      "bom-ref": "2b9be722-0bd4-4514-9bbd-858eb55cfb4a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: do not clean up repair bio if submit fails The submit helper will always run bio_endio() on the bio if it fails to submit, so cleaning up the bio just leads to a variety of use-after-free and NULL pointer dereference bugs because we race with the endio function that is cleaning up the bio. Instead just return BLK_STS_OK as the repair function has to continue to process the rest of the pages, and the endio for the repair bio will do the appropriate cleanup for the page that it was given.",
      "id": "CVE-2022-49168",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:53Z"
      },
      "bom-ref": "2c2b88b7-a184-461a-801f-5c1ec5a2c17a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mlxsw: spectrum: Guard against invalid local ports When processing events generated by the device's firmware, the driver protects itself from events reported for non-existent local ports, but not for the CPU port (local port 0), which exists, but does not have all the fields as any local port. This can result in a NULL pointer dereference when trying access 'struct mlxsw_sp_port' fields which are not initialized for CPU port. Commit 63b08b1f6834 (\"mlxsw: spectrum: Protect driver from buggy firmware\") already handled such issue by bailing early when processing a PUDE event reported for the CPU port. Generalize the approach by moving the check to a common function and making use of it in all relevant places.",
      "id": "CVE-2022-49134",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_DRM_SPRD is not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "8d5682d5-7844-48db-a5f1-3569dc18431d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/sprd: fix potential NULL dereference 'drm' could be null in sprd_drm_shutdown, and drm_warn maybe dereference it, remove this warning log. v1 -> v2: - Split checking platform_get_resource() return value to a separate patch - Use dev_warn() instead of removing the warning log",
      "id": "CVE-2022-49125",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:54Z"
      },
      "bom-ref": "e326be55-7b80-428e-85f6-51428cb55825",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ath11k: Fix frames flush failure caused by deadlock We are seeing below warnings: kernel: [25393.301506] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0 kernel: [25398.421509] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0 kernel: [25398.421831] ath11k_pci 0000:01:00.0: dropping mgmt frame for vdev 0, is_started 0 this means ath11k fails to flush mgmt. frames because wmi_mgmt_tx_work has no chance to run in 5 seconds. By setting /proc/sys/kernel/hung_task_timeout_secs to 20 and increasing ATH11K_FLUSH_TIMEOUT to 50 we get below warnings: kernel: [ 120.763160] INFO: task wpa_supplicant:924 blocked for more than 20 seconds. kernel: [ 120.763169] Not tainted 5.10.90 #12 kernel: [ 120.763177] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message. kernel: [ 120.763186] task:wpa_supplicant state:D stack: 0 pid: 924 ppid: 1 flags:0x000043a0 kernel: [ 120.763201] Call Trace: kernel: [ 120.763214] __schedule+0x785/0x12fa kernel: [ 120.763224] ? lockdep_hardirqs_on_prepare+0xe2/0x1bb kernel: [ 120.763242] schedule+0x7e/0xa1 kernel: [ 120.763253] schedule_timeout+0x98/0xfe kernel: [ 120.763266] ? run_local_timers+0x4a/0x4a kernel: [ 120.763291] ath11k_mac_flush_tx_complete+0x197/0x2b1 [ath11k 13c3a9bf37790f4ac8103b3decf7ab4008ac314a] kernel: [ 120.763306] ? init_wait_entry+0x2e/0x2e kernel: [ 120.763343] __ieee80211_flush_queues+0x167/0x21f [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763378] __ieee80211_recalc_idle+0x105/0x125 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763411] ieee80211_recalc_idle+0x14/0x27 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763441] ieee80211_free_chanctx+0x77/0xa2 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763473] __ieee80211_vif_release_channel+0x100/0x131 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763540] ieee80211_vif_release_channel+0x66/0x81 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763572] ieee80211_destroy_auth_data+0xa3/0xe6 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763612] ieee80211_mgd_deauth+0x178/0x29b [mac80211 335da900954f1c5ea7f1613d92088ce83342042c] kernel: [ 120.763654] cfg80211_mlme_deauth+0x1a8/0x22c [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [ 120.763697] nl80211_deauthenticate+0xfa/0x123 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [ 120.763715] genl_rcv_msg+0x392/0x3c2 kernel: [ 120.763750] ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [ 120.763782] ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be] kernel: [ 120.763802] ? genl_rcv+0x36/0x36 kernel: [ 120.763814] netlink_rcv_skb+0x89/0xf7 kernel: [ 120.763829] genl_rcv+0x28/0x36 kernel: [ 120.763840] netlink_unicast+0x179/0x24b kernel: [ 120.763854] netlink_sendmsg+0x393/0x401 kernel: [ 120.763872] sock_sendmsg+0x72/0x76 kernel: [ 120.763886] ____sys_sendmsg+0x170/0x1e6 kernel: [ 120.763897] ? copy_msghdr_from_user+0x7a/0xa2 kernel: [ 120.763914] ___sys_sendmsg+0x95/0xd1 kernel: [ 120.763940] __sys_sendmsg+0x85/0xbf kernel: [ 120.763956] do_syscall_64+0x43/0x55 kernel: [ 120.763966] entry_SYSCALL_64_after_hwframe+0x44/0xa9 kernel: [ 120.763977] RIP: 0033:0x79089f3fcc83 kernel: [ 120.763986] RSP: 002b:00007ffe604f0508 EFLAGS: 00000246 ORIG_RAX: 000000000000002e kernel: [ 120.763997] RAX: ffffffffffffffda RBX: 000059b40e987690 RCX: 000079089f3fcc83 kernel: [ 120.764006] RDX: 0000000000000000 RSI: 00007ffe604f0558 RDI: 0000000000000009 kernel: [ 120.764014] RBP: 00007ffe604f0540 R08: 0000000000000004 R09: 0000000000400000 kernel: [ 120.764023] R10: 00007ffe604f0638 R11: 0000000000000246 R12: 000059b40ea04980 kernel: [ 120.764032] R13: 00007ffe604 ---truncated---",
      "id": "CVE-2022-49123",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:56Z"
      },
      "bom-ref": "3e88f8a8-ae6c-4040-be03-4c8f32eaf64e",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: clk: mediatek: Fix memory leaks on probe Handle the error branches to free memory where required. Addresses-Coverity-ID: 1491825 (\"Resource leak\")",
      "id": "CVE-2022-49108",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:57Z"
      },
      "bom-ref": "508ab1aa-a352-430d-9af0-7cf20623682a",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: arfs: fix use-after-free when freeing @rx_cpu_rmap The CI testing bots triggered the following splat: [ 718.203054] BUG: KASAN: use-after-free in free_irq_cpu_rmap+0x53/0x80 [ 718.206349] Read of size 4 at addr ffff8881bd127e00 by task sh/20834 [ 718.212852] CPU: 28 PID: 20834 Comm: sh Kdump: loaded Tainted: G S W IOE 5.17.0-rc8_nextqueue-devqueue-02643-g23f3121aca93 #1 [ 718.219695] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0012.070720200218 07/07/2020 [ 718.223418] Call Trace: [ 718.227139] [ 718.230783] dump_stack_lvl+0x33/0x42 [ 718.234431] print_address_description.constprop.9+0x21/0x170 [ 718.238177] ? free_irq_cpu_rmap+0x53/0x80 [ 718.241885] ? free_irq_cpu_rmap+0x53/0x80 [ 718.245539] kasan_report.cold.18+0x7f/0x11b [ 718.249197] ? free_irq_cpu_rmap+0x53/0x80 [ 718.252852] free_irq_cpu_rmap+0x53/0x80 [ 718.256471] ice_free_cpu_rx_rmap.part.11+0x37/0x50 [ice] [ 718.260174] ice_remove_arfs+0x5f/0x70 [ice] [ 718.263810] ice_rebuild_arfs+0x3b/0x70 [ice] [ 718.267419] ice_rebuild+0x39c/0xb60 [ice] [ 718.270974] ? asm_sysvec_apic_timer_interrupt+0x12/0x20 [ 718.274472] ? ice_init_phy_user_cfg+0x360/0x360 [ice] [ 718.278033] ? delay_tsc+0x4a/0xb0 [ 718.281513] ? preempt_count_sub+0x14/0xc0 [ 718.284984] ? delay_tsc+0x8f/0xb0 [ 718.288463] ice_do_reset+0x92/0xf0 [ice] [ 718.292014] ice_pci_err_resume+0x91/0xf0 [ice] [ 718.295561] pci_reset_function+0x53/0x80 <...> [ 718.393035] Allocated by task 690: [ 718.433497] Freed by task 20834: [ 718.495688] Last potentially related work creation: [ 718.568966] The buggy address belongs to the object at ffff8881bd127e00 which belongs to the cache kmalloc-96 of size 96 [ 718.574085] The buggy address is located 0 bytes inside of 96-byte region [ffff8881bd127e00, ffff8881bd127e60) [ 718.579265] The buggy address belongs to the page: [ 718.598905] Memory state around the buggy address: [ 718.601809] ffff8881bd127d00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc [ 718.604796] ffff8881bd127d80: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc [ 718.607794] >ffff8881bd127e00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc [ 718.610811] ^ [ 718.613819] ffff8881bd127e80: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc [ 718.617107] ffff8881bd127f00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc This is due to that free_irq_cpu_rmap() is always being called *after* (devm_)free_irq() and thus it tries to work with IRQ descs already freed. For example, on device reset the driver frees the rmap right before allocating a new one (the splat above). Make rmap creation and freeing function symmetrical with {request,free}_irq() calls i.e. do that on ifup/ifdown instead of device probe/remove/resume. These operations can be performed independently from the actual device aRFS configuration. Also, make sure ice_vsi_free_irq() clears IRQ affinity notifiers only when aRFS is disabled -- otherwise, CPU rmap sets and clears its own and they must not be touched manually.",
      "id": "CVE-2022-49063",
      "published": "2025-02-26T07:00:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-04T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:57:59Z"
      },
      "bom-ref": "deb597cb-1114-4daa-8d22-1dfba0137d35",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ax25: Fix refcount leak caused by setting SO_BINDTODEVICE sockopt If an AX25 device is bound to a socket by setting the SO_BINDTODEVICE socket option, a refcount leak will occur in ax25_release(). Commit 9fd75b66b8f6 (\"ax25: Fix refcount leaks caused by ax25_cb_del()\") added decrement of device refcounts in ax25_release(). In order for that to work correctly the refcounts must already be incremented when the device is bound to the socket. An AX25 device can be bound to a socket by either calling ax25_bind() or setting SO_BINDTODEVICE socket option. In both cases the refcounts should be incremented, but in fact it is done only in ax25_bind(). This bug leads to the following issue reported by Syzkaller: ================================================================ refcount_t: decrement hit 0; leaking memory. WARNING: CPU: 1 PID: 5932 at lib/refcount.c:31 refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31 Modules linked in: CPU: 1 UID: 0 PID: 5932 Comm: syz-executor424 Not tainted 6.13.0-rc4-syzkaller-00110-g4099a71718b0 #0 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014 RIP: 0010:refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31 Call Trace: <TASK> __refcount_dec include/linux/refcount.h:336 [inline] refcount_dec include/linux/refcount.h:351 [inline] ref_tracker_free+0x710/0x820 lib/ref_tracker.c:236 netdev_tracker_free include/linux/netdevice.h:4156 [inline] netdev_put include/linux/netdevice.h:4173 [inline] netdev_put include/linux/netdevice.h:4169 [inline] ax25_release+0x33f/0xa10 net/ax25/af_ax25.c:1069 __sock_release+0xb0/0x270 net/socket.c:640 sock_close+0x1c/0x30 net/socket.c:1408 ... do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f ... </TASK> ================================================================ Fix the implementation of ax25_setsockopt() by adding increment of refcounts for the new device bound, and decrement of refcounts for the old unbound device.",
      "id": "CVE-2025-21792",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-05T18:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "4edb9bd1-bda5-4ed8-926a-72ea8fe08c83",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: vrf: use RCU protection in l3mdev_l3_out() l3mdev_l3_out() can be called without RCU being held: raw_sendmsg() ip_push_pending_frames() ip_send_skb() ip_local_out() __ip_local_out() l3mdev_ip_out() Add rcu_read_lock() / rcu_read_unlock() pair to avoid a potential UAF.",
      "id": "CVE-2025-21791",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:00Z"
      },
      "bom-ref": "6bb979d7-4405-404e-ac24-7bac6012e428",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: team: better TEAM_OPTION_TYPE_STRING validation syzbot reported following splat [1] Make sure user-provided data contains one nul byte. [1] BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:633 [inline] BUG: KMSAN: uninit-value in string+0x3ec/0x5f0 lib/vsprintf.c:714 string_nocheck lib/vsprintf.c:633 [inline] string+0x3ec/0x5f0 lib/vsprintf.c:714 vsnprintf+0xa5d/0x1960 lib/vsprintf.c:2843 __request_module+0x252/0x9f0 kernel/module/kmod.c:149 team_mode_get drivers/net/team/team_core.c:480 [inline] team_change_mode drivers/net/team/team_core.c:607 [inline] team_mode_option_set+0x437/0x970 drivers/net/team/team_core.c:1401 team_option_set drivers/net/team/team_core.c:375 [inline] team_nl_options_set_doit+0x1339/0x1f90 drivers/net/team/team_core.c:2662 genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline] genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline] genl_rcv_msg+0x1214/0x12c0 net/netlink/genetlink.c:1210 netlink_rcv_skb+0x375/0x650 net/netlink/af_netlink.c:2543 genl_rcv+0x40/0x60 net/netlink/genetlink.c:1219 netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline] netlink_unicast+0xf52/0x1260 net/netlink/af_netlink.c:1348 netlink_sendmsg+0x10da/0x11e0 net/netlink/af_netlink.c:1892 sock_sendmsg_nosec net/socket.c:718 [inline] __sock_sendmsg+0x30f/0x380 net/socket.c:733 ____sys_sendmsg+0x877/0xb60 net/socket.c:2573 ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2627 __sys_sendmsg net/socket.c:2659 [inline] __do_sys_sendmsg net/socket.c:2664 [inline] __se_sys_sendmsg net/socket.c:2662 [inline] __x64_sys_sendmsg+0x212/0x3c0 net/socket.c:2662 x64_sys_call+0x2ed6/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:47 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2025-21787",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:02Z"
      },
      "bom-ref": "127d0f0a-2c01-4ee0-92ec-3e79a937dae5",
      "description": "In the Linux kernel, the following vulnerability has been resolved: workqueue: Put the pwq after detaching the rescuer from the pool The commit 68f83057b913(\"workqueue: Reap workers via kthread_stop() and remove detach_completion\") adds code to reap the normal workers but mistakenly does not handle the rescuer and also removes the code waiting for the rescuer in put_unbound_pool(), which caused a use-after-free bug reported by Cheung Wall. To avoid the use-after-free bug, the pool\u2019s reference must be held until the detachment is complete. Therefore, move the code that puts the pwq after detaching the rescuer from the pool.",
      "id": "CVE-2025-21786",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-21T15:43:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "745b1e61-5955-4140-9641-c53a86d567c8",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: arm64: cacheinfo: Avoid out-of-bounds write to cacheinfo array The loop that detects/populates cache information already has a bounds check on the array size but does not account for cache levels with separate data/instructions cache. Fix this by incrementing the index for any populated leaf (instead of any populated level).",
      "id": "CVE-2025-21785",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ORANGEFS_FS is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "c6ca72c5-c774-4af0-9379-571a02a34eda",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: orangefs: fix a oob in orangefs_debug_write I got a syzbot report: slab-out-of-bounds Read in orangefs_debug_write... several people suggested fixes, I tested Al Viro's suggestion and made this patch.",
      "id": "CVE-2025-21782",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "6f630b4f-6f3b-47d0-88bb-e98ba8844ea6",
      "cwes": [
        120
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table() It malicious user provides a small pptable through sysfs and then a bigger pptable, it may cause buffer overflow attack in function smu_sys_set_pp_table().",
      "id": "CVE-2025-21780",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-05T18:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:03Z"
      },
      "bom-ref": "acdc238c-538d-4cf0-96d7-ab84818e3200",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: KVM: x86: Reject Hyper-V's SEND_IPI hypercalls if local APIC isn't in-kernel Advertise support for Hyper-V's SEND_IPI and SEND_IPI_EX hypercalls if and only if the local API is emulated/virtualized by KVM, and explicitly reject said hypercalls if the local APIC is emulated in userspace, i.e. don't rely on userspace to opt-in to KVM_CAP_HYPERV_ENFORCE_CPUID. Rejecting SEND_IPI and SEND_IPI_EX fixes a NULL-pointer dereference if Hyper-V enlightenments are exposed to the guest without an in-kernel local APIC: dump_stack+0xbe/0xfd __kasan_report.cold+0x34/0x84 kasan_report+0x3a/0x50 __apic_accept_irq+0x3a/0x5c0 kvm_hv_send_ipi.isra.0+0x34e/0x820 kvm_hv_hypercall+0x8d9/0x9d0 kvm_emulate_hypercall+0x506/0x7e0 __vmx_handle_exit+0x283/0xb60 vmx_handle_exit+0x1d/0xd0 vcpu_enter_guest+0x16b0/0x24c0 vcpu_run+0xc0/0x550 kvm_arch_vcpu_ioctl_run+0x170/0x6d0 kvm_vcpu_ioctl+0x413/0xb20 __se_sys_ioctl+0x111/0x160 do_syscal1_64+0x30/0x40 entry_SYSCALL_64_after_hwframe+0x67/0xd1 Note, checking the sending vCPU is sufficient, as the per-VM irqchip_mode can't be modified after vCPUs are created, i.e. if one vCPU has an in-kernel local APIC, then all vCPUs have an in-kernel local APIC.",
      "id": "CVE-2025-21779",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:05Z"
      },
      "bom-ref": "f9360abd-f607-4930-b0b8-73904dec79cf",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: USB: hub: Ignore non-compliant devices with too many configs or interfaces Robert Morris created a test program which can cause usb_hub_to_struct_hub() to dereference a NULL or inappropriate pointer: Oops: general protection fault, probably for non-canonical address 0xcccccccccccccccc: 0000 [#1] SMP DEBUG_PAGEALLOC PTI CPU: 7 UID: 0 PID: 117 Comm: kworker/7:1 Not tainted 6.13.0-rc3-00017-gf44d154d6e3d #14 Hardware name: FreeBSD BHYVE/BHYVE, BIOS 14.0 10/17/2021 Workqueue: usb_hub_wq hub_event RIP: 0010:usb_hub_adjust_deviceremovable+0x78/0x110 ... Call Trace: <TASK> ? die_addr+0x31/0x80 ? exc_general_protection+0x1b4/0x3c0 ? asm_exc_general_protection+0x26/0x30 ? usb_hub_adjust_deviceremovable+0x78/0x110 hub_probe+0x7c7/0xab0 usb_probe_interface+0x14b/0x350 really_probe+0xd0/0x2d0 ? __pfx___device_attach_driver+0x10/0x10 __driver_probe_device+0x6e/0x110 driver_probe_device+0x1a/0x90 __device_attach_driver+0x7e/0xc0 bus_for_each_drv+0x7f/0xd0 __device_attach+0xaa/0x1a0 bus_probe_device+0x8b/0xa0 device_add+0x62e/0x810 usb_set_configuration+0x65d/0x990 usb_generic_driver_probe+0x4b/0x70 usb_probe_device+0x36/0xd0 The cause of this error is that the device has two interfaces, and the hub driver binds to interface 1 instead of interface 0, which is where usb_hub_to_struct_hub() looks. We can prevent the problem from occurring by refusing to accept hub devices that violate the USB spec by having more than one configuration or interface.",
      "id": "CVE-2025-21776",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:06Z"
      },
      "bom-ref": "afdbec0e-9e16-4803-bde7-89624100a519",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipv6: mcast: extend RCU protection in igmp6_send() igmp6_send() can be called without RTNL or RCU being held. Extend RCU protection so that we can safely fetch the net pointer and avoid a potential UAF. Note that we no longer can use sock_alloc_send_skb() because ipv6.igmp_sk uses GFP_KERNEL allocations which can sleep. Instead use alloc_skb() and charge the net->ipv6.igmp_sk socket under RCU protection.",
      "id": "CVE-2025-21759",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:08Z"
      },
      "bom-ref": "856888e0-8b93-4e55-8795-760e39cfbe55",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/mlx5: HWS, change error flow on matcher disconnect Currently, when firmware failure occurs during matcher disconnect flow, the error flow of the function reconnects the matcher back and returns an error, which continues running the calling function and eventually frees the matcher that is being disconnected. This leads to a case where we have a freed matcher on the matchers list, which in turn leads to use-after-free and eventual crash. This patch fixes that by not trying to reconnect the matcher back when some FW command fails during disconnect. Note that we're dealing here with FW error. We can't overcome this problem. This might lead to bad steering state (e.g. wrong connection between matchers), and will also lead to resource leakage, as it is the case with any other error handling during resource destruction. However, the goal here is to allow the driver to continue and not crash the machine with use-after-free error.",
      "id": "CVE-2025-21751",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:20:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:09Z"
      },
      "bom-ref": "088379be-3f75-478a-80aa-fd6bb80fe262",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: rose: lock the socket in rose_bind() syzbot reported a soft lockup in rose_loopback_timer(), with a repro calling bind() from multiple threads. rose_bind() must lock the socket to avoid this issue.",
      "id": "CVE-2025-21749",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:11Z"
      },
      "bom-ref": "b709ce72-78be-4280-b644-16059e9283b8",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix integer overflows on 32 bit systems On 32bit systems the addition operations in ipc_msg_alloc() can potentially overflow leading to memory corruption. Add bounds checking using KSMBD_IPC_MAX_PAYLOAD to avoid overflow.",
      "id": "CVE-2025-21748",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:12Z"
      },
      "bom-ref": "b3616c5f-af6d-4454-b7c0-8b79c064f7fb",
      "description": "In the Linux kernel, the following vulnerability has been resolved: blk-cgroup: Fix class @block_class's subsystem refcount leakage blkcg_fill_root_iostats() iterates over @block_class's devices by class_dev_iter_(init|next)(), but does not end iterating with class_dev_iter_exit(), so causes the class's subsystem refcount leakage. Fix by ending the iterating with class_dev_iter_exit().",
      "id": "CVE-2025-21745",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:14Z"
      },
      "bom-ref": "58d582b7-5c6a-4461-b2a7-f5aae4511221",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: brcmfmac: fix NULL pointer dereference in brcmf_txfinalize() On removal of the device or unloading of the kernel module a potential NULL pointer dereference occurs. The following sequence deletes the interface: brcmf_detach() brcmf_remove_interface() brcmf_del_if() Inside the brcmf_del_if() function the drvr->if2bss[ifidx] is updated to BRCMF_BSSIDX_INVALID (-1) if the bsscfgidx matches. After brcmf_remove_interface() call the brcmf_proto_detach() function is called providing the following sequence: brcmf_detach() brcmf_proto_detach() brcmf_proto_msgbuf_detach() brcmf_flowring_detach() brcmf_msgbuf_delete_flowring() brcmf_msgbuf_remove_flowring() brcmf_flowring_delete() brcmf_get_ifp() brcmf_txfinalize() Since brcmf_get_ip() can and actually will return NULL in this case the call to brcmf_txfinalize() will result in a NULL pointer dereference inside brcmf_txfinalize() when trying to update ifp->ndev->stats.tx_errors. This will only happen if a flowring still has an skb. Although the NULL pointer dereference has only been seen when trying to update the tx statistic, all other uses of the ifp pointer have been guarded as well with an early return if ifp is NULL.",
      "id": "CVE-2025-21744",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:15Z"
      },
      "bom-ref": "107f98aa-fa91-4a7b-89dc-ba1b87d5ad43",
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: core: Fix use-after free in init error and remove paths devm_blk_crypto_profile_init() registers a cleanup handler to run when the associated (platform-) device is being released. For UFS, the crypto private data and pointers are stored as part of the ufs_hba's data structure 'struct ufs_hba::crypto_profile'. This structure is allocated as part of the underlying ufshcd and therefore Scsi_host allocation. During driver release or during error handling in ufshcd_pltfrm_init(), this structure is released as part of ufshcd_dealloc_host() before the (platform-) device associated with the crypto call above is released. Once this device is released, the crypto cleanup code will run, using the just-released 'struct ufs_hba::crypto_profile'. This causes a use-after-free situation: Call trace: kfree+0x60/0x2d8 (P) kvfree+0x44/0x60 blk_crypto_profile_destroy_callback+0x28/0x70 devm_action_release+0x1c/0x30 release_nodes+0x6c/0x108 devres_release_all+0x98/0x100 device_unbind_cleanup+0x20/0x70 really_probe+0x218/0x2d0 In other words, the initialisation code flow is: platform-device probe ufshcd_pltfrm_init() ufshcd_alloc_host() scsi_host_alloc() allocation of struct ufs_hba creation of scsi-host devices devm_blk_crypto_profile_init() devm registration of cleanup handler using platform-device and during error handling of ufshcd_pltfrm_init() or during driver removal: ufshcd_dealloc_host() scsi_host_put() put_device(scsi-host) release of struct ufs_hba put_device(platform-device) crypto cleanup handler To fix this use-after free, change ufshcd_alloc_host() to register a devres action to automatically cleanup the underlying SCSI device on ufshcd destruction, without requiring explicit calls to ufshcd_dealloc_host(). This way: * the crypto profile and all other ufs_hba-owned resources are destroyed before SCSI (as they've been registered after) * a memleak is plugged in tc-dwc-g210-pci.c remove() as a side-effect * EXPORT_SYMBOL_GPL(ufshcd_dealloc_host) can be removed fully as it's not needed anymore * no future drivers using ufshcd_alloc_host() could ever forget adding the cleanup",
      "id": "CVE-2025-21739",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:12:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:17Z"
      },
      "bom-ref": "2f4f25df-e4b7-41dc-b180-419d515cf2ae",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nilfs2: fix possible int overflows in nilfs_fiemap() Since nilfs_bmap_lookup_contig() in nilfs_fiemap() calculates its result by being prepared to go through potentially maxblocks == INT_MAX blocks, the value in n may experience an overflow caused by left shift of blkbits. While it is extremely unlikely to occur, play it safe and cast right hand expression to wider type to mitigate the issue. Found by Linux Verification Center (linuxtesting.org) with static analysis tool SVACE.",
      "id": "CVE-2025-21736",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "90af0c80-8ab3-416b-be29-5ed699ea2c32",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: NFC: nci: Add bounds checking in nci_hci_create_pipe() The \"pipe\" variable is a u8 which comes from the network. If it's more than 127, then it results in memory corruption in the caller, nci_hci_connect_gate().",
      "id": "CVE-2025-21735",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:18Z"
      },
      "bom-ref": "239aba52-99b6-4ad2-8471-4e772fd290ce",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: HID: multitouch: Add NULL check in mt_input_configured devm_kasprintf() can return a NULL pointer on failure,but this returned value in mt_input_configured() is not checked. Add NULL check in mt_input_configured(), to handle kernel NULL pointer dereference error.",
      "id": "CVE-2024-58020",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:20Z"
      },
      "bom-ref": "e56f398d-4759-4a23-ac6a-11797cee447b",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: printk: Fix signed integer overflow when defining LOG_BUF_LEN_MAX Shifting 1 << 31 on a 32-bit int causes signed integer overflow, which leads to undefined behavior. To prevent this, cast 1 to u32 before performing the shift, ensuring well-defined behavior. This change explicitly avoids any potential overflow by ensuring that the shift occurs on an unsigned 32-bit integer.",
      "id": "CVE-2024-58017",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:21Z"
      },
      "bom-ref": "892b72a0-0579-4977-a62b-3bce5bacc71e",
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: MGMT: Fix slab-use-after-free Read in mgmt_remove_adv_monitor_sync This fixes the following crash: ================================================================== BUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543 Read of size 8 at addr ffff88814128f898 by task kworker/u9:4/5961 CPU: 1 UID: 0 PID: 5961 Comm: kworker/u9:4 Not tainted 6.12.0-syzkaller-10684-gf1cd565ce577 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: hci0 hci_cmd_sync_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 16026: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269 mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296 remove_adv_monitor+0x102/0x1b0 net/bluetooth/mgmt.c:5568 hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712 hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832 sock_sendmsg_nosec net/socket.c:711 [inline] __sock_sendmsg+0x221/0x270 net/socket.c:726 sock_write_iter+0x2d7/0x3f0 net/socket.c:1147 new_sync_write fs/read_write.c:586 [inline] vfs_write+0xaeb/0xd30 fs/read_write.c:679 ksys_write+0x18f/0x2b0 fs/read_write.c:731 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 16022: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2338 [inline] slab_free mm/slub.c:4598 [inline] kfree+0x196/0x420 mm/slub.c:4746 mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259 __mgmt_power_off+0x183/0x430 net/bluetooth/mgmt.c:9550 hci_dev_close_sync+0x6c4/0x11c0 net/bluetooth/hci_sync.c:5208 hci_dev_do_close net/bluetooth/hci_core.c:483 [inline] hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508 sock_do_ioctl+0x158/0x460 net/socket.c:1209 sock_ioctl+0x626/0x8e0 net/socket.c:1328 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-58013",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T18:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:23Z"
      },
      "bom-ref": "18751b3b-0f39-425a-8139-2f6005c444d1",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ASoC: SOF: Intel: hda-dai: Ensure DAI widget is valid during params Each cpu DAI should associate with a widget. However, the topology might not create the right number of DAI widgets for aggregated amps. And it will cause NULL pointer deference. Check that the DAI widget associated with the CPU DAI is valid to prevent NULL pointer deference due to missing DAI widgets in topologies with aggregated amps.",
      "id": "CVE-2024-58012",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T12:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:24Z"
      },
      "bom-ref": "ab2925d6-fbef-48b8-a6b5-8f12c30af6e9",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: platform/x86: int3472: Check for adev == NULL Not all devices have an ACPI companion fwnode, so adev might be NULL. This can e.g. (theoretically) happen when a user manually binds one of the int3472 drivers to another i2c/platform device through sysfs. Add a check for adev not being set and return -ENODEV in that case to avoid a possible NULL pointer deref in skl_int3472_get_acpi_buffer().",
      "id": "CVE-2024-58011",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-06T12:49:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:26Z"
      },
      "bom-ref": "6b35f911-16df-4857-b537-f5813c67743e",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: binfmt_flat: Fix integer overflow bug on 32 bit systems Most of these sizes and counts are capped at 256MB so the math doesn't result in an integer overflow. The \"relocs\" count needs to be checked as well. Otherwise on 32bit systems the calculation of \"full_data\" could be wrong. full_data = data_len + relocs * sizeof(unsigned long);",
      "id": "CVE-2024-58010",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "ca9c5887-d2f1-4375-b2d9-e00cffd63072",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: soc: qcom: socinfo: Avoid out of bounds read of serial number On MSM8916 devices, the serial number exposed in sysfs is constant and does not change across individual devices. It's always: db410c:/sys/devices/soc0$ cat serial_number 2644893864 The firmware used on MSM8916 exposes SOCINFO_VERSION(0, 8), which does not have support for the serial_num field in the socinfo struct. There is an existing check to avoid exposing the serial number in that case, but it's not correct: When checking the item_size returned by SMEM, we need to make sure the *end* of the serial_num is within bounds, instead of comparing with the *start* offset. The serial_number currently exposed on MSM8916 devices is just an out of bounds read of whatever comes after the socinfo struct in SMEM. Fix this by changing offsetof() to offsetofend(), so that the size of the field is also taken into account.",
      "id": "CVE-2024-58007",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:27Z"
      },
      "bom-ref": "f06838c5-63cb-48da-9a85-9e6e8f334b03",
      "description": "In the Linux kernel, the following vulnerability has been resolved: tpm: Change to kvalloc() in eventlog/acpi.c The following failure was reported on HPE ProLiant D320: [ 10.693310][ T1] tpm_tis STM0925:00: 2.0 TPM (device-id 0x3, rev-id 0) [ 10.848132][ T1] ------------[ cut here ]------------ [ 10.853559][ T1] WARNING: CPU: 59 PID: 1 at mm/page_alloc.c:4727 __alloc_pages_noprof+0x2ca/0x330 [ 10.862827][ T1] Modules linked in: [ 10.866671][ T1] CPU: 59 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-lp155.2.g52785e2-default #1 openSUSE Tumbleweed (unreleased) 588cd98293a7c9eba9013378d807364c088c9375 [ 10.882741][ T1] Hardware name: HPE ProLiant DL320 Gen12/ProLiant DL320 Gen12, BIOS 1.20 10/28/2024 [ 10.892170][ T1] RIP: 0010:__alloc_pages_noprof+0x2ca/0x330 [ 10.898103][ T1] Code: 24 08 e9 4a fe ff ff e8 34 36 fa ff e9 88 fe ff ff 83 fe 0a 0f 86 b3 fd ff ff 80 3d 01 e7 ce 01 00 75 09 c6 05 f8 e6 ce 01 01 <0f> 0b 45 31 ff e9 e5 fe ff ff f7 c2 00 00 08 00 75 42 89 d9 80 e1 [ 10.917750][ T1] RSP: 0000:ffffb7cf40077980 EFLAGS: 00010246 [ 10.923777][ T1] RAX: 0000000000000000 RBX: 0000000000040cc0 RCX: 0000000000000000 [ 10.931727][ T1] RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000040cc0 The above transcript shows that ACPI pointed a 16 MiB buffer for the log events because RSI maps to the 'order' parameter of __alloc_pages_noprof(). Address the bug by moving from devm_kmalloc() to devm_add_action() and kvmalloc() and devm_add_action().",
      "id": "CVE-2024-58005",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "cfd733ae-815f-4ed7-8ec3-b3c520669117",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Remove dangling pointers When an async control is written, we copy a pointer to the file handle that started the operation. That pointer will be used when the device is done. Which could be anytime in the future. If the user closes that file descriptor, its structure will be freed, and there will be one dangling pointer per pending async control, that the driver will try to use. Clean all the dangling pointers during release(). To avoid adding a performance penalty in the most common case (no async operation), a counter has been introduced with some logic to make sure that it is properly handled.",
      "id": "CVE-2024-58002",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:29Z"
      },
      "bom-ref": "327b4118-acf5-4371-af79-2106b29f37fb",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: vidtv: Fix a null-ptr-deref in vidtv_mux_stop_thread syzbot report a null-ptr-deref in vidtv_mux_stop_thread. [1] If dvb->mux is not initialized successfully by vidtv_mux_init() in the vidtv_start_streaming(), it will trigger null pointer dereference about mux in vidtv_mux_stop_thread(). Adjust the timing of streaming initialization and check it before stopping it. [1] KASAN: null-ptr-deref in range [0x0000000000000128-0x000000000000012f] CPU: 0 UID: 0 PID: 5842 Comm: syz-executor248 Not tainted 6.13.0-rc4-syzkaller-00012-g9b2ffa6148b1 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 RIP: 0010:vidtv_mux_stop_thread+0x26/0x80 drivers/media/test-drivers/vidtv/vidtv_mux.c:471 Code: 90 90 90 90 66 0f 1f 00 55 53 48 89 fb e8 82 2e c8 f9 48 8d bb 28 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 02 7e 3b 0f b6 ab 28 01 00 00 31 ff 89 ee e8 RSP: 0018:ffffc90003f2faa8 EFLAGS: 00010202 RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff87cfb125 RDX: 0000000000000025 RSI: ffffffff87d120ce RDI: 0000000000000128 RBP: ffff888029b8d220 R08: 0000000000000005 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000003 R12: ffff888029b8d188 R13: ffffffff8f590aa0 R14: ffffc9000581c5c8 R15: ffff888029a17710 FS: 00007f7eef5156c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f7eef5e635c CR3: 0000000076ca6000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> vidtv_stop_streaming drivers/media/test-drivers/vidtv/vidtv_bridge.c:209 [inline] vidtv_stop_feed+0x151/0x250 drivers/media/test-drivers/vidtv/vidtv_bridge.c:252 dmx_section_feed_stop_filtering+0x90/0x160 drivers/media/dvb-core/dvb_demux.c:1000 dvb_dmxdev_feed_stop.isra.0+0x1ee/0x270 drivers/media/dvb-core/dmxdev.c:486 dvb_dmxdev_filter_stop+0x22a/0x3a0 drivers/media/dvb-core/dmxdev.c:559 dvb_dmxdev_filter_free drivers/media/dvb-core/dmxdev.c:840 [inline] dvb_demux_release+0x92/0x550 drivers/media/dvb-core/dmxdev.c:1246 __fput+0x3f8/0xb60 fs/file_table.c:450 task_work_run+0x14e/0x250 kernel/task_work.c:239 get_signal+0x1d3/0x2610 kernel/signal.c:2790 arch_do_signal_or_restart+0x90/0x7e0 arch/x86/kernel/signal.c:337 exit_to_user_mode_loop kernel/entry/common.c:111 [inline] exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline] __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline] syscall_exit_to_user_mode+0x150/0x2a0 kernel/entry/common.c:218 do_syscall_64+0xda/0x250 arch/x86/entry/common.c:89 entry_SYSCALL_64_after_hwframe+0x77/0x7f",
      "id": "CVE-2024-57834",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:30Z"
      },
      "bom-ref": "3003580f-0433-4077-83fc-c07bca7b1266",
      "description": "In the Linux kernel, the following vulnerability has been resolved: scsi: ufs: bsg: Set bsg_queue to NULL after removal Currently, this does not cause any issues, but I believe it is necessary to set bsg_queue to NULL after removing it to prevent potential use-after-free (UAF) access.",
      "id": "CVE-2024-54458",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:32Z"
      },
      "bom-ref": "3afde3e4-299d-4ea2-9352-0ac183986773",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/msm/gem: prevent integer overflow in msm_ioctl_gem_submit() The \"submit->cmd[i].size\" and \"submit->cmd[i].offset\" variables are u32 values that come from the user via the submit_lookup_cmds() function. This addition could lead to an integer wrapping bug so use size_add() to prevent that. Patchwork: https://patchwork.freedesktop.org/patch/624696/",
      "id": "CVE-2024-52559",
      "published": "2025-02-27T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T12:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "70d7715d-2baf-42d6-8d20-7ad99fe48105",
      "cwes": [
        362,
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: rose: fix timer races against user threads Rose timers only acquire the socket spinlock, without checking if the socket is owned by one user thread. Add a check and rearm the timers if needed. BUG: KASAN: slab-use-after-free in rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174 Read of size 2 at addr ffff88802f09b82a by task swapper/0/0 CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.13.0-rc5-syzkaller-00172-gd1bf27c4e176 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <IRQ> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174 call_timer_fn+0x187/0x650 kernel/time/timer.c:1793 expire_timers kernel/time/timer.c:1844 [inline] __run_timers kernel/time/timer.c:2418 [inline] __run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2430 run_timer_base kernel/time/timer.c:2439 [inline] run_timer_softirq+0xb7/0x170 kernel/time/timer.c:2449 handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561 __do_softirq kernel/softirq.c:595 [inline] invoke_softirq kernel/softirq.c:435 [inline] __irq_exit_rcu+0xf7/0x220 kernel/softirq.c:662 irq_exit_rcu+0x9/0x30 kernel/softirq.c:678 instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline] sysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1049 </IRQ>",
      "id": "CVE-2025-21718",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:33Z"
      },
      "bom-ref": "423f9989-3692-482d-b375-d6d9843f020d",
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/mlx5: Fix implicit ODP use after free Prevent double queueing of implicit ODP mr destroy work by using __xa_cmpxchg() to make sure this is the only time we are destroying this specific mr. Without this change, we could try to invalidate this mr twice, which in turn could result in queuing a MR work destroy twice, and eventually the second work could execute after the MR was freed due to the first work, causing a user after free and trace below. refcount_t: underflow; use-after-free. WARNING: CPU: 2 PID: 12178 at lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130 Modules linked in: bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [last unloaded: ib_uverbs] CPU: 2 PID: 12178 Comm: kworker/u20:5 Not tainted 6.5.0-rc1_net_next_mlx5_58c644e #1 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014 Workqueue: events_unbound free_implicit_child_mr_work [mlx5_ib] RIP: 0010:refcount_warn_saturate+0x12b/0x130 Code: 48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ff RSP: 0018:ffff8881008e3e40 EFLAGS: 00010286 RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000027 RDX: ffff88852c91b5c8 RSI: 0000000000000001 RDI: ffff88852c91b5c0 RBP: ffff8881dacd4e00 R08: 00000000ffffffff R09: 0000000000000019 R10: 000000000000072e R11: 0000000063666572 R12: ffff88812bfd9e00 R13: ffff8881c792d200 R14: ffff88810011c005 R15: ffff8881002099c0 FS: 0000000000000000(0000) GS:ffff88852c900000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f5694b5e000 CR3: 00000001153f6003 CR4: 0000000000370ea0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ? refcount_warn_saturate+0x12b/0x130 free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib] process_one_work+0x1cc/0x3c0 worker_thread+0x218/0x3c0 kthread+0xc6/0xf0 ret_from_fork+0x1f/0x30 </TASK>",
      "id": "CVE-2025-21714",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_ROSE is not set",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e6ebdfa8-e0e0-42b4-bd8b-a7edf8d2b6ba",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net/rose: prevent integer overflows in rose_setsockopt() In case of possible unpredictably large arguments passed to rose_setsockopt() and multiplied by extra values on top of that, integer overflows may occur. Do the safest minimum and fix these issues by checking the contents of 'opt' and returning -EINVAL if they are too large. Also, switch to unsigned int and remove useless check for negative 'opt' in ROSE_IDLE case.",
      "id": "CVE-2025-21711",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:35Z"
      },
      "bom-ref": "961c4cca-8b94-4a68-8614-feed4a83f7af",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mptcp: consolidate suboption status MPTCP maintains the received sub-options status is the bitmask carrying the received suboptions and in several bitfields carrying per suboption additional info. Zeroing the bitmask before parsing is not enough to ensure a consistent status, and the MPTCP code has to additionally clear some bitfiled depending on the actually parsed suboption. The above schema is fragile, and syzbot managed to trigger a path where a relevant bitfield is not cleared/initialized: BUG: KMSAN: uninit-value in __mptcp_expand_seq net/mptcp/options.c:1030 [inline] BUG: KMSAN: uninit-value in mptcp_expand_seq net/mptcp/protocol.h:864 [inline] BUG: KMSAN: uninit-value in ack_update_msk net/mptcp/options.c:1060 [inline] BUG: KMSAN: uninit-value in mptcp_incoming_options+0x2036/0x3d30 net/mptcp/options.c:1209 __mptcp_expand_seq net/mptcp/options.c:1030 [inline] mptcp_expand_seq net/mptcp/protocol.h:864 [inline] ack_update_msk net/mptcp/options.c:1060 [inline] mptcp_incoming_options+0x2036/0x3d30 net/mptcp/options.c:1209 tcp_data_queue+0xb4/0x7be0 net/ipv4/tcp_input.c:5233 tcp_rcv_established+0x1061/0x2510 net/ipv4/tcp_input.c:6264 tcp_v4_do_rcv+0x7f3/0x11a0 net/ipv4/tcp_ipv4.c:1916 tcp_v4_rcv+0x51df/0x5750 net/ipv4/tcp_ipv4.c:2351 ip_protocol_deliver_rcu+0x2a3/0x13d0 net/ipv4/ip_input.c:205 ip_local_deliver_finish+0x336/0x500 net/ipv4/ip_input.c:233 NF_HOOK include/linux/netfilter.h:314 [inline] ip_local_deliver+0x21f/0x490 net/ipv4/ip_input.c:254 dst_input include/net/dst.h:460 [inline] ip_rcv_finish+0x4a2/0x520 net/ipv4/ip_input.c:447 NF_HOOK include/linux/netfilter.h:314 [inline] ip_rcv+0xcd/0x380 net/ipv4/ip_input.c:567 __netif_receive_skb_one_core net/core/dev.c:5704 [inline] __netif_receive_skb+0x319/0xa00 net/core/dev.c:5817 process_backlog+0x4ad/0xa50 net/core/dev.c:6149 __napi_poll+0xe7/0x980 net/core/dev.c:6902 napi_poll net/core/dev.c:6971 [inline] net_rx_action+0xa5a/0x19b0 net/core/dev.c:7093 handle_softirqs+0x1a0/0x7c0 kernel/softirq.c:561 __do_softirq+0x14/0x1a kernel/softirq.c:595 do_softirq+0x9a/0x100 kernel/softirq.c:462 __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:389 local_bh_enable include/linux/bottom_half.h:33 [inline] rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline] __dev_queue_xmit+0x2758/0x57d0 net/core/dev.c:4493 dev_queue_xmit include/linux/netdevice.h:3168 [inline] neigh_hh_output include/net/neighbour.h:523 [inline] neigh_output include/net/neighbour.h:537 [inline] ip_finish_output2+0x187c/0x1b70 net/ipv4/ip_output.c:236 __ip_finish_output+0x287/0x810 ip_finish_output+0x4b/0x600 net/ipv4/ip_output.c:324 NF_HOOK_COND include/linux/netfilter.h:303 [inline] ip_output+0x15f/0x3f0 net/ipv4/ip_output.c:434 dst_output include/net/dst.h:450 [inline] ip_local_out net/ipv4/ip_output.c:130 [inline] __ip_queue_xmit+0x1f2a/0x20d0 net/ipv4/ip_output.c:536 ip_queue_xmit+0x60/0x80 net/ipv4/ip_output.c:550 __tcp_transmit_skb+0x3cea/0x4900 net/ipv4/tcp_output.c:1468 tcp_transmit_skb net/ipv4/tcp_output.c:1486 [inline] tcp_write_xmit+0x3b90/0x9070 net/ipv4/tcp_output.c:2829 __tcp_push_pending_frames+0xc4/0x380 net/ipv4/tcp_output.c:3012 tcp_send_fin+0x9f6/0xf50 net/ipv4/tcp_output.c:3618 __tcp_close+0x140c/0x1550 net/ipv4/tcp.c:3130 __mptcp_close_ssk+0x74e/0x16f0 net/mptcp/protocol.c:2496 mptcp_close_ssk+0x26b/0x2c0 net/mptcp/protocol.c:2550 mptcp_pm_nl_rm_addr_or_subflow+0x635/0xd10 net/mptcp/pm_netlink.c:889 mptcp_pm_nl_rm_subflow_received net/mptcp/pm_netlink.c:924 [inline] mptcp_pm_flush_addrs_and_subflows net/mptcp/pm_netlink.c:1688 [inline] mptcp_nl_flush_addrs_list net/mptcp/pm_netlink.c:1709 [inline] mptcp_pm_nl_flush_addrs_doit+0xe10/0x1630 net/mptcp/pm_netlink.c:1750 genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline] ---truncated---",
      "id": "CVE-2025-21707",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:36Z"
      },
      "bom-ref": "551b6b76-82ca-4104-8730-2e64e3ef474e",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: net_sched: sch_sfq: don't allow 1 packet limit The current implementation does not work correctly with a limit of 1. iproute2 actually checks for this and this patch adds the check in kernel as well. This fixes the following syzkaller reported crash: UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:210:6 index 65535 is out of range for type 'struct sfq_head[128]' CPU: 0 PID: 2569 Comm: syz-executor101 Not tainted 5.10.0-smp-DEV #1 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: __dump_stack lib/dump_stack.c:79 [inline] dump_stack+0x125/0x19f lib/dump_stack.c:120 ubsan_epilogue lib/ubsan.c:148 [inline] __ubsan_handle_out_of_bounds+0xed/0x120 lib/ubsan.c:347 sfq_link net/sched/sch_sfq.c:210 [inline] sfq_dec+0x528/0x600 net/sched/sch_sfq.c:238 sfq_dequeue+0x39b/0x9d0 net/sched/sch_sfq.c:500 sfq_reset+0x13/0x50 net/sched/sch_sfq.c:525 qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026 tbf_reset+0x3d/0x100 net/sched/sch_tbf.c:319 qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026 dev_reset_queue+0x8c/0x140 net/sched/sch_generic.c:1296 netdev_for_each_tx_queue include/linux/netdevice.h:2350 [inline] dev_deactivate_many+0x6dc/0xc20 net/sched/sch_generic.c:1362 __dev_close_many+0x214/0x350 net/core/dev.c:1468 dev_close_many+0x207/0x510 net/core/dev.c:1506 unregister_netdevice_many+0x40f/0x16b0 net/core/dev.c:10738 unregister_netdevice_queue+0x2be/0x310 net/core/dev.c:10695 unregister_netdevice include/linux/netdevice.h:2893 [inline] __tun_detach+0x6b6/0x1600 drivers/net/tun.c:689 tun_detach drivers/net/tun.c:705 [inline] tun_chr_close+0x104/0x1b0 drivers/net/tun.c:3640 __fput+0x203/0x840 fs/file_table.c:280 task_work_run+0x129/0x1b0 kernel/task_work.c:185 exit_task_work include/linux/task_work.h:33 [inline] do_exit+0x5ce/0x2200 kernel/exit.c:931 do_group_exit+0x144/0x310 kernel/exit.c:1046 __do_sys_exit_group kernel/exit.c:1057 [inline] __se_sys_exit_group kernel/exit.c:1055 [inline] __x64_sys_exit_group+0x3b/0x40 kernel/exit.c:1055 do_syscall_64+0x6c/0xd0 entry_SYSCALL_64_after_hwframe+0x61/0xcb RIP: 0033:0x7fe5e7b52479 Code: Unable to access opcode bytes at RIP 0x7fe5e7b5244f. RSP: 002b:00007ffd3c800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fe5e7b52479 RDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000 RBP: 00007fe5e7bcd2d0 R08: ffffffffffffffb8 R09: 0000000000000014 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe5e7bcd2d0 R13: 0000000000000000 R14: 00007fe5e7bcdd20 R15: 00007fe5e7b24270 The crash can be also be reproduced with the following (with a tc recompiled to allow for sfq limits of 1): tc qdisc add dev dummy0 handle 1: root tbf rate 1Kbit burst 100b lat 1s ../iproute2-6.9.0/tc/tc qdisc add dev dummy0 handle 2: parent 1:10 sfq limit 1 ifconfig dummy0 up ping -I dummy0 -f -c2 -W0.1 8.8.8.8 sleep 1 Scenario that triggers the crash: * the first packet is sent and queued in TBF and SFQ; qdisc qlen is 1 * TBF dequeues: it peeks from SFQ which moves the packet to the gso_skb list and keeps qdisc qlen set to 1. TBF is out of tokens so it schedules itself for later. * the second packet is sent and TBF tries to queues it to SFQ. qdisc qlen is now 2 and because the SFQ limit is 1 the packet is dropped by SFQ. At this point qlen is 1, and all of the SFQ slots are empty, however q->tail is not NULL. At this point, assuming no more packets are queued, when sch_dequeue runs again it will decrement the qlen for the current empty slot causing an underflow and the subsequent out of bounds access.",
      "id": "CVE-2024-57996",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-27T11:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:38Z"
      },
      "bom-ref": "d336342b-55f9-457d-bc07-ffc2abad2d7f",
      "description": "In the Linux kernel, the following vulnerability has been resolved: i3c: dw: Fix use-after-free in dw_i3c_master driver due to race condition In dw_i3c_common_probe, &master->hj_work is bound with dw_i3c_hj_work. And dw_i3c_master_irq_handler can call dw_i3c_master_irq_handle_ibis function to start the work. If we remove the module which will call dw_i3c_common_remove to make cleanup, it will free master->base through i3c_master_unregister while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | dw_i3c_hj_work dw_i3c_common_remove | i3c_master_unregister(&master->base) | device_unregister(&master->dev) | device_release | //free master->base | | i3c_master_do_daa(&master->base) | //use master->base Fix it by ensuring that the work is canceled before proceeding with the cleanup in dw_i3c_common_remove.",
      "id": "CVE-2024-57984",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T17:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "46e5aab3-038f-46eb-9155-d8c2f3c04d0f",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: xfrm: state: fix out-of-bounds read during lookup lookup and resize can run in parallel. The xfrm_state_hash_generation seqlock ensures a retry, but the hash functions can observe a hmask value that is too large for the new hlist array. rehash does: rcu_assign_pointer(net->xfrm.state_bydst, ndst) [..] net->xfrm.state_hmask = nhashmask; While state lookup does: h = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family); hlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) { This is only safe in case the update to state_bydst is larger than net->xfrm.xfrm_state_hmask (or if the lookup function gets serialized via state spinlock again). Fix this by prefetching state_hmask and the associated pointers. The xfrm_state_hash_generation seqlock retry will ensure that the pointer and the hmask will be consistent. The existing helpers, like xfrm_dst_hash(), are now unsafe for RCU side, add lockdep assertions to document that they are only safe for insert side. xfrm_state_lookup_byaddr() uses the spinlock rather than RCU. AFAICS this is an oversight from back when state lookup was converted to RCU, this lock should be replaced with RCU in a future patch.",
      "id": "CVE-2024-57982",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-07T15:09:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:39Z"
      },
      "bom-ref": "31a53800-3ed2-4fc7-9dc7-a55806690fe5",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: usb: xhci: Fix NULL pointer dereference on certain command aborts If a command is queued to the final usable TRB of a ring segment, the enqueue pointer is advanced to the subsequent link TRB and no further. If the command is later aborted, when the abort completion is handled the dequeue pointer is advanced to the first TRB of the next segment. If no further commands are queued, xhci_handle_stopped_cmd_ring() sees the ring pointers unequal and assumes that there is a pending command, so it calls xhci_mod_cmd_timer() which crashes if cur_cmd was NULL. Don't attempt timer setup if cur_cmd is NULL. The subsequent doorbell ring likely is unnecessary too, but it's harmless. Leave it alone. This is probably Bug 219532, but no confirmation has been received. The issue has been independently reproduced and confirmed fixed using a USB MCU programmed to NAK the Status stage of SET_ADDRESS forever. Everything continued working normally after several prevented crashes.",
      "id": "CVE-2024-57981",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "bdb928fc-6af2-4ae7-b68f-10508744f538",
      "cwes": [
        415
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: uvcvideo: Fix double free in error path If the uvc_status_init() function fails to allocate the int_urb, it will free the dev->status pointer but doesn't reset the pointer to NULL. This results in the kfree() call in uvc_status_cleanup() trying to double-free the memory. Fix it by resetting the dev->status pointer to NULL after freeing it. Reviewed by: Ricardo Ribalda <ribalda@chromium.org>",
      "id": "CVE-2024-57980",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:41Z"
      },
      "bom-ref": "fc2dbb17-36e5-4782-8da9-95722bcb3bcb",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: imx-jpeg: Fix potential error pointer dereference in detach_pm() The proble is on the first line: if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i])) If jpeg->pd_dev[i] is an error pointer, then passing it to pm_runtime_suspended() will lead to an Oops. The other conditions check for both error pointers and NULL, but it would be more clear to use the IS_ERR_OR_NULL() check for that.",
      "id": "CVE-2024-57978",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:42Z"
      },
      "bom-ref": "040c84d2-cb1f-48b4-8cab-868e3b7179f6",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: memcg: fix soft lockup in the OOM process A soft lockup issue was found in the product with about 56,000 tasks were in the OOM cgroup, it was traversing them when the soft lockup was triggered. watchdog: BUG: soft lockup - CPU#2 stuck for 23s! [VM Thread:1503066] CPU: 2 PID: 1503066 Comm: VM Thread Kdump: loaded Tainted: G Hardware name: Huawei Cloud OpenStack Nova, BIOS RIP: 0010:console_unlock+0x343/0x540 RSP: 0000:ffffb751447db9a0 EFLAGS: 00000247 ORIG_RAX: ffffffffffffff13 RAX: 0000000000000001 RBX: 0000000000000000 RCX: 00000000ffffffff RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000247 RBP: ffffffffafc71f90 R08: 0000000000000000 R09: 0000000000000040 R10: 0000000000000080 R11: 0000000000000000 R12: ffffffffafc74bd0 R13: ffffffffaf60a220 R14: 0000000000000247 R15: 0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f2fe6ad91f0 CR3: 00000004b2076003 CR4: 0000000000360ee0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: vprintk_emit+0x193/0x280 printk+0x52/0x6e dump_task+0x114/0x130 mem_cgroup_scan_tasks+0x76/0x100 dump_header+0x1fe/0x210 oom_kill_process+0xd1/0x100 out_of_memory+0x125/0x570 mem_cgroup_out_of_memory+0xb5/0xd0 try_charge+0x720/0x770 mem_cgroup_try_charge+0x86/0x180 mem_cgroup_try_charge_delay+0x1c/0x40 do_anonymous_page+0xb5/0x390 handle_mm_fault+0xc4/0x1f0 This is because thousands of processes are in the OOM cgroup, it takes a long time to traverse all of them. As a result, this lead to soft lockup in the OOM process. To fix this issue, call 'cond_resched' in the 'mem_cgroup_scan_tasks' function per 1000 iterations. For global OOM, call 'touch_softlockup_watchdog' per 1000 iterations to avoid this issue.",
      "id": "CVE-2024-57977",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:44Z"
      },
      "bom-ref": "e9a4996b-7a2f-465a-8277-625c03690f81",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: rdma/cxgb4: Prevent potential integer overflow on 32bit The \"gl->tot_len\" variable is controlled by the user. It comes from process_responses(). On 32bit systems, the \"gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header)\" addition could have an integer wrapping bug. Use size_add() to prevent this.",
      "id": "CVE-2024-57973",
      "published": "2025-02-27T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:45Z"
      },
      "bom-ref": "e42f3633-6d40-49e4-8eda-cfcf8af4a3fc",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: tty: xilinx_uartps: split sysrq handling lockdep detects the following circular locking dependency: CPU 0 CPU 1 ========================== ============================ cdns_uart_isr() printk() uart_port_lock(port) console_lock() cdns_uart_console_write() if (!port->sysrq) uart_port_lock(port) uart_handle_break() port->sysrq = ... uart_handle_sysrq_char() printk() console_lock() The fixed commit attempts to avoid this situation by only taking the port lock in cdns_uart_console_write if port->sysrq unset. However, if (as shown above) cdns_uart_console_write runs before port->sysrq is set, then it will try to take the port lock anyway. This may result in a deadlock. Fix this by splitting sysrq handling into two parts. We use the prepare helper under the port lock and defer handling until we release the lock.",
      "id": "CVE-2025-21820",
      "published": "2025-02-27T20:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:47Z"
      },
      "bom-ref": "d7bc4938-9656-481c-9c03-1e7c6ab8bb5a",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ptp: Ensure info->enable callback is always set The ioctl and sysfs handlers unconditionally call the ->enable callback. Not all drivers implement that callback, leading to NULL dereferences. Example of affected drivers: ptp_s390.c, ptp_vclock.c and ptp_mock.c. Instead use a dummy callback if no better was specified by the driver.",
      "id": "CVE-2025-21814",
      "published": "2025-02-27T20:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:48Z"
      },
      "bom-ref": "cbc92305-af0c-49af-8185-525d3a10d71f",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ax25: rcu protect dev->ax25_ptr syzbot found a lockdep issue [1]. We should remove ax25 RTNL dependency in ax25_setsockopt() This should also fix a variety of possible UAF in ax25. [1] WARNING: possible circular locking dependency detected 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not tainted ------------------------------------------------------ syz.5.1818/12806 is trying to acquire lock: ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4}, at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680 but task is already holding lock: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline] ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574 which lock already depends on the new lock. the existing dependency chain (in reverse order) is: -> #1 (sk_lock-AF_AX25){+.+.}-{0:0}: lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 lock_sock_nested+0x48/0x100 net/core/sock.c:3642 lock_sock include/net/sock.h:1618 [inline] ax25_kill_by_device net/ax25/af_ax25.c:101 [inline] ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146 notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85 __dev_notify_flags+0x207/0x400 dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026 dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563 dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820 sock_do_ioctl+0x240/0x460 net/socket.c:1234 sock_ioctl+0x626/0x8e0 net/socket.c:1339 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:906 [inline] __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f -> #0 (rtnl_mutex){+.+.}-{4:4}: check_prev_add kernel/locking/lockdep.c:3161 [inline] check_prevs_add kernel/locking/lockdep.c:3280 [inline] validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904 __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226 lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849 __mutex_lock_common kernel/locking/mutex.c:585 [inline] __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735 ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680 do_sock_setsockopt+0x3af/0x720 net/socket.c:2324 __sys_setsockopt net/socket.c:2349 [inline] __do_sys_setsockopt net/socket.c:2355 [inline] __se_sys_setsockopt net/socket.c:2352 [inline] __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f other info that might help us debug this: Possible unsafe locking scenario: CPU0 CPU1 ---- ---- lock(sk_lock-AF_AX25); lock(rtnl_mutex); lock(sk_lock-AF_AX25); lock(rtnl_mutex); *** DEADLOCK *** 1 lock held by syz.5.1818/12806: #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1618 [inline] #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0}, at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574 stack backtrace: CPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074 check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206 check_prev_add kernel/locking/lockdep.c:3161 [inline] check_prevs_add kernel/lockin ---truncated---",
      "id": "CVE-2025-21812",
      "published": "2025-02-27T20:16:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-21T18:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:50Z"
      },
      "bom-ref": "38d69be6-70f4-4991-963e-752955c987ca",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iommu/vt-d: Avoid use of NULL after WARN_ON_ONCE There is a WARN_ON_ONCE to catch an unlikely situation when domain_remove_dev_pasid can't find the `pasid`. In case it nevertheless happens we must avoid using a NULL pointer.",
      "id": "CVE-2025-21833",
      "published": "2025-03-06T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-25T14:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:51Z"
      },
      "bom-ref": "9ddf160b-60d2-4661-9fe1-4fb4d1a75e90",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: powerpc/code-patching: Fix KASAN hit by not flagging text patching area as VM_ALLOC Erhard reported the following KASAN hit while booting his PowerMac G4 with a KASAN-enabled kernel 6.13-rc6: BUG: KASAN: vmalloc-out-of-bounds in copy_to_kernel_nofault+0xd8/0x1c8 Write of size 8 at addr f1000000 by task chronyd/1293 CPU: 0 UID: 123 PID: 1293 Comm: chronyd Tainted: G W 6.13.0-rc6-PMacG4 #2 Tainted: [W]=WARN Hardware name: PowerMac3,6 7455 0x80010303 PowerMac Call Trace: [c2437590] [c1631a84] dump_stack_lvl+0x70/0x8c (unreliable) [c24375b0] [c0504998] print_report+0xdc/0x504 [c2437610] [c050475c] kasan_report+0xf8/0x108 [c2437690] [c0505a3c] kasan_check_range+0x24/0x18c [c24376a0] [c03fb5e4] copy_to_kernel_nofault+0xd8/0x1c8 [c24376c0] [c004c014] patch_instructions+0x15c/0x16c [c2437710] [c00731a8] bpf_arch_text_copy+0x60/0x7c [c2437730] [c0281168] bpf_jit_binary_pack_finalize+0x50/0xac [c2437750] [c0073cf4] bpf_int_jit_compile+0xb30/0xdec [c2437880] [c0280394] bpf_prog_select_runtime+0x15c/0x478 [c24378d0] [c1263428] bpf_prepare_filter+0xbf8/0xc14 [c2437990] [c12677ec] bpf_prog_create_from_user+0x258/0x2b4 [c24379d0] [c027111c] do_seccomp+0x3dc/0x1890 [c2437ac0] [c001d8e0] system_call_exception+0x2dc/0x420 [c2437f30] [c00281ac] ret_from_syscall+0x0/0x2c --- interrupt: c00 at 0x5a1274 NIP: 005a1274 LR: 006a3b3c CTR: 005296c8 REGS: c2437f40 TRAP: 0c00 Tainted: G W (6.13.0-rc6-PMacG4) MSR: 0200f932 <VEC,EE,PR,FP,ME,IR,DR,RI> CR: 24004422 XER: 00000000 GPR00: 00000166 af8f3fa0 a7ee3540 00000001 00000000 013b6500 005a5858 0200f932 GPR08: 00000000 00001fe9 013d5fc8 005296c8 2822244c 00b2fcd8 00000000 af8f4b57 GPR16: 00000000 00000001 00000000 00000000 00000000 00000001 00000000 00000002 GPR24: 00afdbb0 00000000 00000000 00000000 006e0004 013ce060 006e7c1c 00000001 NIP [005a1274] 0x5a1274 LR [006a3b3c] 0x6a3b3c --- interrupt: c00 The buggy address belongs to the virtual mapping at [f1000000, f1002000) created by: text_area_cpu_up+0x20/0x190 The buggy address belongs to the physical page: page: refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x76e30 flags: 0x80000000(zone=2) raw: 80000000 00000000 00000122 00000000 00000000 00000000 ffffffff 00000001 raw: 00000000 page dumped because: kasan: bad access detected Memory state around the buggy address: f0ffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0ffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 >f1000000: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ^ f1000080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f1000100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 ================================================================== f8 corresponds to KASAN_VMALLOC_INVALID which means the area is not initialised hence not supposed to be used yet. Powerpc text patching infrastructure allocates a virtual memory area using get_vm_area() and flags it as VM_ALLOC. But that flag is meant to be used for vmalloc() and vmalloc() allocated memory is not supposed to be used before a call to __vmalloc_node_range() which is never called for that area. That went undetected until commit e4137f08816b (\"mm, kasan, kmsan: instrument copy_from/to_kernel_nofault\") The area allocated by text_area_cpu_up() is not vmalloc memory, it is mapped directly on demand when needed by map_kernel_page(). There is no VM flag corresponding to such usage, so just pass no flag. That way the area will be unpoisonned and usable immediately.",
      "id": "CVE-2025-21866",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "a2a469d5-946f-428b-b367-2831465e6236",
      "description": "In the Linux kernel, the following vulnerability has been resolved: io_uring: prevent opcode speculation sqe->opcode is used for different tables, make sure we santitise it against speculations.",
      "id": "CVE-2025-21863",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:53Z"
      },
      "bom-ref": "8102a1f8-4232-4d98-8d7d-fd16277be840",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drop_monitor: fix incorrect initialization order Syzkaller reports the following bug: BUG: spinlock bad magic on CPU#1, syz-executor.0/7995 lock: 0xffff88805303f3e0, .magic: 00000000, .owner: <none>/-1, .owner_cpu: 0 CPU: 1 PID: 7995 Comm: syz-executor.0 Tainted: G E 5.10.209+ #1 Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020 Call Trace: __dump_stack lib/dump_stack.c:77 [inline] dump_stack+0x119/0x179 lib/dump_stack.c:118 debug_spin_lock_before kernel/locking/spinlock_debug.c:83 [inline] do_raw_spin_lock+0x1f6/0x270 kernel/locking/spinlock_debug.c:112 __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:117 [inline] _raw_spin_lock_irqsave+0x50/0x70 kernel/locking/spinlock.c:159 reset_per_cpu_data+0xe6/0x240 [drop_monitor] net_dm_cmd_trace+0x43d/0x17a0 [drop_monitor] genl_family_rcv_msg_doit+0x22f/0x330 net/netlink/genetlink.c:739 genl_family_rcv_msg net/netlink/genetlink.c:783 [inline] genl_rcv_msg+0x341/0x5a0 net/netlink/genetlink.c:800 netlink_rcv_skb+0x14d/0x440 net/netlink/af_netlink.c:2497 genl_rcv+0x29/0x40 net/netlink/genetlink.c:811 netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline] netlink_unicast+0x54b/0x800 net/netlink/af_netlink.c:1348 netlink_sendmsg+0x914/0xe00 net/netlink/af_netlink.c:1916 sock_sendmsg_nosec net/socket.c:651 [inline] __sock_sendmsg+0x157/0x190 net/socket.c:663 ____sys_sendmsg+0x712/0x870 net/socket.c:2378 ___sys_sendmsg+0xf8/0x170 net/socket.c:2432 __sys_sendmsg+0xea/0x1b0 net/socket.c:2461 do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x62/0xc7 RIP: 0033:0x7f3f9815aee9 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f3f972bf0c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f3f9826d050 RCX: 00007f3f9815aee9 RDX: 0000000020000000 RSI: 0000000020001300 RDI: 0000000000000007 RBP: 00007f3f981b63bd R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 000000000000006e R14: 00007f3f9826d050 R15: 00007ffe01ee6768 If drop_monitor is built as a kernel module, syzkaller may have time to send a netlink NET_DM_CMD_START message during the module loading. This will call the net_dm_monitor_start() function that uses a spinlock that has not yet been initialized. To fix this, let's place resource initialization above the registration of a generic netlink family. Found by InfoTeCS on behalf of Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "id": "CVE-2025-21862",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:54Z"
      },
      "bom-ref": "ea50dd3f-2ee5-48bc-84d0-0c1f48b038db",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm/migrate_device: don't add folio to be freed to LRU in migrate_device_finalize() If migration succeeded, we called folio_migrate_flags()->mem_cgroup_migrate() to migrate the memcg from the old to the new folio. This will set memcg_data of the old folio to 0. Similarly, if migration failed, memcg_data of the dst folio is left unset. If we call folio_putback_lru() on such folios (memcg_data == 0), we will add the folio to be freed to the LRU, making memcg code unhappy. Running the hmm selftests: # ./hmm-tests ... # RUN hmm.hmm_device_private.migrate ... [ 102.078007][T14893] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x7ff27d200 pfn:0x13cc00 [ 102.079974][T14893] anon flags: 0x17ff00000020018(uptodate|dirty|swapbacked|node=0|zone=2|lastcpupid=0x7ff) [ 102.082037][T14893] raw: 017ff00000020018 dead000000000100 dead000000000122 ffff8881353896c9 [ 102.083687][T14893] raw: 00000007ff27d200 0000000000000000 00000001ffffffff 0000000000000000 [ 102.085331][T14893] page dumped because: VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled()) [ 102.087230][T14893] ------------[ cut here ]------------ [ 102.088279][T14893] WARNING: CPU: 0 PID: 14893 at ./include/linux/memcontrol.h:726 folio_lruvec_lock_irqsave+0x10e/0x170 [ 102.090478][T14893] Modules linked in: [ 102.091244][T14893] CPU: 0 UID: 0 PID: 14893 Comm: hmm-tests Not tainted 6.13.0-09623-g6c216bc522fd #151 [ 102.093089][T14893] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014 [ 102.094848][T14893] RIP: 0010:folio_lruvec_lock_irqsave+0x10e/0x170 [ 102.096104][T14893] Code: ... [ 102.099908][T14893] RSP: 0018:ffffc900236c37b0 EFLAGS: 00010293 [ 102.101152][T14893] RAX: 0000000000000000 RBX: ffffea0004f30000 RCX: ffffffff8183f426 [ 102.102684][T14893] RDX: ffff8881063cb880 RSI: ffffffff81b8117f RDI: ffff8881063cb880 [ 102.104227][T14893] RBP: 0000000000000000 R08: 0000000000000005 R09: 0000000000000000 [ 102.105757][T14893] R10: 0000000000000001 R11: 0000000000000002 R12: ffffc900236c37d8 [ 102.107296][T14893] R13: ffff888277a2bcb0 R14: 000000000000001f R15: 0000000000000000 [ 102.108830][T14893] FS: 00007ff27dbdd740(0000) GS:ffff888277a00000(0000) knlGS:0000000000000000 [ 102.110643][T14893] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [ 102.111924][T14893] CR2: 00007ff27d400000 CR3: 000000010866e000 CR4: 0000000000750ef0 [ 102.113478][T14893] PKRU: 55555554 [ 102.114172][T14893] Call Trace: [ 102.114805][T14893] <TASK> [ 102.115397][T14893] ? folio_lruvec_lock_irqsave+0x10e/0x170 [ 102.116547][T14893] ? __warn.cold+0x110/0x210 [ 102.117461][T14893] ? folio_lruvec_lock_irqsave+0x10e/0x170 [ 102.118667][T14893] ? report_bug+0x1b9/0x320 [ 102.119571][T14893] ? handle_bug+0x54/0x90 [ 102.120494][T14893] ? exc_invalid_op+0x17/0x50 [ 102.121433][T14893] ? asm_exc_invalid_op+0x1a/0x20 [ 102.122435][T14893] ? __wake_up_klogd.part.0+0x76/0xd0 [ 102.123506][T14893] ? dump_page+0x4f/0x60 [ 102.124352][T14893] ? folio_lruvec_lock_irqsave+0x10e/0x170 [ 102.125500][T14893] folio_batch_move_lru+0xd4/0x200 [ 102.126577][T14893] ? __pfx_lru_add+0x10/0x10 [ 102.127505][T14893] __folio_batch_add_and_move+0x391/0x720 [ 102.128633][T14893] ? __pfx_lru_add+0x10/0x10 [ 102.129550][T14893] folio_putback_lru+0x16/0x80 [ 102.130564][T14893] migrate_device_finalize+0x9b/0x530 [ 102.131640][T14893] dmirror_migrate_to_device.constprop.0+0x7c5/0xad0 [ 102.133047][T14893] dmirror_fops_unlocked_ioctl+0x89b/0xc80 Likely, nothing else goes wrong: putting the last folio reference will remove the folio from the LRU again. So besides memcg complaining, adding the folio to be freed to the LRU is just an unnecessary step. The new flow resembles what we have in migrate_folio_move(): add the dst to the lru, rem ---truncated---",
      "id": "CVE-2025-21861",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:56Z"
      },
      "bom-ref": "2cc0cf75-e932-4f5a-a8c1-4763a866d3c0",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: USB: gadget: f_midi: f_midi_complete to call queue_work When using USB MIDI, a lock is attempted to be acquired twice through a re-entrant call to f_midi_transmit, causing a deadlock. Fix it by using queue_work() to schedule the inner f_midi_transmit() via a high priority work queue from the completion handler.",
      "id": "CVE-2025-21859",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "9159b10a-b861-4113-8b92-b6d11e547abf",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: geneve: Fix use-after-free in geneve_find_dev(). syzkaller reported a use-after-free in geneve_find_dev() [0] without repro. geneve_configure() links struct geneve_dev.next to net_generic(net, geneve_net_id)->geneve_list. The net here could differ from dev_net(dev) if IFLA_NET_NS_PID, IFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set. When dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally calls unregister_netdevice_queue() for each dev in the netns, and later the dev is freed. However, its geneve_dev.next is still linked to the backend UDP socket netns. Then, use-after-free will occur when another geneve dev is created in the netns. Let's call geneve_dellink() instead in geneve_destroy_tunnels(). [0]: BUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline] BUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343 Read of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441 CPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d Hardware name: linux,dummy-virt (DT) Call trace: show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C) __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x16c/0x6f0 mm/kasan/report.c:489 kasan_report+0xc0/0x120 mm/kasan/report.c:602 __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379 geneve_find_dev drivers/net/geneve.c:1295 [inline] geneve_configure+0x234/0x858 drivers/net/geneve.c:1343 geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634 rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795 __rtnl_newlink net/core/rtnetlink.c:3906 [inline] rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938 netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline] netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348 netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892 sock_sendmsg_nosec net/socket.c:713 [inline] __sock_sendmsg net/socket.c:728 [inline] ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568 ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622 __sys_sendmsg net/socket.c:2654 [inline] __do_sys_sendmsg net/socket.c:2659 [inline] __se_sys_sendmsg net/socket.c:2657 [inline] __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657 __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline] invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49 el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132 do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151 el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744 el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762 el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600 Allocated by task 13247: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x30/0x68 mm/kasan/common.c:68 kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4298 [inline] __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304 __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645 alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470 rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604 rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780 __rtnl_newlink net/core/rtnetlink.c:3906 [inline] rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021 rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911 netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543 rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938 netlink_unicast_kernel net/netlink/af_n ---truncated---",
      "id": "CVE-2025-21858",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "c9b7cee1-9a01-46dd-9c2e-f5d6c466a1b6",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ibmvnic: Don't reference skb after sending to VIOS Previously, after successfully flushing the xmit buffer to VIOS, the tx_bytes stat was incremented by the length of the skb. It is invalid to access the skb memory after sending the buffer to the VIOS because, at any point after sending, the VIOS can trigger an interrupt to free this memory. A race between reading skb->len and freeing the skb is possible (especially during LPM) and will result in use-after-free: ================================================================== BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic] Read of size 4 at addr c00000024eb48a70 by task hxecom/14495 <...> Call Trace: [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable) [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0 [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8 [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0 [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic] [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358 <...> Freed by task 0: kasan_save_stack+0x34/0x68 kasan_save_track+0x2c/0x50 kasan_save_free_info+0x64/0x108 __kasan_mempool_poison_object+0x148/0x2d4 napi_skb_cache_put+0x5c/0x194 net_tx_action+0x154/0x5b8 handle_softirqs+0x20c/0x60c do_softirq_own_stack+0x6c/0x88 <...> The buggy address belongs to the object at c00000024eb48a00 which belongs to the cache skbuff_head_cache of size 224 ==================================================================",
      "id": "CVE-2025-21855",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-28T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:57Z"
      },
      "bom-ref": "6ee6cabf-6754-4ad0-8f5a-e8a908029fdb",
      "description": "In the Linux kernel, the following vulnerability has been resolved: bpf: avoid holding freeze_mutex during mmap operation We use map->freeze_mutex to prevent races between map_freeze() and memory mapping BPF map contents with writable permissions. The way we naively do this means we'll hold freeze_mutex for entire duration of all the mm and VMA manipulations, which is completely unnecessary. This can potentially also lead to deadlocks, as reported by syzbot in [0]. So, instead, hold freeze_mutex only during writeability checks, bump (proactively) \"write active\" count for the map, unlock the mutex and proceed with mmap logic. And only if something went wrong during mmap logic, then undo that \"write active\" counter increment. [0] https://lore.kernel.org/bpf/678dcbc9.050a0220.303755.0066.GAE@google.com/",
      "id": "CVE-2025-21853",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:58:59Z"
      },
      "bom-ref": "358c106a-f917-407a-8298-cc266ecb24c6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nfp: bpf: Add check for nfp_app_ctrl_msg_alloc() Add check for the return value of nfp_app_ctrl_msg_alloc() in nfp_bpf_cmsg_alloc() to prevent null pointer dereference.",
      "id": "CVE-2025-21848",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T16:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:00Z"
      },
      "bom-ref": "05e9f8fd-f395-472c-8651-1ab11efa19c6",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: acct: perform last write from workqueue In [1] it was reported that the acct(2) system call can be used to trigger NULL deref in cases where it is set to write to a file that triggers an internal lookup. This can e.g., happen when pointing acc(2) to /sys/power/resume. At the point the where the write to this file happens the calling task has already exited and called exit_fs(). A lookup will thus trigger a NULL-deref when accessing current->fs. Reorganize the code so that the the final write happens from the workqueue but with the caller's credentials. This preserves the (strange) permission model and has almost no regression risk. This api should stop to exist though.",
      "id": "CVE-2025-21846",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T16:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:02Z"
      },
      "bom-ref": "8a85f93e-72ca-4cb9-9d3b-2d9a578301d2",
      "cwes": [
        770
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: btrfs: fix double accounting race when btrfs_run_delalloc_range() failed [BUG] When running btrfs with block size (4K) smaller than page size (64K, aarch64), there is a very high chance to crash the kernel at generic/750, with the following messages: (before the call traces, there are 3 extra debug messages added) BTRFS warning (device dm-3): read-write for sector size 4096 with page size 65536 is experimental BTRFS info (device dm-3): checking UUID tree hrtimer: interrupt took 5451385 ns BTRFS error (device dm-3): cow_file_range failed, root=4957 inode=257 start=1605632 len=69632: -28 BTRFS error (device dm-3): run_delalloc_nocow failed, root=4957 inode=257 start=1605632 len=69632: -28 BTRFS error (device dm-3): failed to run delalloc range, root=4957 ino=257 folio=1572864 submit_bitmap=8-15 start=1605632 len=69632: -28 ------------[ cut here ]------------ WARNING: CPU: 2 PID: 3020984 at ordered-data.c:360 can_finish_ordered_extent+0x370/0x3b8 [btrfs] CPU: 2 UID: 0 PID: 3020984 Comm: kworker/u24:1 Tainted: G OE 6.13.0-rc1-custom+ #89 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022 Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs] pc : can_finish_ordered_extent+0x370/0x3b8 [btrfs] lr : can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] Call trace: can_finish_ordered_extent+0x370/0x3b8 [btrfs] (P) can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] (L) btrfs_mark_ordered_io_finished+0x130/0x2b8 [btrfs] extent_writepage+0x10c/0x3b8 [btrfs] extent_write_cache_pages+0x21c/0x4e8 [btrfs] btrfs_writepages+0x94/0x160 [btrfs] do_writepages+0x74/0x190 filemap_fdatawrite_wbc+0x74/0xa0 start_delalloc_inodes+0x17c/0x3b0 [btrfs] btrfs_start_delalloc_roots+0x17c/0x288 [btrfs] shrink_delalloc+0x11c/0x280 [btrfs] flush_space+0x288/0x328 [btrfs] btrfs_async_reclaim_data_space+0x180/0x228 [btrfs] process_one_work+0x228/0x680 worker_thread+0x1bc/0x360 kthread+0x100/0x118 ret_from_fork+0x10/0x20 ---[ end trace 0000000000000000 ]--- BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1605632 OE len=16384 to_dec=16384 left=0 BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1622016 OE len=12288 to_dec=12288 left=0 Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008 BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1634304 OE len=8192 to_dec=4096 left=0 CPU: 1 UID: 0 PID: 3286940 Comm: kworker/u24:3 Tainted: G W OE 6.13.0-rc1-custom+ #89 Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022 Workqueue: btrfs_work_helper [btrfs] (btrfs-endio-write) pstate: 404000c5 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--) pc : process_one_work+0x110/0x680 lr : worker_thread+0x1bc/0x360 Call trace: process_one_work+0x110/0x680 (P) worker_thread+0x1bc/0x360 (L) worker_thread+0x1bc/0x360 kthread+0x100/0x118 ret_from_fork+0x10/0x20 Code: f84086a1 f9000fe1 53041c21 b9003361 (f9400661) ---[ end trace 0000000000000000 ]--- Kernel panic - not syncing: Oops: Fatal exception SMP: stopping secondary CPUs SMP: failed to stop secondary CPUs 2-3 Dumping ftrace buffer: (ftrace buffer empty) Kernel Offset: 0x275bb9540000 from 0xffff800080000000 PHYS_OFFSET: 0xffff8fbba0000000 CPU features: 0x100,00000070,00801250,8201720b [CAUSE] The above warning is triggered immediately after the delalloc range failure, this happens in the following sequence: - Range [1568K, 1636K) is dirty 1536K 1568K 1600K 1636K 1664K | |/////////|////////| | Where 1536K, 1600K and 1664K are page boundaries (64K page size) - Enter extent_writepage() for page 1536K - Enter run_delalloc_nocow() with locke ---truncated---",
      "id": "CVE-2024-58089",
      "published": "2025-03-12T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-13T16:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:03Z"
      },
      "bom-ref": "ac51beb4-1af1-442e-9f59-5a8d9a043ecc",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cifs: fix potential memory leaks in session setup Make sure to free cifs_ses::auth_key.response before allocating it as we might end up leaking memory in reconnect or mounting.",
      "id": "CVE-2023-53008",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:05Z"
      },
      "bom-ref": "413def19-9d68-493d-8321-8ef7f1cc27c8",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/i915: Fix a memory leak with reused mmap_offset drm_vma_node_allow() and drm_vma_node_revoke() should be called in balanced pairs. We call drm_vma_node_allow() once per-file everytime a user calls mmap_offset, but only call drm_vma_node_revoke once per-file on each mmap_offset. As the mmap_offset is reused by the client, the per-file vm_count may remain non-zero and the rbtree leaked. Call drm_vma_node_allow_once() instead to prevent that memory leak.",
      "id": "CVE-2023-53002",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:06Z"
      },
      "bom-ref": "42a3efff-ef41-43f0-819a-339931972016",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: drm/drm_vma_manager: Add drm_vma_node_allow_once() Currently there is no easy way for a drm driver to safely check and allow drm_vma_offset_node for a drm file just once. Allow drm drivers to call non-refcounted version of drm_vma_node_allow() so that a driver doesn't need to keep track of each drm_vma_node_allow() to call subsequent drm_vma_node_revoke() to prevent memory leak.",
      "id": "CVE-2023-53001",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-15T14:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:08Z"
      },
      "bom-ref": "b3caef40-bfb4-4510-9c79-ed6d70d68bc7",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: squashfs: harden sanity check in squashfs_read_xattr_id_table While mounting a corrupted filesystem, a signed integer '*xattr_ids' can become less than zero. This leads to the incorrect computation of 'len' and 'indexes' values which can cause null-ptr-deref in copy_bio_to_actor() or out-of-bounds accesses in the next sanity checks inside squashfs_read_xattr_id_table(). Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "id": "CVE-2023-52979",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:59:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:09Z"
      },
      "bom-ref": "572919c2-48be-4c7e-8953-829f95e0aa3c",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm: memcg: fix NULL pointer in mem_cgroup_track_foreign_dirty_slowpath() As commit 18365225f044 (\"hwpoison, memcg: forcibly uncharge LRU pages\"), hwpoison will forcibly uncharg a LRU hwpoisoned page, the folio_memcg could be NULl, then, mem_cgroup_track_foreign_dirty_slowpath() could occurs a NULL pointer dereference, let's do not record the foreign writebacks for folio memcg is null in mem_cgroup_track_foreign_dirty() to fix it.",
      "id": "CVE-2023-52939",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-15T14:46:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:11Z"
      },
      "bom-ref": "8b652ea7-79db-44d3-9a62-cfaa24f6a091",
      "description": "In the Linux kernel, the following vulnerability has been resolved: mm/khugepaged: fix ->anon_vma race If an ->anon_vma is attached to the VMA, collapse_and_free_pmd() requires it to be locked. Page table traversal is allowed under any one of the mmap lock, the anon_vma lock (if the VMA is associated with an anon_vma), and the mapping lock (if the VMA is associated with a mapping); and so to be able to remove page tables, we must hold all three of them. retract_page_tables() bails out if an ->anon_vma is attached, but does this check before holding the mmap lock (as the comment above the check explains). If we racily merged an existing ->anon_vma (shared with a child process) from a neighboring VMA, subsequent rmap traversals on pages belonging to the child will be able to see the page tables that we are concurrently removing while assuming that nothing else can access them. Repeat the ->anon_vma check once we hold the mmap lock to ensure that there really is no concurrent page table access. Hitting this bug causes a lockdep warning in collapse_and_free_pmd(), in the line \"lockdep_assert_held_write(&vma->anon_vma->root->rwsem)\". It can also lead to use-after-free access.",
      "id": "CVE-2023-52935",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-01T15:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:12Z"
      },
      "bom-ref": "41f819a5-c040-4665-9c1f-6ff15ec657fc",
      "cwes": [
        190
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cpufreq: CPPC: Add u64 casts to avoid overflowing The fields of the _CPC object are unsigned 32-bits values. To avoid overflows while using _CPC's values, add 'u64' casts.",
      "id": "CVE-2022-49750",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:14Z"
      },
      "bom-ref": "260aad71-cd78-4ede-a88c-ade1caff43c7",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: f2fs: initialize locks earlier in f2fs_fill_super() syzbot is reporting lockdep warning at f2fs_handle_error() [1], for spin_lock(&sbi->error_lock) is called before spin_lock_init() is called. For safe locking in error handling, move initialization of locks (and obvious structures) in f2fs_fill_super() to immediately after memory allocation.",
      "id": "CVE-2022-49742",
      "published": "2025-03-27T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:27:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:15Z"
      },
      "bom-ref": "29b7e970-2898-4bb8-a3ab-75c3a6a62115",
      "cwes": [
        908
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ipvlan: ensure network headers are in skb linear part syzbot found that ipvlan_process_v6_outbound() was assuming the IPv6 network header isis present in skb->head [1] Add the needed pskb_network_may_pull() calls for both IPv4 and IPv6 handlers. [1] BUG: KMSAN: uninit-value in __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47 __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47 ipv6_addr_type include/net/ipv6.h:555 [inline] ip6_route_output_flags_noref net/ipv6/route.c:2616 [inline] ip6_route_output_flags+0x51/0x720 net/ipv6/route.c:2651 ip6_route_output include/net/ip6_route.h:93 [inline] ipvlan_route_v6_outbound+0x24e/0x520 drivers/net/ipvlan/ipvlan_core.c:476 ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:491 [inline] ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:541 [inline] ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:605 [inline] ipvlan_queue_xmit+0xd72/0x1780 drivers/net/ipvlan/ipvlan_core.c:671 ipvlan_start_xmit+0x5b/0x210 drivers/net/ipvlan/ipvlan_main.c:223 __netdev_start_xmit include/linux/netdevice.h:5150 [inline] netdev_start_xmit include/linux/netdevice.h:5159 [inline] xmit_one net/core/dev.c:3735 [inline] dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3751 sch_direct_xmit+0x399/0xd40 net/sched/sch_generic.c:343 qdisc_restart net/sched/sch_generic.c:408 [inline] __qdisc_run+0x14da/0x35d0 net/sched/sch_generic.c:416 qdisc_run+0x141/0x4d0 include/net/pkt_sched.h:127 net_tx_action+0x78b/0x940 net/core/dev.c:5484 handle_softirqs+0x1a0/0x7c0 kernel/softirq.c:561 __do_softirq+0x14/0x1a kernel/softirq.c:595 do_softirq+0x9a/0x100 kernel/softirq.c:462 __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:389 local_bh_enable include/linux/bottom_half.h:33 [inline] rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline] __dev_queue_xmit+0x2758/0x57d0 net/core/dev.c:4611 dev_queue_xmit include/linux/netdevice.h:3311 [inline] packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276 packet_snd net/packet/af_packet.c:3132 [inline] packet_sendmsg+0x93e0/0xa7e0 net/packet/af_packet.c:3164 sock_sendmsg_nosec net/socket.c:718 [inline]",
      "id": "CVE-2025-21891",
      "published": "2025-03-27T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:17Z"
      },
      "bom-ref": "ebe94500-7f76-462e-a601-62ec1286153c",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ice: fix memory leak in aRFS after reset Fix aRFS (accelerated Receive Flow Steering) structures memory leak by adding a checker to verify if aRFS memory is already allocated while configuring VSI. aRFS objects are allocated in two cases: - as part of VSI initialization (at probe), and - as part of reset handling However, VSI reconfiguration executed during reset involves memory allocation one more time, without prior releasing already allocated resources. This led to the memory leak with the following signature: [root@os-delivery ~]# cat /sys/kernel/debug/kmemleak unreferenced object 0xff3c1ca7252e6000 (size 8192): comm \"kworker/0:0\", pid 8, jiffies 4296833052 hex dump (first 32 bytes): 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ backtrace (crc 0): [<ffffffff991ec485>] __kmalloc_cache_noprof+0x275/0x340 [<ffffffffc0a6e06a>] ice_init_arfs+0x3a/0xe0 [ice] [<ffffffffc09f1027>] ice_vsi_cfg_def+0x607/0x850 [ice] [<ffffffffc09f244b>] ice_vsi_setup+0x5b/0x130 [ice] [<ffffffffc09c2131>] ice_init+0x1c1/0x460 [ice] [<ffffffffc09c64af>] ice_probe+0x2af/0x520 [ice] [<ffffffff994fbcd3>] local_pci_probe+0x43/0xa0 [<ffffffff98f07103>] work_for_cpu_fn+0x13/0x20 [<ffffffff98f0b6d9>] process_one_work+0x179/0x390 [<ffffffff98f0c1e9>] worker_thread+0x239/0x340 [<ffffffff98f14abc>] kthread+0xcc/0x100 [<ffffffff98e45a6d>] ret_from_fork+0x2d/0x50 [<ffffffff98e083ba>] ret_from_fork_asm+0x1a/0x30 ...",
      "id": "CVE-2025-21981",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "990d57cc-2303-4754-b78b-6cc4ad16f944",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmd After the hci sync command releases l2cap_conn, the hci receive data work queue references the released l2cap_conn when sending to the upper layer. Add hci dev lock to the hci receive data work queue to synchronize the two. [1] BUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954 Read of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837 CPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: hci1 hci_rx_work Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:378 [inline] print_report+0x169/0x550 mm/kasan/report.c:489 kasan_report+0x143/0x180 mm/kasan/report.c:602 l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline] l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954 l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline] l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline] l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817 hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline] hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK> Allocated by task 5837: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329 kmalloc_noprof include/linux/slab.h:901 [inline] kzalloc_noprof include/linux/slab.h:1037 [inline] l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860 l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline] hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726 hci_event_func net/bluetooth/hci_event.c:7473 [inline] hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525 hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 Freed by task 54: kasan_save_stack mm/kasan/common.c:47 [inline] kasan_save_track+0x3f/0x80 mm/kasan/common.c:68 kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2353 [inline] slab_free mm/slub.c:4613 [inline] kfree+0x196/0x430 mm/slub.c:4761 l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235 hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline] hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266 hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603 hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332 process_one_work kernel/workqueue.c:3229 [inline] process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310 worker_thread+0x870/0xd30 kernel/workqueue.c:3391 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entr ---truncated---",
      "id": "CVE-2025-21969",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T12:36:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "f1d058ff-050c-4f8c-9509-e51bdbcf28df",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in ksmbd_free_work_struct ->interim_entry of ksmbd_work could be deleted after oplock is freed. We don't need to manage it with linked list. The interim request could be immediately sent whenever a oplock break wait is needed.",
      "id": "CVE-2025-21967",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-16T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:18Z"
      },
      "bom-ref": "678c6406-26aa-476a-8ed8-ac1ba91235ec",
      "cwes": [
        362
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix type confusion via race condition when using ipc_msg_send_request req->handle is allocated using ksmbd_acquire_id(&ipc_ida), based on ida_alloc. req->handle from ksmbd_ipc_login_request and FSCTL_PIPE_TRANSCEIVE ioctl can be same and it could lead to type confusion between messages, resulting in access to unexpected parts of memory after an incorrect delivery. ksmbd check type of ipc response but missing add continue to check next ipc reponse.",
      "id": "CVE-2025-21947",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T18:05:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "fb61aeff-88b7-4430-ab88-0c1eb8c246e5",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in smb2_lock If smb_lock->zero_len has value, ->llist of smb_lock is not delete and flock is old one. It will cause use-after-free on error handling routine.",
      "id": "CVE-2025-21945",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-16T14:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "264e4b61-e488-4a13-aee0-60fe859695d5",
      "cwes": [
        787
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: nvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu() nvme_tcp_recv_pdu() doesn't check the validity of the header length. When header digests are enabled, a target might send a packet with an invalid header length (e.g. 255), causing nvme_tcp_verify_hdgst() to access memory outside the allocated area and cause memory corruptions by overwriting it with the calculated digest. Fix this by rejecting packets with an unexpected header length.",
      "id": "CVE-2025-21927",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-11T13:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "1ee1eb14-2876-4540-8443-5a78e0d1ff01",
      "cwes": [
        416
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: cdx: Fix possible UAF error in driver_override_show() Fixed a possible UAF problem in driver_override_show() in drivers/cdx/cdx.c This function driver_override_show() is part of DEVICE_ATTR_RW, which includes both driver_override_show() and driver_override_store(). These functions can be executed concurrently in sysfs. The driver_override_store() function uses driver_set_override() to update the driver_override value, and driver_set_override() internally locks the device (device_lock(dev)). If driver_override_show() reads cdx_dev->driver_override without locking, it could potentially access a freed pointer if driver_override_store() frees the string concurrently. This could lead to printing a kernel address, which is a security risk since DEVICE_ATTR can be read by all users. Additionally, a similar pattern is used in drivers/amba/bus.c, as well as many other bus drivers, where device_lock() is taken in the show function, and it has been working without issues. This potential bug was detected by our experimental static analysis tool, which analyzes locking APIs and paired functions to identify data races and atomicity violations.",
      "id": "CVE-2025-21915",
      "published": "2025-04-01T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-21T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "We do not use iscsi boot over ipv6",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "4c418638-3dc1-412e-8862-1e3fcfb06e2b",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: iscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic() When performing an iSCSI boot using IPv6, iscsistart still reads the /sys/firmware/ibft/ethernetX/subnet-mask entry. Since the IPv6 prefix length is 64, this causes the shift exponent to become negative, triggering a UBSAN warning. As the concept of a subnet mask does not apply to IPv6, the value is set to ~0 to suppress the warning message.",
      "id": "CVE-2025-21993",
      "published": "2025-04-02T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "we are not using AMD CPU's",
        "justification": "code_not_present",
        "state": "not_affected"
      },
      "bom-ref": "4f6bce8e-954b-4f43-ba41-9498f02dedbd",
      "cwes": [
        129
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: x86/microcode/AMD: Fix out-of-bounds on systems with CPU-less NUMA nodes Currently, load_microcode_amd() iterates over all NUMA nodes, retrieves their CPU masks and unconditionally accesses per-CPU data for the first CPU of each mask. According to Documentation/admin-guide/mm/numaperf.rst: \"Some memory may share the same node as a CPU, and others are provided as memory only nodes.\" Therefore, some node CPU masks may be empty and wouldn't have a \"first CPU\". On a machine with far memory (and therefore CPU-less NUMA nodes): - cpumask_of_node(nid) is 0 - cpumask_first(0) is CONFIG_NR_CPUS - cpu_data(CONFIG_NR_CPUS) accesses the cpu_info per-CPU array at an index that is 1 out of bounds This does not have any security implications since flashing microcode is a privileged operation but I believe this has reliability implications by potentially corrupting memory while flashing a microcode update. When booting with CONFIG_UBSAN_BOUNDS=y on an AMD machine that flashes a microcode update. I get the following splat: UBSAN: array-index-out-of-bounds in arch/x86/kernel/cpu/microcode/amd.c:X:Y index 512 is out of range for type 'unsigned long[512]' [...] Call Trace: dump_stack __ubsan_handle_out_of_bounds load_microcode_amd request_microcode_amd reload_store kernfs_fop_write_iter vfs_write ksys_write do_syscall_64 entry_SYSCALL_64_after_hwframe Change the loop to go over only NUMA nodes which have CPUs before determining whether the first CPU on the respective node needs microcode update. [ bp: Massage commit message, fix typo. ]",
      "id": "CVE-2025-21991",
      "published": "2025-04-02T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:20Z"
      },
      "bom-ref": "39e5fb29-5013-4e3b-8538-25200eee5700",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix error code in chan_alloc_skb_cb() The chan_alloc_skb_cb() function is supposed to return error pointers on error. Returning NULL will lead to a NULL dereference.",
      "id": "CVE-2025-22007",
      "published": "2025-04-03T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:21Z"
      },
      "bom-ref": "770dea0c-0b7e-494f-9c0d-ba39a0c76825",
      "description": "In the Linux kernel, the following vulnerability has been resolved: net: atm: fix use after free in lec_send() The ->send() operation frees skb so save the length before calling ->send() to avoid a use after free.",
      "id": "CVE-2025-22004",
      "published": "2025-04-03T08:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:23Z"
      },
      "bom-ref": "7f811ec8-aaf0-4825-8f5a-a69bb88dc6ad",
      "description": "In the Linux kernel, the following vulnerability has been resolved: proc: fix UAF in proc_get_inode() Fix race between rmmod and /proc/XXX's inode instantiation. The bug is that pde->proc_ops don't belong to /proc, it belongs to a module, therefore dereferencing it after /proc entry has been registered is a bug unless use_pde/unuse_pde() pair has been used. use_pde/unuse_pde can be avoided (2 atomic ops!) because pde->proc_ops never changes so information necessary for inode instantiation can be saved _before_ proc_register() in PDE itself and used later, avoiding pde->proc_ops->... dereference. rmmod lookup sys_delete_module proc_lookup_de pde_get(de); proc_get_inode(dir->i_sb, de); mod->exit() proc_remove remove_proc_subtree proc_entry_rundown(de); free_module(mod); if (S_ISREG(inode->i_mode)) if (de->proc_ops->proc_read_iter) --> As module is already freed, will trigger UAF BUG: unable to handle page fault for address: fffffbfff80a702b PGD 817fc4067 P4D 817fc4067 PUD 817fc0067 PMD 102ef4067 PTE 0 Oops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI CPU: 26 UID: 0 PID: 2667 Comm: ls Tainted: G Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) RIP: 0010:proc_get_inode+0x302/0x6e0 RSP: 0018:ffff88811c837998 EFLAGS: 00010a06 RAX: dffffc0000000000 RBX: ffffffffc0538140 RCX: 0000000000000007 RDX: 1ffffffff80a702b RSI: 0000000000000001 RDI: ffffffffc0538158 RBP: ffff8881299a6000 R08: 0000000067bbe1e5 R09: 1ffff11023906f20 R10: ffffffffb560ca07 R11: ffffffffb2b43a58 R12: ffff888105bb78f0 R13: ffff888100518048 R14: ffff8881299a6004 R15: 0000000000000001 FS: 00007f95b9686840(0000) GS:ffff8883af100000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: fffffbfff80a702b CR3: 0000000117dd2000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> proc_lookup_de+0x11f/0x2e0 __lookup_slow+0x188/0x350 walk_component+0x2ab/0x4f0 path_lookupat+0x120/0x660 filename_lookup+0x1ce/0x560 vfs_statx+0xac/0x150 __do_sys_newstat+0x96/0x110 do_syscall_64+0x5f/0x170 entry_SYSCALL_64_after_hwframe+0x76/0x7e [adobriyan@gmail.com: don't do 2 atomic ops on the common path]",
      "id": "CVE-2025-21999",
      "published": "2025-04-03T08:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_QCOM_PDR_HELPERS not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "ceb550a1-8161-4993-8c5e-88175534ab89",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: soc: qcom: pdr: Fix the potential deadlock When some client process A call pdr_add_lookup() to add the look up for the service and does schedule locator work, later a process B got a new server packet indicating locator is up and call pdr_locator_new_server() which eventually sets pdr->locator_init_complete to true which process A sees and takes list lock and queries domain list but it will timeout due to deadlock as the response will queued to the same qmi->wq and it is ordered workqueue and process B is not able to complete new server request work due to deadlock on list lock. Fix it by removing the unnecessary list iteration as the list iteration is already being done inside locator work, so avoid it here and just call schedule_work() here. Process A Process B process_scheduled_works() pdr_add_lookup() qmi_data_ready_work() process_scheduled_works() pdr_locator_new_server() pdr->locator_init_complete=true; pdr_locator_work() mutex_lock(&pdr->list_lock); pdr_locate_service() mutex_lock(&pdr->list_lock); pdr_get_domain_list() pr_err(\"PDR: %s get domain list txn wait failed: %d\\n\", req->service_name, ret); Timeout error log due to deadlock: \" PDR: tms/servreg get domain list txn wait failed: -110 PDR: service lookup for msm/adsp/sensor_pd:tms/servreg failed: -110 \" Thanks to Bjorn and Johan for letting me know that this commit also fixes an audio regression when using the in-kernel pd-mapper as that makes it easier to hit this race. [1]",
      "id": "CVE-2025-22014",
      "published": "2025-04-08T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:24Z"
      },
      "bom-ref": "418c2ef4-c490-4250-b113-0a3e43a76098",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: RDMA/hns: Fix soft lockup during bt pages loop Driver runs a for-loop when allocating bt pages and mapping them with buffer pages. When a large buffer (e.g. MR over 100GB) is being allocated, it may require a considerable loop count. This will lead to soft lockup: watchdog: BUG: soft lockup - CPU#27 stuck for 22s! ... Call trace: hem_list_alloc_mid_bt+0x124/0x394 [hns_roce_hw_v2] hns_roce_hem_list_request+0xf8/0x160 [hns_roce_hw_v2] hns_roce_mtr_create+0x2e4/0x360 [hns_roce_hw_v2] alloc_mr_pbl+0xd4/0x17c [hns_roce_hw_v2] hns_roce_reg_user_mr+0xf8/0x190 [hns_roce_hw_v2] ib_uverbs_reg_mr+0x118/0x290 watchdog: BUG: soft lockup - CPU#35 stuck for 23s! ... Call trace: hns_roce_hem_list_find_mtt+0x7c/0xb0 [hns_roce_hw_v2] mtr_map_bufs+0xc4/0x204 [hns_roce_hw_v2] hns_roce_mtr_create+0x31c/0x3c4 [hns_roce_hw_v2] alloc_mr_pbl+0xb0/0x160 [hns_roce_hw_v2] hns_roce_reg_user_mr+0x108/0x1c0 [hns_roce_hw_v2] ib_uverbs_reg_mr+0x120/0x2bc Add a cond_resched() to fix soft lockup during these loops. In order not to affect the allocation performance of normal-size buffer, set the loop count of a 100GB MR as the threshold to call cond_resched().",
      "id": "CVE-2025-22010",
      "published": "2025-04-08T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-10T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:26Z"
      },
      "bom-ref": "e2e98419-f476-4b79-9386-c3411d05fb2d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: sctp: add mutual exclusion in proc_sctp_do_udp_port() We must serialize calls to sctp_udp_sock_stop() and sctp_udp_sock_start() or risk a crash as syzbot reported: Oops: general protection fault, probably for non-canonical address 0xdffffc000000000d: 0000 [#1] SMP KASAN PTI KASAN: null-ptr-deref in range [0x0000000000000068-0x000000000000006f] CPU: 1 UID: 0 PID: 6551 Comm: syz.1.44 Not tainted 6.14.0-syzkaller-g7f2ff7b62617 #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025 RIP: 0010:kernel_sock_shutdown+0x47/0x70 net/socket.c:3653 Call Trace: <TASK> udp_tunnel_sock_release+0x68/0x80 net/ipv4/udp_tunnel_core.c:181 sctp_udp_sock_stop+0x71/0x160 net/sctp/protocol.c:930 proc_sctp_do_udp_port+0x264/0x450 net/sctp/sysctl.c:553 proc_sys_call_handler+0x3d0/0x5b0 fs/proc/proc_sysctl.c:601 iter_file_splice_write+0x91c/0x1150 fs/splice.c:738 do_splice_from fs/splice.c:935 [inline] direct_splice_actor+0x18f/0x6c0 fs/splice.c:1158 splice_direct_to_actor+0x342/0xa30 fs/splice.c:1102 do_splice_direct_actor fs/splice.c:1201 [inline] do_splice_direct+0x174/0x240 fs/splice.c:1227 do_sendfile+0xafd/0xe50 fs/read_write.c:1368 __do_sys_sendfile64 fs/read_write.c:1429 [inline] __se_sys_sendfile64 fs/read_write.c:1415 [inline] __x64_sys_sendfile64+0x1d8/0x220 fs/read_write.c:1415 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]",
      "id": "CVE-2025-22062",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T13:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:27Z"
      },
      "bom-ref": "29da55de-ac9a-4e65-adad-389f7c4e392e",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix use-after-free in ksmbd_sessions_deregister() In multichannel mode, UAF issue can occur in session_deregister when the second channel sets up a session through the connection of the first channel. session that is freed through the global session table can be accessed again through ->sessions of connection.",
      "id": "CVE-2025-22041",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-25T18:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:29Z"
      },
      "bom-ref": "57c34ef9-fdab-4b5f-b4a4-f39becd0f419",
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix session use-after-free in multichannel connection There is a race condition between session setup and ksmbd_sessions_deregister. The session can be freed before the connection is added to channel list of session. This patch check reference count of session before freeing it.",
      "id": "CVE-2025-22040",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-25T18:42:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires a compromise of both the network and the specific authentication credentials, the practical exploitability is considered extremely limited.",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "0e865079-364e-410c-b58e-abd2e7b1ad1d",
      "cwes": [
        125
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: validate zero num_subauth before sub_auth is accessed Access psid->sub_auth[psid->num_subauth - 1] without checking if num_subauth is non-zero leads to an out-of-bounds read. This patch adds a validation step to ensure num_subauth != 0 before sub_auth is accessed.",
      "id": "CVE-2025-22038",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-29T19:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:30Z"
      },
      "bom-ref": "80b5ac73-eb99-4f5c-aeb1-4b50bd8428d0",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix null pointer dereference in alloc_preauth_hash() The Client send malformed smb2 negotiate request. ksmbd return error response. Subsequently, the client can send smb2 session setup even thought conn->preauth_info is not allocated. This patch add KSMBD_SESS_NEED_SETUP status of connection to ignore session setup request if smb2 negotiate phase is not complete.",
      "id": "CVE-2025-22037",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-29T19:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:32Z"
      },
      "bom-ref": "3a126c2c-50ea-42c3-9a2f-cd44cc64bbb8",
      "cwes": [
        362,
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: media: streamzap: fix race between device disconnection and urb callback Syzkaller has reported a general protection fault at function ir_raw_event_store_with_filter(). This crash is caused by a NULL pointer dereference of dev->raw pointer, even though it is checked for NULL in the same function, which means there is a race condition. It occurs due to the incorrect order of actions in the streamzap_disconnect() function: rc_unregister_device() is called before usb_kill_urb(). The dev->raw pointer is freed and set to NULL in rc_unregister_device(), and only after that usb_kill_urb() waits for in-progress requests to finish. If rc_unregister_device() is called while streamzap_callback() handler is not finished, this can lead to accessing freed resources. Thus rc_unregister_device() should be called after usb_kill_urb(). Found by Linux Verification Center (linuxtesting.org) with Syzkaller.",
      "id": "CVE-2025-22027",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 4.7,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-06T16:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:33Z"
      },
      "bom-ref": "ce7fb90c-84ff-4993-b677-144664638740",
      "cwes": [
        835
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: wifi: ath11k: fix RCU stall while reaping monitor destination ring While processing the monitor destination ring, MSDUs are reaped from the link descriptor based on the corresponding buf_id. However, sometimes the driver cannot obtain a valid buffer corresponding to the buf_id received from the hardware. This causes an infinite loop in the destination processing, resulting in a kernel crash. kernel log: ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed Fix this by skipping the problematic buf_id and reaping the next entry, replacing the break with the next MSDU processing. Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30 Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1",
      "id": "CVE-2024-58097",
      "published": "2025-04-16T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-06T16:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:35Z"
      },
      "bom-ref": "4985a2e4-116a-4e0c-8986-c9f65432b208",
      "description": "In the Linux kernel, the following vulnerability has been resolved: HSI: ssi_protocol: Fix use after free vulnerability in ssi_protocol Driver Due to Race Condition In the ssi_protocol_probe() function, &ssi->work is bound with ssip_xmit_work(), In ssip_pn_setup(), the ssip_pn_xmit() function within the ssip_pn_ops structure is capable of starting the work. If we remove the module which will call ssi_protocol_remove() to make a cleanup, it will free ssi through kfree(ssi), while the work mentioned above will be used. The sequence of operations that may lead to a UAF bug is as follows: CPU0 CPU1 | ssip_xmit_work ssi_protocol_remove | kfree(ssi); | | struct hsi_client *cl = ssi->cl; | // use ssi Fix it by ensuring that the work is canceled before proceeding with the cleanup in ssi_protocol_remove().",
      "id": "CVE-2025-37838",
      "published": "2025-04-18T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T07:16:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CONFIG_JFS_FS not set in kernel configuration.",
        "justification": "requires_configuration",
        "state": "not_affected"
      },
      "bom-ref": "e797a813-70c4-43f0-b6b0-2ee9e78a7ee6",
      "description": "In the Linux kernel, the following vulnerability has been resolved: jfs: reject on-disk inodes of an unsupported type Syzbot has reported the following BUG: kernel BUG at fs/inode.c:668! Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI CPU: 3 UID: 0 PID: 139 Comm: jfsCommit Not tainted 6.12.0-rc4-syzkaller-00085-g4e46774408d9 #0 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-3.fc41 04/01/2014 RIP: 0010:clear_inode+0x168/0x190 Code: 4c 89 f7 e8 ba fe e5 ff e9 61 ff ff ff 44 89 f1 80 e1 07 80 c1 03 38 c1 7c c1 4c 89 f7 e8 90 ff e5 ff eb b7 0b e8 01 5d 7f ff 90 0f 0b e8 f9 5c 7f ff 90 0f 0b e8 f1 5c 7f RSP: 0018:ffffc900027dfae8 EFLAGS: 00010093 RAX: ffffffff82157a87 RBX: 0000000000000001 RCX: ffff888104d4b980 RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000000 RBP: ffffc900027dfc90 R08: ffffffff82157977 R09: fffff520004fbf38 R10: dffffc0000000000 R11: fffff520004fbf38 R12: dffffc0000000000 R13: ffff88811315bc00 R14: ffff88811315bda8 R15: ffff88811315bb80 FS: 0000000000000000(0000) GS:ffff888135f00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00005565222e0578 CR3: 0000000026ef0000 CR4: 00000000000006f0 Call Trace: <TASK> ? __die_body+0x5f/0xb0 ? die+0x9e/0xc0 ? do_trap+0x15a/0x3a0 ? clear_inode+0x168/0x190 ? do_error_trap+0x1dc/0x2c0 ? clear_inode+0x168/0x190 ? __pfx_do_error_trap+0x10/0x10 ? report_bug+0x3cd/0x500 ? handle_invalid_op+0x34/0x40 ? clear_inode+0x168/0x190 ? exc_invalid_op+0x38/0x50 ? asm_exc_invalid_op+0x1a/0x20 ? clear_inode+0x57/0x190 ? clear_inode+0x167/0x190 ? clear_inode+0x168/0x190 ? clear_inode+0x167/0x190 jfs_evict_inode+0xb5/0x440 ? __pfx_jfs_evict_inode+0x10/0x10 evict+0x4ea/0x9b0 ? __pfx_evict+0x10/0x10 ? iput+0x713/0xa50 txUpdateMap+0x931/0xb10 ? __pfx_txUpdateMap+0x10/0x10 jfs_lazycommit+0x49a/0xb80 ? _raw_spin_unlock_irqrestore+0x8f/0x140 ? lockdep_hardirqs_on+0x99/0x150 ? __pfx_jfs_lazycommit+0x10/0x10 ? __pfx_default_wake_function+0x10/0x10 ? __kthread_parkme+0x169/0x1d0 ? __pfx_jfs_lazycommit+0x10/0x10 kthread+0x2f2/0x390 ? __pfx_jfs_lazycommit+0x10/0x10 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x4d/0x80 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK> This happens when 'clear_inode()' makes an attempt to finalize an underlying JFS inode of unknown type. According to JFS layout description from https://jfs.sourceforge.net/project/pub/jfslayout.pdf, inode types from 5 to 15 are reserved for future extensions and should not be encountered on a valid filesystem. So add an extra check for valid inode type in 'copy_from_dinode()'.",
      "id": "CVE-2025-37925",
      "published": "2025-04-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-29T16:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:36Z"
      },
      "bom-ref": "2c4ef698-8903-4937-ad6a-222ba5f4813d",
      "cwes": [
        401
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: blk-mq: Fix kmemleak in blk_mq_init_allocated_queue There is a kmemleak caused by modprobe null_blk.ko unreferenced object 0xffff8881acb1f000 (size 1024): comm \"modprobe\", pid 836, jiffies 4294971190 (age 27.068s) hex dump (first 32 bytes): 00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00 .....N.......... ff ff ff ff ff ff ff ff 00 53 99 9e ff ff ff ff .........S...... backtrace: [<000000004a10c249>] kmalloc_node_trace+0x22/0x60 [<00000000648f7950>] blk_mq_alloc_and_init_hctx+0x289/0x350 [<00000000af06de0e>] blk_mq_realloc_hw_ctxs+0x2fe/0x3d0 [<00000000e00c1872>] blk_mq_init_allocated_queue+0x48c/0x1440 [<00000000d16b4e68>] __blk_mq_alloc_disk+0xc8/0x1c0 [<00000000d10c98c3>] 0xffffffffc450d69d [<00000000b9299f48>] 0xffffffffc4538392 [<0000000061c39ed6>] do_one_initcall+0xd0/0x4f0 [<00000000b389383b>] do_init_module+0x1a4/0x680 [<0000000087cf3542>] load_module+0x6249/0x7110 [<00000000beba61b8>] __do_sys_finit_module+0x140/0x200 [<00000000fdcfff51>] do_syscall_64+0x35/0x80 [<000000003c0f1f71>] entry_SYSCALL_64_after_hwframe+0x46/0xb0 That is because q->ma_ops is set to NULL before blk_release_queue is called. blk_mq_init_queue_data blk_mq_init_allocated_queue blk_mq_realloc_hw_ctxs for (i = 0; i < set->nr_hw_queues; i++) { old_hctx = xa_load(&q->hctx_table, i); if (!blk_mq_alloc_and_init_hctx(.., i, ..)) [1] if (!old_hctx) break; xa_for_each_start(&q->hctx_table, j, hctx, j) blk_mq_exit_hctx(q, set, hctx, j); [2] if (!q->nr_hw_queues) [3] goto err_hctxs; err_exit: q->mq_ops = NULL; [4] blk_put_queue blk_release_queue if (queue_is_mq(q)) [5] blk_mq_release(q); [1]: blk_mq_alloc_and_init_hctx failed at i != 0. [2]: The hctxs allocated by [1] are moved to q->unused_hctx_list and will be cleaned up in blk_mq_release. [3]: q->nr_hw_queues is 0. [4]: Set q->mq_ops to NULL. [5]: queue_is_mq returns false due to [4]. And blk_mq_release will not be called. The hctxs in q->unused_hctx_list are leaked. To fix it, call blk_release_queue in exception path.",
      "id": "CVE-2022-49901",
      "published": "2025-05-01T15:16:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-07T13:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:38Z"
      },
      "bom-ref": "416275e4-bfcc-4c67-ad55-b88b208d20d9",
      "cwes": [
        667
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: ksmbd: fix WARNING \"do not call blocking ops when !TASK_RUNNING\" wait_event_timeout() will set the state of the current task to TASK_UNINTERRUPTIBLE, before doing the condition check. This means that ksmbd_durable_scavenger_alive() will try to acquire the mutex while already in a sleeping state. The scheduler warns us by giving the following warning: do not call blocking ops when !TASK_RUNNING; state=2 set at [<0000000061515a6f>] prepare_to_wait_event+0x9f/0x6c0 WARNING: CPU: 2 PID: 4147 at kernel/sched/core.c:10099 __might_sleep+0x12f/0x160 mutex lock is not needed in ksmbd_durable_scavenger_alive().",
      "id": "CVE-2025-37802",
      "published": "2025-05-08T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-05T14:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "b13987b0-ff27-49ac-a85a-c2fecebcec9d",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: spi: spi-imx: Add check for spi_imx_setupxfer() Add check for the return value of spi_imx_setupxfer(). spi_imx->rx and spi_imx->tx function pointer can be NULL when spi_imx_setupxfer() return error, and make NULL pointer dereference. Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 Call trace: 0x0 spi_imx_pio_transfer+0x50/0xd8 spi_imx_transfer_one+0x18c/0x858 spi_transfer_one_message+0x43c/0x790 __spi_pump_transfer_message+0x238/0x5d4 __spi_sync+0x2b0/0x454 spi_write_then_read+0x11c/0x200",
      "id": "CVE-2025-37801",
      "published": "2025-05-08T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-05T14:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Unable to determine configuration requirements",
        "justification": "component_not_present",
        "state": "under_investigation",
        "timestamp": "2025-07-06T11:59:41Z"
      },
      "bom-ref": "0d437270-590b-4918-8231-13a61a8ec6b0",
      "cwes": [
        476
      ],
      "description": "In the Linux kernel, the following vulnerability has been resolved: driver core: fix potential NULL pointer dereference in dev_uevent() If userspace reads \"uevent\" device attribute at the same time as another threads unbinds the device from its driver, change to dev->driver from a valid pointer to NULL may result in crash. Fix this by using READ_ONCE() when fetching the pointer, and take bus' drivers klist lock to make sure driver instance will not disappear while we access it. Use WRITE_ONCE() when setting the driver pointer to ensure there is no tearing.",
      "id": "CVE-2025-37800",
      "published": "2025-05-08T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-05T14:32:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "9b5a212a-1b03-476c-a84e-d3982801bca1",
      "description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
      "id": "CVE-2024-22365",
      "published": "2024-02-06T08:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-05T17:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "c33b3ffc-d6a0-4023-96a3-0e66789a7901",
      "cwes": [
        287
      ],
      "description": "The Linux-PAM package before 1.5.2-6.1 for openSUSE Tumbleweed allows authentication bypass for SSH logins. The pam_access.so module doesn't correctly restrict login if a user tries to connect from an IP address that is not resolvable via DNS. In such conditions, a user with denied access to a machine can still get access. NOTE: the relevance of this issue is largely limited to openSUSE Tumbleweed and openSUSE Factory; it does not affect Linux-PAM upstream.",
      "id": "CVE-2022-28321",
      "published": "2022-09-19T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-29T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "dec11f5a-5fbd-4be6-9cd5-7fbb524e7434",
      "cwes": [
        264
      ],
      "description": "The default configuration of logrotate on Debian GNU/Linux uses root privileges to process files in directories that permit non-root write access, which allows local users to conduct symlink and hard link attacks by leveraging logrotate's lack of support for untrusted directories, as demonstrated by /var/log/postgresql/.",
      "id": "CVE-2011-1548",
      "published": "2011-03-30T22:55:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:N/I:C/A:C)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T01:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "0af52d26-030d-4737-8b3c-58a610780cd1",
      "cwes": [
        264
      ],
      "description": "The default configuration of logrotate on Gentoo Linux uses root privileges to process files in directories that permit non-root write access, which allows local users to conduct symlink and hard link attacks by leveraging logrotate's lack of support for untrusted directories, as demonstrated by directories under /var/log/ for packages.",
      "id": "CVE-2011-1549",
      "published": "2011-03-30T22:55:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:N/I:C/A:C)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T01:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "a9e33e44-e9d2-4d7c-afb2-b1794745ad53",
      "cwes": [
        264
      ],
      "description": "The default configuration of logrotate on SUSE openSUSE Factory uses root privileges to process files in directories that permit non-root write access, which allows local users to conduct symlink and hard link attacks by leveraging logrotate's lack of support for untrusted directories, as demonstrated by directories for the (1) cobbler, (2) inn, (3) safte-monitor, and (4) uucp packages.",
      "id": "CVE-2011-1550",
      "published": "2011-03-30T22:55:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:N/I:C/A:C)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T01:26:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "5e390127-a05e-44d2-9751-bf17ff7b859f",
      "cwes": [
        189
      ],
      "description": "Yann Collet LZ4 before r119, when used on certain 32-bit platforms that allocate memory beyond 0x80000000, does not properly detect integer overflows, which allows context-dependent attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted Literal Run, a different vulnerability than CVE-2014-4611.",
      "id": "CVE-2014-4715",
      "published": "2014-07-03T04:22:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "56469e7f-f75c-4689-b021-bb17fb852094",
      "cwes": [
        59
      ],
      "description": "multipath-tools 0.7.7 through 0.9.x before 0.9.2 allows local users to obtain root access, as exploited in conjunction with CVE-2022-41974. Local users able to access /dev/shm can change symlinks in multipathd due to incorrect symlink handling, which could lead to controlled file writes outside of the /dev/shm directory. This could be used indirectly for local privilege escalation to root.",
      "id": "CVE-2022-41973",
      "published": "2022-10-29T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "e2c81963-4137-4363-9da9-106bf0ffcfa6",
      "cwes": [
        269
      ],
      "description": "multipath-tools 0.7.0 through 0.9.x before 0.9.2 allows local users to obtain root access, as exploited alone or in conjunction with CVE-2022-41973. Local users able to write to UNIX domain sockets can bypass access controls and manipulate the multipath setup. This can lead to local privilege escalation to root. This occurs because an attacker can repeat a keyword, which is mishandled because arithmetic ADD is used instead of bitwise OR.",
      "id": "CVE-2022-41974",
      "published": "2022-10-29T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "ad5db0d0-2d80-4515-a91f-40989140748f",
      "description": "A vulnerability was found in GNU Nano that allows a possible privilege escalation through an insecure temporary file. If Nano is killed while editing, a file it saves to an emergency file with the permissions of the running user provides a window of opportunity for attackers to escalate privileges through a malicious symlink.",
      "id": "CVE-2024-5742",
      "published": "2024-06-12T09:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T09:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "a222ab26-5a3b-4d9e-9cc5-73a5506c2a46",
      "cwes": [
        787
      ],
      "description": "ncurses before 6.4 20230408, when used by a setuid application, allows local users to trigger security-relevant memory corruption via malformed data in a terminfo database file that is found in $HOME/.terminfo or reached via the TERMINFO or TERM environment variable.",
      "id": "CVE-2023-29491",
      "published": "2023-04-14T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:57:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Issue is reported on Windows. We are running Linux and not Windows",
        "justification": "code_not_present",
        "response": [
          "will_not_fix"
        ],
        "state": "not_affected"
      },
      "bom-ref": "f577f792-9187-4a61-a7fb-954c9e56f727",
      "cwes": [
        77
      ],
      "description": "A command inject vulnerability allows an attacker to perform command injection on Windows applications that indirectly depend on the CreateProcess function when the specific conditions are satisfied.",
      "id": "CVE-2024-3566",
      "published": "2024-04-10T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-25T20:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "10ce2d44-1e20-42bf-bd71-4b8c7156c3e1",
      "description": "Multiple packages on Sun Solaris, including (1) NSS; (2) Java JDK and JRE 5.0 Update 8 and earlier, SDK and JRE 1.4.x up to 1.4.2_12, and SDK and JRE 1.3.x up to 1.3.1_19; (3) JSSE 1.0.3_03 and earlier; (4) IPSec/IKE; (5) Secure Global Desktop; and (6) StarOffice, when using an RSA key with exponent 3, removes PKCS-1 padding before generating a hash, which allows remote attackers to forge a PKCS #1 v1.5 signature that is signed by that RSA key and prevents these products from correctly verifying X.509 and other certificates that use PKCS #1.",
      "id": "CVE-2006-5201",
      "published": "2006-10-10T04:06:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:H/Au:N/C:N/I:P/A:P)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T00:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "c8ab2042-8c1b-475a-b5c8-67cdba689f17",
      "description": "ssh-add in OpenSSH before 9.3 adds smartcard keys to ssh-agent without the intended per-hop destination constraints. The earliest affected version is 8.9.",
      "id": "CVE-2023-28531",
      "published": "2023-03-17T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "66038496-fa39-49b8-a40a-64e8cf8688e6",
      "cwes": [
        428
      ],
      "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
      "id": "CVE-2023-38408",
      "published": "2023-07-20T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "79b95b2e-e20b-430d-8f63-05a478725638",
      "description": "In ssh-agent in OpenSSH before 9.6, certain destination constraints can be incompletely applied. When destination constraints are specified during addition of PKCS#11-hosted private keys, these constraints are only applied to the first key, even if a PKCS#11 token returns multiple keys.",
      "id": "CVE-2023-51384",
      "published": "2023-12-18T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "4441b33e-e920-4ad0-9666-58a08d786408",
      "cwes": [
        78
      ],
      "description": "In ssh in OpenSSH before 9.6, OS command injection might occur if a user name or host name has shell metacharacters, and this name is referenced by an expansion token in certain situations. For example, an untrusted Git repository can have a submodule with shell metacharacters in a user name or host name.",
      "id": "CVE-2023-51385",
      "published": "2023-12-18T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "b5e06536-66db-46d6-8107-e6a4cd6be902",
      "description": "OpenSSH through 9.6, when common types of DRAM are used, might allow row hammer attacks (for authentication bypass) because the integer value of authenticated in mm_answer_authpassword does not resist flips of a single bit. NOTE: this is applicable to a certain threat model of attacker-victim co-location in which the attacker has user privileges.",
      "id": "CVE-2023-51767",
      "published": "2023-12-24T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.0,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "3a688d6c-afc5-4b7e-86bf-68d630ffeb58",
      "cwes": [
        20
      ],
      "description": "Certain Red Hat Enterprise Linux (RHEL) 4 and 5 packages for OpenSSH, as signed in August 2008 using a legitimate Red Hat GPG key, contain an externally introduced modification (Trojan Horse) that allows the package authors to have an unknown impact. NOTE: since the malicious packages were not distributed from any official Red Hat sources, the scope of this issue is restricted to users who may have obtained these packages through unofficial distribution points. As of 20080827, no unofficial distributions of this software are known.",
      "id": "CVE-2008-3844",
      "published": "2008-08-27T20:41:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 9.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:C/I:C/A:C)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T00:50:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "bc66efcb-fd8a-4a42-bafb-4d512b91ace5",
      "cwes": [
        200
      ],
      "description": "OpenSSH, when using OPIE (One-Time Passwords in Everything) for PAM, allows remote attackers to determine the existence of certain user accounts, which displays a different response if the user account exists and is configured to use one-time passwords (OTP), a similar issue to CVE-2007-2243.",
      "id": "CVE-2007-2768",
      "published": "2007-05-21T20:30:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:N/A:N)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T00:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "87eb0848-b431-41e0-ad5f-d63f78bc9b7d",
      "cwes": [
        362
      ],
      "description": "A security regression (CVE-2006-5051) was discovered in OpenSSH's server (sshd). There is a race condition which can lead sshd to handle some signals in an unsafe manner. An unauthenticated, remote attacker may be able to trigger it by failing to authenticate within a set time period.",
      "id": "CVE-2024-6387",
      "published": "2024-07-01T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.1,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-24T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "9ec10cd3-5f74-4fb3-bcb3-cac76351bde8",
      "description": "A vulnerability was found in OpenSSH when the VerifyHostKeyDNS option is enabled. A machine-in-the-middle attack can be performed by a malicious machine impersonating a legit server. This issue occurs due to how OpenSSH mishandles error codes in specific conditions when verifying the host key. For an attack to be considered successful, the attacker needs to manage to exhaust the client's memory resource first, turning the attack complexity high.",
      "id": "CVE-2025-26465",
      "published": "2025-02-18T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-02T15:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "918f84d0-a4a5-49f5-8237-a57509d7068f",
      "description": "In sshd in OpenSSH before 10.0, the DisableForwarding directive does not adhere to the documentation stating that it disables X11 and agent forwarding.",
      "id": "CVE-2025-32728",
      "published": "2025-04-10T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.8,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T16:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "205dec98-021b-48b9-9a97-adc03b6f57fe",
      "cwes": [
        476
      ],
      "description": "A null pointer dereference issue was discovered in functions op_get_data and op_open1 in opusfile.c in xiph opusfile 0.9 thru 0.12 allows attackers to cause denial of service or other unspecified impacts.",
      "id": "CVE-2022-47021",
      "published": "2023-01-20T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-03T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "32a021e4-9c84-47a0-98a3-2ad1527a803c",
      "cwes": [
        59
      ],
      "description": "In GNU patch through 2.7.6, the following of symlinks is mishandled in certain cases other than input files. This affects inp.c and util.c.",
      "id": "CVE-2019-13636",
      "published": "2019-07-17T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "5367dc39-a890-474d-b189-1fe4940ebd46",
      "cwes": [
        78
      ],
      "description": "GNU patch through 2.7.6 is vulnerable to OS shell command injection that can be exploited by opening a crafted patch file that contains an ed style diff payload with shell metacharacters. The ed editor does not need to be present on the vulnerable system. This is different from CVE-2018-1000156.",
      "id": "CVE-2019-13638",
      "published": "2019-07-26T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 9.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:C/I:C/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "5e76042a-b033-47cb-add3-83b88326d347",
      "cwes": [
        415
      ],
      "description": "GNU patch through 2.7.6 contains a free(p_line[p_end]) Double Free vulnerability in the function another_hunk in pch.c that can cause a denial of service via a crafted patch file. NOTE: this issue exists because of an incomplete fix for CVE-2018-6952.",
      "id": "CVE-2019-20633",
      "published": "2020-03-25T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "c97a6a11-2a87-479a-8765-6032153b014c",
      "cwes": [
        20
      ],
      "description": "GNU Patch version 2.7.6 contains an input validation vulnerability when processing patch files, specifically the EDITOR_PROGRAM invocation (using ed) can result in code execution. This attack appear to be exploitable via a patch file processed via the patch utility. This is similar to FreeBSD's CVE-2015-1418 however although they share a common ancestry the code bases have diverged over time.",
      "id": "CVE-2018-1000156",
      "published": "2018-04-06T13:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-14T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "c9a66da6-707f-41f4-8cb6-10488ea7978a",
      "cwes": [
        78
      ],
      "description": "do_ed_script in pch.c in GNU patch through 2.7.6 does not block strings beginning with a ! character. NOTE: this is the same commit as for CVE-2019-13638, but the ! syntax is specific to ed, and is unrelated to a shell metacharacter.",
      "id": "CVE-2018-20969",
      "published": "2019-08-16T04:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 9.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:C/I:C/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:02:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "064688d9-6beb-49ba-baad-4a2b5a827a86",
      "cwes": [
        476
      ],
      "description": "An issue was discovered in GNU patch through 2.7.6. There is a segmentation fault, associated with a NULL pointer dereference, leading to a denial of service in the intuit_diff_type function in pch.c, aka a \"mangled rename\" issue.",
      "id": "CVE-2018-6951",
      "published": "2018-02-13T19:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "86ff39a2-6af6-42c1-a433-1ca59f3f9b7a",
      "cwes": [
        415
      ],
      "description": "A double free exists in the another_hunk function in pch.c in GNU patch through 2.7.6.",
      "id": "CVE-2018-6952",
      "published": "2018-02-13T19:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:39Z"
      },
      "bom-ref": "dd931b00-8b02-4909-b1b4-308128c8236a",
      "cwes": [
        190
      ],
      "description": "Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.",
      "id": "CVE-2022-41409",
      "published": "2023-07-18T14:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:42Z"
      },
      "bom-ref": "f6c5eebc-28ae-4098-a105-93136fea7d34",
      "cwes": [
        787
      ],
      "description": "A heap buffer overflow vulnerability was discovered in Perl. Release branches 5.34, 5.36, 5.38 and 5.40 are affected, including development versions from 5.33.1 through 5.41.10. When there are non-ASCII bytes in the left-hand-side of the `tr` operator, `S_do_trans_invmap` can overflow the destination pointer `d`. \u00a0 \u00a0$ perl -e '$_ = \"\\x{FF}\" x 1000000; tr/\\xFF/\\x{100}/;' \u00a0 \u00a0Segmentation fault (core dumped) It is believed that this vulnerability can enable Denial of Service and possibly Code Execution attacks on platforms that lack sufficient defenses.",
      "id": "CVE-2024-56406",
      "published": "2025-04-13T14:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-30T15:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:41Z"
      },
      "bom-ref": "89447192-cf30-4668-89e7-d213bfea394e",
      "cwes": [
        190
      ],
      "description": "In libpixman in Pixman before 0.42.2, there is an out-of-bounds write (aka heap-based buffer overflow) in rasterize_edges_8 due to an integer overflow in pixman_sample_floor_y.",
      "id": "CVE-2022-44638",
      "published": "2022-11-03T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:41Z"
      },
      "bom-ref": "829ddd34-effb-47e1-ad78-272cc59d43a0",
      "cwes": [
        125,
        787
      ],
      "description": "A local privilege escalation vulnerability was found on polkit's pkexec utility. The pkexec application is a setuid tool designed to allow unprivileged users to run commands as privileged users according predefined policies. The current version of pkexec doesn't handle the calling parameters count correctly and ends trying to execute environment variables as commands. An attacker can leverage this by crafting environment variables in such a way it'll induce pkexec to execute arbitrary code. When successfully executed the attack can cause a local privilege escalation given unprivileged users administrative rights on the target machine.",
      "id": "CVE-2021-4034",
      "published": "2022-01-28T20:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 7.2,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:C/I:C/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-03T18:53:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain access to the secure customer network where the device resides. Attack Complexity (AC): Attack complexity is High (H). The adversary must not only breach the network but also obtain a valid, short-lived (90-day) SSH client certificate to authenticate to the device. Privileges Required (PR): High (H) privileges are required, as the attacker needs a valid certificate that represents an authorized user. Given that a successful attack requires the user to gain access to the device due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "3a8c9907-81e8-4260-9bba-e9f94407c253",
      "cwes": [
        116
      ],
      "description": "pkexec, when used with --user nonpriv, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
      "id": "CVE-2016-2568",
      "published": "2017-02-13T18:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.4,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:41Z"
      },
      "bom-ref": "5b78f5de-d6ea-442b-9774-fcdf2282b67b",
      "cwes": [
        787
      ],
      "description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
      "id": "CVE-2023-4016",
      "published": "2023-08-02T05:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:34:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:41Z"
      },
      "bom-ref": "93cb5390-52a0-4526-86db-6ccfc2a21c5a",
      "cwes": [
        674
      ],
      "description": "The legacy email.utils.parseaddr function in Python through 3.11.4 allows attackers to trigger \"RecursionError: maximum recursion depth exceeded while calling a Python object\" via a crafted argument. This argument is plausibly an untrusted value from an application's input data that was supposed to contain a name and an e-mail address. NOTE: email.utils.parseaddr is categorized as a Legacy API in the documentation of the Python email package. Applications should instead use the email.parser.BytesParser or email.parser.Parser class. NOTE: the vendor's perspective is that this is neither a vulnerability nor a bug. The email package is intended to have size limits and to throw an exception when limits are exceeded; they were exceeded by the example demonstration code.",
      "id": "CVE-2023-36632",
      "published": "2023-06-25T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:10:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:44Z"
      },
      "bom-ref": "3dd23d4a-76fa-4db7-8feb-90b2f94634fe",
      "description": "An issue was discovered in gui/util/qktxhandler.cpp in Qt before 5.15.17, 6.x before 6.2.12, 6.3.x through 6.5.x before 6.5.5, and 6.6.x before 6.6.2. A buffer overflow and application crash can occur via a crafted KTX image file.",
      "id": "CVE-2024-25580",
      "published": "2024-03-27T03:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-30T12:17:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:45Z"
      },
      "bom-ref": "a4e2231c-72bf-4506-9e8e-82e783755e0d",
      "description": "QAbstractOAuth in Qt Network Authorization in Qt before 5.15.17, 6.x before 6.2.13, 6.3.x through 6.5.x before 6.5.6, and 6.6.x through 6.7.x before 6.7.1 uses only the time to seed the PRNG, which may result in guessable values.",
      "id": "CVE-2024-36048",
      "published": "2024-05-18T21:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-30T15:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: We are not using SQL in our applications",
        "justification": "code_not_reachable",
        "response": [
          "update"
        ],
        "state": "not_affected"
      },
      "bom-ref": "99bfeb44-ccba-429c-9ee2-c37c59e54aee",
      "description": "Qt before 6.4.3 allows a denial of service via a crafted string when the SQL ODBC driver plugin is used and the size of SQLTCHAR is 4. The affected versions are 5.x before 5.15.13, 6.x before 6.2.8, and 6.3.x before 6.4.3.",
      "id": "CVE-2023-24607",
      "published": "2023-04-15T01:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:48:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:47Z"
      },
      "bom-ref": "1dc6478d-e02f-40a1-8e08-0af6b7e931a3",
      "cwes": [
        369
      ],
      "description": "In Qt before 5.15.14, 6.0.x through 6.2.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.1, QtSvg QSvgFont m_unitsPerEm initialization is mishandled.",
      "id": "CVE-2023-32573",
      "published": "2023-05-10T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-01-27T21:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:48Z"
      },
      "bom-ref": "52764295-f9b0-48c0-86fa-34aab9c35b1f",
      "description": "An issue was discovered in Qt before 5.15.14, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.1. Qt Network incorrectly parses the strict-transport-security (HSTS) header, allowing unencrypted connections to be established, even when explicitly prohibited by the server. This happens if the case used for this header does not exactly match.",
      "id": "CVE-2023-32762",
      "published": "2023-05-28T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:03:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Attack would require that an attacker doctors an SVG and somehow get it on our device and renders it. Our applications does not use SVGs,",
        "justification": "code_not_reachable",
        "state": "not_affected"
      },
      "bom-ref": "09efca95-7b8e-45f7-be2a-f47fd7e97807",
      "cwes": [
        120
      ],
      "description": "An issue was discovered in Qt before 5.15.15, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.1. When a SVG file with an image inside it is rendered, a QTextLayout buffer overflow can be triggered.",
      "id": "CVE-2023-32763",
      "published": "2023-05-28T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:04:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:50Z"
      },
      "bom-ref": "23b7f0c1-3e96-4061-80bf-f32aa2ea18bf",
      "cwes": [
        295
      ],
      "description": "An issue was discovered in Qt before 5.15.15, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.2. Certificate validation for TLS does not always consider whether the root of a chain is a configured CA certificate.",
      "id": "CVE-2023-34410",
      "published": "2023-06-05T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:30:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Affected QXmlStreamReader is not used in our code",
        "justification": "code_not_present",
        "response": [
          "update"
        ],
        "state": "not_affected"
      },
      "bom-ref": "c2cce5f3-bbb1-45a1-ba55-67a07c57de79",
      "description": "In Qt before 5.15.15, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.2, there can be an application crash in QXmlStreamReader via a crafted XML string that triggers a situation in which a prefix is greater than a length.",
      "id": "CVE-2023-37369",
      "published": "2023-08-20T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: Affected QXmlStreamReader is not used in our code",
        "justification": "code_not_present",
        "response": [
          "update"
        ],
        "state": "not_affected"
      },
      "bom-ref": "99848a82-e277-4ac3-8c4d-0048d85e6f40",
      "cwes": [
        835
      ],
      "description": "An issue was discovered in Qt before 5.15.15, 6.x before 6.2.10, and 6.3.x through 6.5.x before 6.5.3. There are infinite loops in recursive entity expansion.",
      "id": "CVE-2023-38197",
      "published": "2023-07-13T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:13:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "5337c22f-b191-4df6-a5d5-bce2261521fd",
      "description": "An issue was discovered in Qt before 5.15.16, 6.x before 6.2.10, and 6.3.x through 6.5.x before 6.5.3 on Windows. When using the GDI font engine, if a corrupted font is loaded via QFontDatabase::addApplicationFont{FromData], then it can cause the application to crash because of missing length checks.",
      "id": "CVE-2023-43114",
      "published": "2023-09-18T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:23:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:50Z"
      },
      "bom-ref": "d2557068-970c-43c7-8fe8-29a54ab6baa7",
      "cwes": [
        190
      ],
      "description": "An issue was discovered in the HTTP2 implementation in Qt before 5.15.17, 6.x before 6.2.11, 6.3.x through 6.5.x before 6.5.4, and 6.6.x before 6.6.2. network/access/http2/hpacktable.cpp has an incorrect HPack integer overflow check.",
      "id": "CVE-2023-51714",
      "published": "2023-12-24T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T21:31:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Not Affected. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), Attack Complexity (AC): Attack complexity is Low Privileges Required (PR): Low privileges are required Given that a successful attack requires the user to gain access to the device due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "cbe605af-d457-4867-99a4-129937a30fbb",
      "description": "In Qt 5.9.x through 5.15.x before 5.15.9 and 6.x before 6.2.4 on Linux and UNIX, QProcess could execute a binary from the current working directory when not found in the PATH.",
      "id": "CVE-2022-25255",
      "published": "2022-02-16T19:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 7.2,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:C/I:C/A:C)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:51:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Not Affected. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), Attack Complexity (AC): Attack complexity is Low Privileges Required (PR): Low privileges are required Given that a successful attack requires the user to gain access to the device due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "protected_at_perimeter",
        "state": "not_affected"
      },
      "bom-ref": "a4be1368-d8ac-4e69-8b63-0416bea63506",
      "cwes": [
        22
      ],
      "description": "Qt through 5.15.8 and 6.x through 6.2.3 can load system library files from an unintended working directory.",
      "id": "CVE-2022-25634",
      "published": "2022-03-02T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:P/I:N/A:N)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:52:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:50Z"
      },
      "bom-ref": "ea19072b-d509-46ed-a8f3-e9bb9dda24d1",
      "cwes": [
        367
      ],
      "description": "An issue was discovered in HTTP2 in Qt before 5.15.18, 6.x before 6.2.13, 6.3.x through 6.5.x before 6.5.7, and 6.6.x through 6.7.x before 6.7.3. Code to make security-relevant decisions about an established connection may execute too early, because the encrypted() signal has not yet been emitted and processed..",
      "id": "CVE-2024-39936",
      "published": "2024-07-04T21:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-19T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:53Z"
      },
      "bom-ref": "a593f93f-c830-4c5c-8b68-dac82df3e4ac",
      "cwes": [
        407
      ],
      "description": "encodeText in QDom in Qt before 6.8.0 has a complex algorithm involving XML string copy and inline replacement of parts of a string (with relocation of later data).",
      "id": "CVE-2025-30348",
      "published": "2025-03-21T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-24T14:08:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "16bfe179-2032-4078-9d50-3bde4bf0ad9c",
      "cwes": [
        22
      ],
      "description": "A flaw was found in rsync. When using the `--safe-links` option, the rsync client fails to properly verify if a symbolic link destination sent from the server contains another symbolic link within it. This results in a path traversal vulnerability, which may lead to arbitrary file write outside the desired directory.",
      "id": "CVE-2024-12088",
      "published": "2025-01-14T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T16:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "61e47e9c-fca2-43f3-9ead-cfc49aa453ef",
      "cwes": [
        22
      ],
      "description": "A path traversal vulnerability exists in rsync. It stems from behavior enabled by the `--inc-recursive` option, a default-enabled option for many client options and can be enabled by the server even if not explicitly enabled by the client. When using the `--inc-recursive` option, a lack of proper symlink verification coupled with deduplication checks occurring on a per-file-list basis could allow a server to write files outside of the client's intended destination directory. A malicious server could write malicious files to arbitrary locations named after valid directories/paths on the client.",
      "id": "CVE-2024-12087",
      "published": "2025-01-14T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-20T18:28:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "f1e2437e-e11e-4fbc-90b8-a28b1548e429",
      "description": "A flaw was found in rsync. It could allow a server to enumerate the contents of an arbitrary file from the client's machine. This issue occurs when files are being copied from a client to a server. During this process, the rsync server will send checksums of local data to the client to compare with in order to determine what data needs to be sent to the server. By sending specially constructed checksum values for arbitrary files, an attacker may be able to reconstruct the data of those files byte-by-byte based on the responses from the client.",
      "id": "CVE-2024-12086",
      "published": "2025-01-14T18:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-20T18:40:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "8a2ea420-21c2-4757-bfc0-9086b5ea9c49",
      "cwes": [
        787
      ],
      "description": "A heap-based buffer overflow flaw was found in the rsync daemon. This issue is due to improper handling of attacker-controlled checksum lengths (s2length) in the code. When MAX_DIGEST_LEN exceeds the fixed SUM_LENGTH (16 bytes), an attacker can write out of bounds in the sum2 buffer.",
      "id": "CVE-2024-12084",
      "published": "2025-01-15T15:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-18T16:25:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "a32c8a64-79ee-4dcf-90a6-7e231f81df68",
      "cwes": [
        1333
      ],
      "description": "Python Packaging Authority (PyPA) setuptools before 65.5.1 allows remote attackers to cause a denial of service via HTML in a crafted package or custom PackageIndex page. There is a Regular Expression Denial of Service (ReDoS) in package_index.py.",
      "id": "CVE-2022-40897",
      "published": "2022-12-23T00:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.9,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:22:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "Assessment Rationale: The assessed severity of this vulnerability is Low. This is based on the following factors that increase the complexity of an attack: Attack Vector (AV): The attack vector is Local (L), as the attacker must first gain user access to the local device Attack Complexity (AC): Attack complexity is High (H). Privileges Required (PR): Low(L) privileges are required. Given that a successful attack requires the attacker to gain user access to the device operating system due to the local attack vector, the practical exploitability is considered not affected",
        "justification": "code_not_reachable",
        "response": [
          "update"
        ],
        "state": "not_affected"
      },
      "bom-ref": "7d9d849a-044a-4017-b698-39200b6d32d9",
      "description": "setuptools is a package that allows users to download, build, install, upgrade, and uninstall Python packages. A path traversal vulnerability in `PackageIndex` is present in setuptools prior to version 78.1.1. An attacker would be allowed to write files to arbitrary locations on the filesystem with the permissions of the process running the Python code, which could escalate to remote code execution depending on the context. Version 78.1.1 fixes the issue.",
      "id": "CVE-2025-47273",
      "published": "2025-05-17T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 8.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-06-12T16:29:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "3092daf0-3994-40b7-9421-589931cdcc56",
      "cwes": [
        119
      ],
      "description": "A vulnerability was found in SQLite SQLite3 up to 3.43.0 and classified as critical. This issue affects the function sessionReadRecord of the file ext/session/sqlite3session.c of the component make alltest Handler. The manipulation leads to heap-based buffer overflow. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-248999.",
      "id": "CVE-2023-7104",
      "published": "2023-12-29T10:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:45:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "c1ef7add-b27a-4d88-8bcc-41fcd6a4c19d",
      "cwes": [
        129
      ],
      "description": "SQLite 1.0.12 through 3.39.x before 3.39.2 sometimes allows an array-bounds overflow if billions of bytes are used in a string argument to a C API.",
      "id": "CVE-2022-35737",
      "published": "2022-08-03T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T07:11:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "5a609fda-ad3b-4a4e-8dab-eb45775b379c",
      "description": "SQLite through 3.40.0, when relying on --safe for execution of an untrusted CLI script, does not properly implement the azProhibitedFunctions protection mechanism, and instead allows UDF functions such as WRITEFILE.",
      "id": "CVE-2022-46908",
      "published": "2022-12-12T06:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 7.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "6dc6b9ac-653f-4c27-97c4-dec30d4e2a12",
      "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
      "id": "CVE-2022-3821",
      "published": "2022-11-08T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-02T18:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "0d8dedcf-1136-4970-a43e-4aa22b527f47",
      "description": "A vulnerability was found in systemd. This security flaw can cause a local information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel setting.",
      "id": "CVE-2022-4415",
      "published": "2023-01-11T15:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T16:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "3a746b80-d97e-425c-9943-f65a102b7747",
      "cwes": [
        400
      ],
      "description": "systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock by triggering a crash that has a long backtrace. This occurs in parse_elf_object in shared/elf-util.c. The exploitation methodology is to crash a binary calling the same function recursively, and put it in a deeply nested directory to make its backtrace large enough to cause the deadlock. This must be done 16 times when MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file.",
      "id": "CVE-2022-45873",
      "published": "2022-11-23T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-25T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "a66f037e-cd5e-41d5-ba50-3c2ebefb3940",
      "cwes": [
        787
      ],
      "description": "A flaw was found in Unzip. The vulnerability occurs during the conversion of a wide string to a local string that leads to a heap of out-of-bound write. This flaw allows an attacker to input a specially crafted zip file, leading to a crash or code execution.",
      "id": "CVE-2022-0529",
      "published": "2022-02-09T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "4d572315-b9b4-4747-8c05-3e49737b32e2",
      "description": "A flaw was found in Unzip. The vulnerability occurs during the conversion of a wide string to a local string that leads to a heap of out-of-bound write. This flaw allows an attacker to input a specially crafted zip file, leading to a crash or code execution.",
      "id": "CVE-2022-0530",
      "published": "2022-02-09T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:38:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "eee55293-3a6f-4202-9443-ae1b0fe617f9",
      "cwes": [
        476
      ],
      "description": "A flaw was found in unzip. The vulnerability occurs due to improper handling of Unicode strings, which can lead to a null pointer dereference. This flaw allows an attacker to input a specially crafted zip file, leading to a crash or code execution.",
      "id": "CVE-2021-4217",
      "published": "2022-08-24T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T06:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "1f7dbf7b-dc57-4bed-bc20-6fb6c6bedcac",
      "cwes": [
        400
      ],
      "description": "Info-ZIP UnZip 6.0 mishandles the overlapping of files inside a ZIP container, leading to denial of service (resource consumption), aka a \"better zip bomb\" issue.",
      "id": "CVE-2019-13232",
      "published": "2019-07-04T13:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 3.3,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T04:24:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "ebb04ab6-b7c1-4746-b070-81e1c4b57f5a",
      "cwes": [
        787
      ],
      "description": "A heap-based buffer overflow exists in Info-Zip UnZip version <= 6.00 in the processing of password-protected archives that allows an attacker to perform a denial of service or to possibly achieve code execution.",
      "id": "CVE-2018-1000035",
      "published": "2018-02-09T23:29:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T03:39:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "c61293e1-964e-4403-b103-ce10c58f62ce",
      "cwes": [
        119
      ],
      "description": "Info-ZIP UnZip 6.0 has a buffer overflow in list.c, when a ZIP archive has a crafted relationship between the compressed-size value and the uncompressed-size value, because a buffer size is 10 and is supposed to be 12.",
      "id": "CVE-2018-18384",
      "published": "2018-10-16T16:50:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T03:55:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "0fe9d113-9534-454f-adce-c0a485b85df4",
      "cwes": [
        119
      ],
      "description": "Buffer overflow in the zi_short function in zipinfo.c in Info-Zip UnZip 6.0 allows remote attackers to cause a denial of service (crash) via a large compression method value in the central directory file header.",
      "id": "CVE-2016-9844",
      "published": "2017-01-18T17:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T03:01:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "dca4141a-bf70-4cfc-9353-8f8f514ec662",
      "cwes": [
        119
      ],
      "description": "Info-ZIP UnZip 6.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly execute arbitrary code via a crafted password-protected ZIP archive, possibly related to an Extra-Field size value.",
      "id": "CVE-2015-7696",
      "published": "2015-11-06T18:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "96cb52cb-6322-49fc-bfa3-c489c99506e6",
      "cwes": [
        399
      ],
      "description": "Info-ZIP UnZip 6.0 allows remote attackers to cause a denial of service (infinite loop) via empty bzip2 data in a ZIP archive.",
      "id": "CVE-2015-7697",
      "published": "2015-11-06T18:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 4.3,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:N/I:N/A:P)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:37:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "3a6b56a5-048a-497c-a822-6de5748dd38f",
      "cwes": [
        787
      ],
      "description": "Heap-based buffer overflow in the CRC32 verification in Info-ZIP UnZip 6.0 and earlier allows remote attackers to execute arbitrary code via a crafted zip file in the -t command argument to the unzip command.",
      "id": "CVE-2014-8139",
      "published": "2020-01-31T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "9aed4369-9b2c-4bf9-802d-9b65f405408a",
      "cwes": [
        787
      ],
      "description": "Heap-based buffer overflow in the test_compr_eb function in Info-ZIP UnZip 6.0 and earlier allows remote attackers to execute arbitrary code via a crafted zip file in the -t command argument to the unzip command.",
      "id": "CVE-2014-8140",
      "published": "2020-01-31T22:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "7d8c790e-1558-4aba-ba0a-5622068c34d1",
      "cwes": [
        787
      ],
      "description": "Heap-based buffer overflow in the getZip64Data function in Info-ZIP UnZip 6.0 and earlier allows remote attackers to execute arbitrary code via a crafted zip file in the -t command argument to the unzip command.",
      "id": "CVE-2014-8141",
      "published": "2020-01-31T23:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 6.8,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:P/I:P/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.8,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:18:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "ece672ef-1ede-4126-bcb1-fe7099549e2e",
      "cwes": [
        119
      ],
      "description": "unzip 6.0 allows remote attackers to cause a denial of service (out-of-bounds read or write and crash) via an extra field with an uncompressed size smaller than the compressed field size in a zip archive that advertises STORED method compression.",
      "id": "CVE-2014-9636",
      "published": "2015-02-06T15:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "954d9c46-357f-4be4-9134-054f4ea70ce3",
      "cwes": [
        119
      ],
      "description": "Buffer overflow in the list_files function in list.c in Info-Zip UnZip 6.0 allows remote attackers to cause a denial of service (crash) via vectors related to the compression method.",
      "id": "CVE-2014-9913",
      "published": "2017-01-18T17:59:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 2.1,
          "severity": "low",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:L/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 4.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T02:21:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "66255393-7dcf-4c6b-97be-d71f66899c41",
      "cwes": [
        119
      ],
      "description": "The NEEDBITS macro in the inflate_dynamic function in inflate.c for unzip can be invoked using invalid buffers, which allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via unknown vectors that trigger a free of uninitialized or previously-freed data.",
      "id": "CVE-2008-0888",
      "published": "2008-03-17T21:44:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 9.3,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:M/Au:N/C:C/I:C/A:C)"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-01T15:33:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "0bc07493-373b-4d3b-9b0f-1a56a9f5c18b",
      "description": "wall in util-linux through 2.40, often installed with setgid tty permissions, allows escape sequences to be sent to other users' terminals through argv. (Specifically, escape sequences received from stdin are blocked, but escape sequences received from argv are not blocked.) There may be plausible scenarios where this leads to account takeover.",
      "id": "CVE-2024-28085",
      "published": "2024-03-27T19:15:00Z",
      "ratings": [
        {
          "method": "other",
          "severity": "unknown",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          }
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-03-20T17:58:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "6ebd3f36-c213-44f8-8543-8725e4566c0e",
      "cwes": [
        190
      ],
      "description": "An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.",
      "id": "CVE-2021-3782",
      "published": "2022-09-23T16:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.6,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-22T19:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "8ba5f48c-7347-401a-981c-06c4b1f15e72",
      "cwes": [
        436
      ],
      "description": "url.c in GNU Wget through 1.24.5 mishandles semicolons in the userinfo subcomponent of a URI, and thus there may be insecure behavior in which data that was supposed to be in the userinfo subcomponent is misinterpreted to be part of the host subcomponent.",
      "id": "CVE-2024-38428",
      "published": "2024-06-16T03:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.1,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-04-21T10:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "1f0f4fc4-1b2a-4266-a8f0-362e5a0ed249",
      "cwes": [
        287
      ],
      "description": "The implementation of PEAP in wpa_supplicant through 2.10 allows authentication bypass. For a successful attack, wpa_supplicant must be configured to not verify the network's TLS certificate during Phase 1 authentication, and an eap_peap_decrypt vulnerability can then be abused to skip Phase 2 authentication. The attack vector is sending an EAP-TLV Success packet instead of starting Phase 2. This allows an adversary to impersonate Enterprise Wi-Fi networks.",
      "id": "CVE-2023-52160",
      "published": "2024-02-22T17:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 6.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-05T14:14:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "412e52bc-6789-4e25-8d00-80a0447e7f64",
      "cwes": [
        190
      ],
      "description": "MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version, and exposes the applicable MiniZip code through its compress API.",
      "id": "CVE-2023-45853",
      "published": "2023-10-14T02:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-12-20T17:41:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "1d290c87-db78-43a6-9fbe-92bb9df90657",
      "cwes": [
        787
      ],
      "description": "Cloudflare version of zlib library was found to be vulnerable to memory corruption issues affecting the deflation algorithm implementation (deflate.c). The issues resulted from improper input validation and heap-based buffer overflow. A local attacker could exploit the problem during compression using a crafted malicious file potentially leading to denial of service of the software. Patches: The issue has been patched in commit 8352d10 https://github.com/cloudflare/zlib/commit/8352d108c05db1bdc5ac3bdf834dad641694c13c . The upstream repository is not affected.",
      "id": "CVE-2023-6992",
      "published": "2024-01-04T12:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 5.5,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2024-11-21T08:44:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "7846fb5c-2fa8-4aa1-b19a-2630fc71e586",
      "cwes": [
        787
      ],
      "description": "zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).",
      "id": "CVE-2022-37434",
      "published": "2022-08-05T07:15:00Z",
      "ratings": [
        {
          "method": "CVSSv3",
          "score": 9.8,
          "severity": "critical",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-30T20:15:00Z"
    },
    {
      "affects": [
        {
          "ref": "81968588-121d-4480-981f-5494ac2acf71"
        }
      ],
      "analysis": {
        "detail": "CVE not related to Linux kernel",
        "justification": "component_not_present",
        "state": "not_affected",
        "timestamp": "2025-07-06T11:59:51Z"
      },
      "bom-ref": "63167f4f-3aad-4643-99cb-74995072fb1c",
      "cwes": [
        787
      ],
      "description": "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
      "id": "CVE-2018-25032",
      "published": "2022-03-25T09:15:00Z",
      "ratings": [
        {
          "method": "CVSSv2",
          "score": 5.0,
          "severity": "medium",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "(AV:N/AC:L/Au:N/C:N/I:N/A:P)"
        },
        {
          "method": "CVSSv3",
          "score": 7.5,
          "severity": "high",
          "source": {
            "name": "NVD",
            "url": "https://nvd.nist.gov/"
          },
          "vector": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
        }
      ],
      "source": {
        "name": "NVD",
        "url": "https://nvd.nist.gov/"
      },
      "updated": "2025-05-06T15:15:00Z"
    }
  ]
}