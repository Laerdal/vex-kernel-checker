#!/usr/bin/env python3
"""
Vulnerability Analyzer for VEX Kernel Checker.

This module handles the core vulnerability analysis logic, including:
- Architecture compatibility checking
- Driver-specific pattern detection
- Configuration requirement analysis
- Vulnerability state determination
"""

import time
from typing import Any, Dict, List, Optional, Set

from .base import VexKernelCheckerBase
from .common import (
    Justification,
    Response,
    VulnerabilityAnalysis,
    VulnerabilityState,
    timed_method,
)


class VulnerabilityAnalyzer(VexKernelCheckerBase):
    """Handles vulnerability analysis and architecture compatibility checking."""

    def __init__(self, **kwargs):
        """Initialize the VulnerabilityAnalyzer.
        
        Args:
            **kwargs: Additional keyword arguments passed to the base class.
        """
        super().__init__(**kwargs)
        self._processed_cves = set()
        self._driver_patterns = self._init_driver_patterns()
        self._arch_patterns = self._init_architecture_patterns()

    def _init_driver_patterns(self) -> Dict[str, Set[str]]:
        """Initialize driver-specific patterns and their associated config options."""
        return {
            # Network drivers
            'mlx5': {
                'CONFIG_MLX5_CORE',
                'CONFIG_MLX5_CORE_EN',
                'CONFIG_MLX5_EN_ARFS',
                'CONFIG_MLX5_EN_RXNFC',
                'CONFIG_MLX5_INFINIBAND',
                'CONFIG_NET',
                'CONFIG_ETHERNET',
                'CONFIG_NETDEVICES',
            },
            'mlx4': {
                'CONFIG_MLX4_CORE',
                'CONFIG_MLX4_EN',
                'CONFIG_MLX4_INFINIBAND',
                'CONFIG_NET',
                'CONFIG_ETHERNET',
                'CONFIG_NETDEVICES',
            },
            'mellanox': {
                'CONFIG_MLX5_CORE',
                'CONFIG_MLX4_CORE',
                'CONFIG_NET',
                'CONFIG_ETHERNET',
                'CONFIG_NETDEVICES',
            },
            'intel ethernet': {
                'CONFIG_E1000',
                'CONFIG_E1000E',
                'CONFIG_IGB',
                'CONFIG_IGBVF',
                'CONFIG_IXGB',
                'CONFIG_IXGBE',
                'CONFIG_I40E',
                'CONFIG_ICE',
                'CONFIG_NET',
                'CONFIG_ETHERNET',
                'CONFIG_NETDEVICES',
            },
            'intel wifi': {
                'CONFIG_IWLWIFI',
                'CONFIG_IWLDVM',
                'CONFIG_IWLMVM',
                'CONFIG_WIRELESS',
                'CONFIG_WLAN',
                'CONFIG_NET',
            },
            'broadcom': {
                'CONFIG_B44',
                'CONFIG_BNX2',
                'CONFIG_BNX2X',
                'CONFIG_TIGON3',
                'CONFIG_NET',
                'CONFIG_ETHERNET',
                'CONFIG_NETDEVICES',
            },
            'realtek': {
                'CONFIG_8139TOO',
                'CONFIG_R8169',
                'CONFIG_NET',
                'CONFIG_ETHERNET',
                'CONFIG_NETDEVICES',
            },
            # USB drivers
            'usb': {'CONFIG_USB', 'CONFIG_USB_SUPPORT', 'CONFIG_USB_COMMON'},
            'usb-storage': {'CONFIG_USB_STORAGE', 'CONFIG_USB', 'CONFIG_SCSI'},
            'usbhid': {'CONFIG_USB_HID', 'CONFIG_HID', 'CONFIG_USB', 'CONFIG_INPUT'},
            # Bluetooth drivers
            'bluetooth': {'CONFIG_BT', 'CONFIG_BT_BREDR', 'CONFIG_BT_LE', 'CONFIG_NET'},
            'btusb': {'CONFIG_BT_HCIBTUSB', 'CONFIG_BT', 'CONFIG_USB'},
            # WiFi drivers
            'ath': {
                'CONFIG_ATH_COMMON',
                'CONFIG_ATH9K',
                'CONFIG_ATH10K',
                'CONFIG_WIRELESS',
                'CONFIG_WLAN',
                'CONFIG_NET',
            },
            'ath9k': {
                'CONFIG_ATH9K',
                'CONFIG_ATH_COMMON',
                'CONFIG_WIRELESS',
                'CONFIG_WLAN',
            },
            'ath10k': {
                'CONFIG_ATH10K',
                'CONFIG_ATH_COMMON',
                'CONFIG_WIRELESS',
                'CONFIG_WLAN',
            },
            'rtl8': {
                'CONFIG_RTL8180',
                'CONFIG_RTL8187',
                'CONFIG_RTL8192CE',
                'CONFIG_WIRELESS',
                'CONFIG_WLAN',
                'CONFIG_NET',
            },
            # Graphics drivers
            'drm': {'CONFIG_DRM', 'CONFIG_DRM_KMS_HELPER'},
            'i915': {'CONFIG_DRM_I915', 'CONFIG_DRM', 'CONFIG_PCI'},
            'amdgpu': {'CONFIG_DRM_AMDGPU', 'CONFIG_DRM', 'CONFIG_PCI'},
            'radeon': {'CONFIG_DRM_RADEON', 'CONFIG_DRM', 'CONFIG_PCI'},
            'nouveau': {'CONFIG_DRM_NOUVEAU', 'CONFIG_DRM', 'CONFIG_PCI'},
            # Sound drivers
            'alsa': {'CONFIG_SND', 'CONFIG_SOUND', 'CONFIG_SND_PCM'},
            'snd_': {'CONFIG_SND', 'CONFIG_SOUND'},
            # Storage drivers
            'nvme': {
                'CONFIG_BLK_DEV_NVME',
                'CONFIG_NVME_CORE',
                'CONFIG_PCI',
                'CONFIG_BLOCK',
            },
            'scsi': {'CONFIG_SCSI', 'CONFIG_SCSI_LOWLEVEL', 'CONFIG_BLOCK'},
            'ahci': {'CONFIG_SATA_AHCI', 'CONFIG_ATA', 'CONFIG_BLOCK', 'CONFIG_PCI'},
            'mmc': {'CONFIG_MMC', 'CONFIG_MMC_BLOCK'},
            # Input drivers
            'input': {'CONFIG_INPUT', 'CONFIG_INPUT_KEYBOARD', 'CONFIG_INPUT_MOUSE'},
            'hid': {'CONFIG_HID', 'CONFIG_INPUT'},
            # Virtualization drivers
            'kvm': {'CONFIG_KVM', 'CONFIG_VIRTUALIZATION'},
            'xen': {'CONFIG_XEN', 'CONFIG_PARAVIRT'},
            'vmware': {'CONFIG_VMWARE_BALLOON', 'CONFIG_VMXNET3', 'CONFIG_NET'},
            # Filesystems
            'ext4': {'CONFIG_EXT4_FS', 'CONFIG_EXT4_USE_FOR_EXT2', 'CONFIG_BLOCK'},
            'xfs': {'CONFIG_XFS_FS', 'CONFIG_BLOCK'},
            'btrfs': {'CONFIG_BTRFS_FS', 'CONFIG_BLOCK'},
            'nfs': {'CONFIG_NFS_FS', 'CONFIG_NFS_V4', 'CONFIG_NET'},
            'cifs': {
                'CONFIG_CIFS',
                'CONFIG_CIFS_WEAK_PW_HASH',
                'CONFIG_CIFS_UPCALL',
                'CONFIG_CIFS_XATTR',
                'CONFIG_CIFS_POSIX',
                'CONFIG_NET',
            },
            'smb': {
                'CONFIG_CIFS',
                'CONFIG_CIFS_WEAK_PW_HASH',
                'CONFIG_CIFS_UPCALL',
                'CONFIG_CIFS_XATTR',
                'CONFIG_CIFS_POSIX',
                'CONFIG_NET',
            },
            'smbfs': {
                'CONFIG_CIFS',
                'CONFIG_CIFS_WEAK_PW_HASH',
                'CONFIG_CIFS_UPCALL',
                'CONFIG_CIFS_XATTR',
                'CONFIG_CIFS_POSIX',
                'CONFIG_NET',
            },
            # Security drivers
            'selinux': {'CONFIG_SECURITY_SELINUX', 'CONFIG_SECURITY'},
            'apparmor': {'CONFIG_SECURITY_APPARMOR', 'CONFIG_SECURITY'},
        }

    def _init_architecture_patterns(self) -> Dict[str, List[str]]:
        """Initialize architecture-specific patterns."""
        return {
            'x86': ['x86', 'intel', 'amd64', 'i386', 'i486', 'i586', 'i686'],
            'x86_64': ['x86_64', 'amd64', 'intel 64', 'x64'],
            'arm': ['arm32', 'armv7', 'armv6', 'arm cortex'],
            'arm64': ['arm64', 'aarch64', 'armv8'],
            'mips': ['mips', 'mips32', 'mips64'],
            'powerpc': ['powerpc', 'ppc', 'ppc32', 'ppc64'],
            'riscv': ['riscv', 'risc-v', 'riscv32', 'riscv64'],
            's390': ['s390', 's390x', 'ibm z'],
            'sparc': ['sparc', 'sparc32', 'sparc64', 'sun'],
            'alpha': ['alpha', 'dec alpha'],
            'ia64': ['ia64', 'itanium'],
            'm68k': ['m68k', 'motorola 68k'],
            'sh': ['superh', 'sh4'],
            'microblaze': ['microblaze'],
            'parisc': ['parisc', 'pa-risc'],
            'xtensa': ['xtensa'],
        }

    @timed_method
    def analyze_cve(
        self,
        cve: Dict,
        kernel_config: List[str],
        kernel_source_path: str,
        cve_manager,
        patch_manager,
        config_analyzer,
    ) -> Optional[VulnerabilityAnalysis]:
        """
        Main method to analyze a CVE for vulnerability.

        Args:
            cve: CVE dictionary with id and description
            kernel_config: List of kernel configuration options
            kernel_source_path: Path to kernel source
            cve_manager: CVE data manager instance
            patch_manager: Patch manager instance
            config_analyzer: Configuration analyzer instance

        Returns:
            VulnerabilityAnalysis or None if no analysis possible
        """
        try:
            # Phase 1: Validate input and check if already processed
            cve_id = self._validate_cve_input(cve)
            if not cve_id:
                return None

            # Phase 2: Fetch CVE details if patch checking enabled
            cve_info = self._fetch_cve_details(cve_id, cve_manager)

            # Phase 3: Check if CVE is kernel-related
            if not self._check_kernel_relevance(cve, cve_id, cve_info, cve_manager):
                return None

            # Phase 4: Try patch-based analysis first
            if self.check_patches and cve_info:
                patch_analysis = self._analyze_patch_content(
                    cve, cve_id, cve_info, patch_manager, config_analyzer, kernel_config
                )
                if patch_analysis:
                    return patch_analysis
            elif self.check_patches and not cve_info:
                if self.verbose:
                    print('ðŸ” VulnAnalyzer: check_patches=True but cve_info=None, skipping patch analysis')
            elif not self.check_patches:
                if self.verbose:
                    print('ðŸ” VulnAnalyzer: check_patches=False, skipping patch analysis')

            # Phase 5: Fallback analysis
            fallback_analysis = self._perform_fallback_analysis(cve, cve_id, kernel_config)
            if fallback_analysis:
                return fallback_analysis

            # Phase 6: Final fallback - no specific analysis possible
            if self.verbose:
                print(f'Unable to determine configuration requirements for {cve_id} - leaving unprocessed')
            return None

        except Exception as e:
            if self.verbose:
                print(f"Error analyzing {cve.get('id', 'unknown')}: {e}")
                import traceback
                traceback.print_exc()
            return None

    @timed_method
    def infer_driver_configs_from_description(self, description: str) -> Set[str]:
        """
        Infer driver-specific configuration options from CVE description.

        Args:
            description: CVE description text

        Returns:
            Set of configuration options relevant to the detected drivers
        """
        driver_configs = set()
        description_lower = description.lower()

        # Check for driver patterns in the description
        for pattern, configs in self._driver_patterns.items():
            if pattern in description_lower:
                driver_configs.update(configs)
                if self.verbose:
                    print(
                        f"Found driver pattern '{pattern}' - adding configs: {', '.join(configs)}"
                    )

        # Additional pattern-based detection for specific subsystems

        # Detect network subsystem patterns
        net_patterns = ['net/', 'drivers/net/', 'network', 'netdev', 'skb', 'socket']
        if any(pattern in description_lower for pattern in net_patterns):
            driver_configs.update(['CONFIG_NET', 'CONFIG_NETDEVICES'])

        # Detect USB subsystem patterns
        usb_patterns = ['usb', 'drivers/usb/', 'urb', 'endpoint']
        if any(pattern in description_lower for pattern in usb_patterns):
            driver_configs.update(['CONFIG_USB', 'CONFIG_USB_SUPPORT'])

        # Detect graphics subsystem patterns
        gpu_patterns = ['drm', 'gpu', 'graphics', 'display', 'framebuffer']
        if any(pattern in description_lower for pattern in gpu_patterns):
            # Only add specific driver configs if detected
            if 'i915' in description_lower:
                driver_configs.update(['CONFIG_DRM_I915'])
            elif 'amdgpu' in description_lower or 'amd' in description_lower:
                driver_configs.update(['CONFIG_DRM_AMDGPU'])
            elif 'radeon' in description_lower:
                driver_configs.update(['CONFIG_DRM_RADEON'])
            elif 'nouveau' in description_lower or 'nvidia' in description_lower:
                driver_configs.update(['CONFIG_DRM_NOUVEAU'])

        # Detect storage subsystem patterns
        storage_patterns = ['block', 'disk', 'storage', 'scsi', 'ata', 'ide']
        if any(pattern in description_lower for pattern in storage_patterns):
            driver_configs.update(['CONFIG_BLOCK'])

        # Detect wireless patterns
        wireless_patterns = ['wireless', 'wifi', 'wlan', '802.11']
        if any(pattern in description_lower for pattern in wireless_patterns):
            driver_configs.update(['CONFIG_WIRELESS', 'CONFIG_WLAN', 'CONFIG_NET'])

        # Detect sound patterns
        sound_patterns = ['sound', 'audio', 'alsa', 'pcm']
        if any(pattern in description_lower for pattern in sound_patterns):
            driver_configs.update(['CONFIG_SOUND', 'CONFIG_SND'])

        # Detect SMB/CIFS patterns specifically
        smb_patterns = ['smb', 'cifs', 'samba', 'smb2', 'smb3']
        if any(pattern in description_lower for pattern in smb_patterns):
            driver_configs.update(['CONFIG_CIFS', 'CONFIG_NET'])

        return driver_configs

    @timed_method
    def check_architecture_compatibility(
        self,
        cve: Dict,
        cve_info: Optional[Dict] = None,
        patch_content: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Check if a CVE is compatible with the detected system architecture.

        Args:
            cve: CVE dictionary with description and ID
            cve_info: Optional CVE info object with patch URLs
            patch_content: Optional patch content for analysis

        Returns:
            Dictionary with compatibility information
        """
        if not self.arch:
            return {
                'compatible': True,
                'reason': 'No architecture detected',
                'detail': 'Architecture compatibility could not be determined',
            }

        description = cve.get('description', '').lower()
        cve_id = cve.get('id', 'unknown')

        # Check if CVE description mentions specific architectures
        mentioned_archs = []
        for arch, patterns in self._arch_patterns.items():
            for pattern in patterns:
                if pattern in description:
                    mentioned_archs.append(arch)
                    break

        # Remove duplicates and normalize
        mentioned_archs = list(set(mentioned_archs))

        # Normalize current architecture for comparison
        current_arch_normalized = self.arch.lower()
        if current_arch_normalized == 'x86_64':
            current_arch_alternatives = ['x86_64', 'amd64', 'x64']
        elif current_arch_normalized == 'arm64':
            current_arch_alternatives = ['arm64', 'aarch64']
        elif current_arch_normalized == 'powerpc':
            current_arch_alternatives = ['powerpc', 'ppc']
        else:
            current_arch_alternatives = [current_arch_normalized]

        # Check for incompatibility
        if mentioned_archs:
            # Check if any mentioned architecture matches current architecture
            compatible = any(
                mentioned_arch in current_arch_alternatives
                or any(alt in mentioned_arch for alt in current_arch_alternatives)
                for mentioned_arch in mentioned_archs
            )

            if not compatible:
                return {
                    'compatible': False,
                    'reason': f'CVE targets {', '.join(mentioned_archs)} but system is {self.arch}',
                    'detail': f'CVE {cve_id} specifically affects {', '.join(mentioned_archs)} '
                    f'architecture(s), but the current system is {self.arch}',
                }

        # Check patch content for architecture-specific patterns
        if patch_content:
            # Look for architecture-specific directories and files in patch
            arch_paths = [
                'arch/x86',
                'arch/arm',
                'arch/arm64',
                'arch/mips',
                'arch/powerpc',
                'arch/s390',
                'arch/sparc',
            ]

            patch_specific_archs = []
            for arch_path in arch_paths:
                if arch_path in patch_content:
                    arch_name = arch_path.split('/')[1]
                    patch_specific_archs.append(arch_name)

            if patch_specific_archs:
                # Check if current architecture is among the patched architectures
                compatible = any(
                    arch in current_arch_alternatives
                    or any(alt in arch for alt in current_arch_alternatives)
                    for arch in patch_specific_archs
                )

                if not compatible:
                    return {
                        'compatible': False,
                        'reason': f'Patch targets {', '.join(patch_specific_archs)} but system is {self.arch}',
                        'detail': f'CVE {cve_id} patch affects {', '.join(patch_specific_archs)} '
                        f'architecture(s), but the current system is {self.arch}',
                    }

        return {
            'compatible': True,
            'reason': 'Architecture compatible',
            'detail': f'CVE {cve_id} is compatible with {self.arch} architecture',
        }

    @timed_method
    def analyze_config_requirements(
        self, config_options: Set[str], kernel_config: List[str]
    ) -> VulnerabilityAnalysis:
        """
        Analyze if the required configuration options are enabled in the kernel.

        Args:
            config_options: Set of required configuration options
            kernel_config: List of kernel configuration lines

        Returns:
            VulnerabilityAnalysis with the analysis result
        """
        # Separate core driver and filesystem configs from dependencies and architecture configs
        core_driver_filesystem_configs = self._get_core_driver_filesystem_configs(
            config_options
        )
        arch_configs = self._get_arch_specific_configs()

        # Add architecture configs for comprehensive check, but track separately
        all_config_options = set(config_options)
        if arch_configs:
            all_config_options.update(arch_configs)
            if self.verbose and arch_configs:
                print(f"Added architecture-specific configs: {', '.join(arch_configs)}")

        if not core_driver_filesystem_configs:
            return VulnerabilityAnalysis(
                state=VulnerabilityState.IN_TRIAGE,
                justification=Justification.CODE_NOT_PRESENT,
                response=Response.CAN_NOT_FIX,
                detail='No configuration requirements identified',
                timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            )

        # Parse kernel config into a dictionary
        enabled_configs = set()
        disabled_configs = set()

        for line in kernel_config:
            line = line.strip()
            if line.startswith('CONFIG_') and '=' in line:
                config_name, value = line.split('=', 1)
                if value in ['y', 'm']:
                    enabled_configs.add(config_name)
                elif value == 'n':
                    disabled_configs.add(config_name)
            elif line.startswith('# CONFIG_') and line.endswith(' is not set'):
                # Extract config name from '# CONFIG_NAME is not set'
                config_name = line[2:].split(' is not set')[0]
                disabled_configs.add(config_name)

        # Check core driver and filesystem configs (these are the ones that matter for vulnerability)
        enabled_driver_configs = core_driver_filesystem_configs.intersection(
            enabled_configs
        )
        missing_driver_configs = core_driver_filesystem_configs - enabled_configs

        # Check all configs for comprehensive analysis
        enabled_required = all_config_options.intersection(enabled_configs)
        missing_required = all_config_options - enabled_configs

        if self.verbose:
            print(f"Required configs: {', '.join(sorted(all_config_options))}")
            print(f"Enabled required: {', '.join(sorted(enabled_required))}")
            print(f"Missing required: {', '.join(sorted(missing_required))}")

        # Determine vulnerability state based on CORE DRIVER/FILESYSTEM configuration analysis
        # Architecture and dependency configs are checked but don't affect the vulnerability determination
        if not missing_driver_configs:
            # All required core driver/filesystem configs are enabled
            return VulnerabilityAnalysis(
                state=VulnerabilityState.EXPLOITABLE,
                justification=Justification.REQUIRES_CONFIGURATION,
                response=Response.CAN_NOT_FIX,
                detail=f"All required driver/filesystem configurations are enabled: {', '.join(sorted(enabled_driver_configs))}",
                timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            )
        elif enabled_driver_configs:
            # Some but not all required core driver/filesystem configs are enabled
            return VulnerabilityAnalysis(
                state=VulnerabilityState.IN_TRIAGE,
                justification=Justification.REQUIRES_CONFIGURATION,
                response=Response.CAN_NOT_FIX,
                detail=(
                    f'Partial driver/filesystem configuration match. '
                    f"Enabled: {', '.join(sorted(enabled_driver_configs))}. "
                    f"Missing: {', '.join(sorted(missing_driver_configs))}"
                ),
                timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            )
        else:
            # No required core driver/filesystem configs are enabled - this is the key case for CIFS
            return VulnerabilityAnalysis(
                state=VulnerabilityState.NOT_AFFECTED,
                justification=Justification.REQUIRES_CONFIGURATION,
                response=Response.WILL_NOT_FIX,
                detail=f"Required driver/filesystem configs not enabled: {', '.join(sorted(missing_driver_configs))}",
                timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            )

    def _get_arch_specific_configs(self) -> Set[str]:
        """Get architecture-specific configuration options from detected architecture."""
        arch_configs = set()

        if self.arch:
            # Add the main architecture config
            arch_config_map = {
                'arm': 'CONFIG_ARM',
                'arm64': 'CONFIG_ARM64',
                'x86': 'CONFIG_X86',
                'x86_64': 'CONFIG_X86',
                'mips': 'CONFIG_MIPS',
                'powerpc': 'CONFIG_POWERPC',
                'riscv': 'CONFIG_RISCV',
                's390': 'CONFIG_S390',
                'sparc': 'CONFIG_SPARC',
                'sparc64': 'CONFIG_SPARC64',
            }

            if self.arch in arch_config_map:
                arch_configs.add(arch_config_map[self.arch])

            # Add common architecture-specific configs
            arch_specific_mappings = {
                'arm': ['CONFIG_ARM', 'CONFIG_ARM_THUMB', 'CONFIG_ARM_LPAE'],
                'arm64': [
                    'CONFIG_ARM64',
                    'CONFIG_ARM64_4K_PAGES',
                    'CONFIG_ARM64_VA_BITS_48',
                ],
                'x86': ['CONFIG_X86', 'CONFIG_X86_32'],
                'x86_64': ['CONFIG_X86', 'CONFIG_X86_64', 'CONFIG_64BIT'],
                'mips': ['CONFIG_MIPS', 'CONFIG_MIPS32_R1'],
                'powerpc': ['CONFIG_PPC', 'CONFIG_POWERPC'],
                'riscv': ['CONFIG_RISCV'],
                's390': ['CONFIG_S390'],
                'sparc': ['CONFIG_SPARC'],
                'sparc64': ['CONFIG_SPARC64', 'CONFIG_64BIT'],
            }

            if self.arch in arch_specific_mappings:
                arch_configs.update(arch_specific_mappings[self.arch])

        return arch_configs

    def _get_core_driver_filesystem_configs(self, driver_configs: Set[str]) -> Set[str]:
        """
        Extract core driver and filesystem configs excluding common dependencies.

        Args:
            driver_configs: Full set of driver and filesystem configs including dependencies

        Returns:
            Set of core driver and filesystem configs (excluding common dependencies)
        """
        # Common dependency configs that shouldn't count as 'core driver/filesystem' configs
        dependency_configs = {
            'CONFIG_NET',
            'CONFIG_NETDEVICES',
            'CONFIG_ETHERNET',
            'CONFIG_BLOCK',
            'CONFIG_PCI',
            'CONFIG_USB',
            'CONFIG_INPUT',
            'CONFIG_SOUND',
            'CONFIG_DRM',
            'CONFIG_SCSI',
            'CONFIG_ATA',
            'CONFIG_WIRELESS',
            'CONFIG_WLAN',
            'CONFIG_SECURITY',
        }

        # Return only the configs that are not common dependencies
        core_configs = driver_configs - dependency_configs

        # If no core configs remain, return the original set
        # (this handles cases where all configs are dependencies)
        if not core_configs:
            return driver_configs

        return core_configs

    def _validate_cve_input(self, cve: Dict) -> Optional[str]:
        """Validate CVE input and return CVE ID."""
        cve_id = cve.get('id', '')
        if not cve_id:
            if self.verbose:
                print('Missing CVE ID - skipping analysis')
            return None
        
        if cve_id in self._processed_cves:
            if self.verbose:
                print(f'Skipping {cve_id} - already processed')
            return None
        
        self._processed_cves.add(cve_id)
        if self.verbose:
            print(f'\n--- Analyzing {cve_id} ---')
        
        return cve_id

    def _fetch_cve_details(self, cve_id: str, cve_manager) -> Optional[Dict]:
        """Fetch CVE details from NVD API if patch checking is enabled."""
        if not self.check_patches:
            if self.verbose:
                print(f'ðŸ” VulnAnalyzer: check_patches={self.check_patches}, skipping CVE fetch')
            return None
            
        if self.verbose:
            print('ðŸ” Step 1/4: Fetching CVE details from NVD API...')
            print(f'ðŸ” VulnAnalyzer: check_patches={self.check_patches}, calling cve_manager.fetch_cve_details')
        
        cve_info = cve_manager.fetch_cve_details(cve_id)
        
        if cve_info:
            if self.verbose:
                print(f'ðŸ” VulnAnalyzer: Successfully got CVE info for {cve_id}')
        elif self.verbose:
            print(f'ðŸ” VulnAnalyzer: Could not fetch CVE details for {cve_id} - proceeding with VEX description analysis')
        
        return cve_info

    def _check_kernel_relevance(self, cve: Dict, cve_id: str, cve_info: Optional[Dict], cve_manager) -> bool:
        """Check if CVE is kernel-related."""
        if self.analyze_all_cves:
            return True
            
        if cve_info:
            if self.verbose:
                print('ðŸ” Step 2/4: Checking if CVE is kernel-related...')
            if not cve_manager.is_kernel_related_cve(cve_info):
                if self.verbose:
                    print(f'CVE {cve_id} is not kernel-related - skipping analysis')
                return False
        else:
            # For CVEs without detailed info, check description for kernel relevance
            description = cve.get('description', '').lower()
            kernel_keywords = [
                'linux kernel', 'kernel', 'drivers/', 'net/', 'fs/', 'arch/', 'kernel.org',
            ]
            if not any(keyword in description for keyword in kernel_keywords):
                if self.verbose:
                    print(f'CVE {cve_id} description does not appear kernel-related - skipping analysis')
                return False
        
        return True

    def _analyze_patch_content(self, cve: Dict, cve_id: str, cve_info: Dict, patch_manager, config_analyzer, kernel_config: List[str]) -> Optional[VulnerabilityAnalysis]:
        """Analyze patch content and configuration requirements."""
        if self.verbose:
            print('ðŸ” Step 3/4: Extracting and fetching patch content...')
            print('ðŸ” VulnAnalyzer: Calling patch_manager.extract_patch_url')
        
        patch_url = patch_manager.extract_patch_url(cve_info)
        
        if not patch_url:
            return None
            
        if self.verbose:
            print(f'ðŸ” VulnAnalyzer: Found patch URL: {patch_url}')
            print('ðŸ” VulnAnalyzer: Calling patch_manager.fetch_patch_content_with_github_priority')

        # Fetch patch content
        patch_info = patch_manager.fetch_patch_content_with_github_priority(patch_url)
        
        if not patch_info:
            return None
            
        if self.verbose:
            print(f'ðŸ” VulnAnalyzer: Successfully fetched patch content for {cve_id}')
        
        # Early architecture compatibility check
        arch_compatibility = self.check_architecture_compatibility(cve, cve_info, patch_info)
        if not arch_compatibility['compatible']:
            if self.verbose:
                print(f"CVE not compatible with current architecture: {arch_compatibility['reason']}")
            
            return VulnerabilityAnalysis(
                state=VulnerabilityState.NOT_AFFECTED,
                justification=Justification.REQUIRES_ENVIRONMENT,
                response=Response.WILL_NOT_FIX,
                detail=arch_compatibility['detail'],
                timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            )

        # Analyze configuration requirements
        return self._analyze_source_files(cve_id, patch_info, patch_manager, config_analyzer, kernel_config)

    def _analyze_source_files(self, cve_id: str, patch_info: Dict, patch_manager, config_analyzer, kernel_config: List[str]) -> Optional[VulnerabilityAnalysis]:
        """Analyze source files from patch for configuration requirements."""
        if self.verbose:
            print('ðŸ” Step 4/4: Analyzing configuration requirements...')

        source_files = patch_manager.extract_sourcefiles(patch_info)
        
        if not source_files:
            return None
            
        if self.verbose:
            print(f'Analyzing {len(source_files)} source files from patch')

        all_config_options = set()
        source_file_list = list(source_files)[:20]  # Limit to 20 files

        for i, source_file in enumerate(source_file_list):
            try:
                if self.verbose and len(source_file_list) > 1:
                    print(f'   ðŸ“ Analyzing file {i+1}/{len(source_file_list)}: {source_file}')

                configs = config_analyzer.analyze_source_file_configs(source_file)
                all_config_options.update(configs)
                
            except Exception as exc:
                if self.verbose:
                    print(f'Error analyzing source file {source_file}: {exc}')

        if all_config_options:
            config_analysis = self.analyze_config_requirements(all_config_options, kernel_config)
            if config_analysis:
                return config_analysis

        return None

    def _perform_fallback_analysis(self, cve: Dict, cve_id: str, kernel_config: List[str]) -> Optional[VulnerabilityAnalysis]:
        """Perform driver-specific and general fallback analysis."""
        description = cve.get('description', '').lower()
        
        # Driver-specific fallback analysis
        driver_configs = self.infer_driver_configs_from_description(description)
        if driver_configs:
            if self.verbose:
                print(f'Driver-specific analysis: found {len(driver_configs)} relevant configs')
            config_analysis = self.analyze_config_requirements(driver_configs, kernel_config)
            if config_analysis:
                return config_analysis

        # General fallback - check if description contains specific vulnerability indicators
        vulnerability_keywords = [
            'use-after-free', 'buffer overflow', 'null pointer dereference',
            'memory corruption', 'heap overflow', 'stack overflow', 'double free',
            'out-of-bounds', 'format string', 'integer overflow'
        ]
        
        if any(keyword in description for keyword in vulnerability_keywords):
            if self.verbose:
                print(f'Found vulnerability keywords in {cve_id} description')
            return VulnerabilityAnalysis(
                state=VulnerabilityState.IN_TRIAGE,
                justification=Justification.REQUIRES_CONFIGURATION,
                response=Response.WILL_NOT_FIX,
                detail='CVE contains vulnerability indicators but specific configuration requirements could not be determined',
                timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
            )

        return None
