#!/usr/bin/env python3
"""
Unit tests for VulnerabilityAnalyzer module.
Tests vulnerability analysis logic, pattern matching, and state determination.
"""

import unittest
from unittest.mock import Mock, patch, MagicMock
import sys
import os

# Add the parent directory to the path so we can import the vex_kernel_checker package
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from vex_kernel_checker.vulnerability_analyzer import VulnerabilityAnalyzer
from vex_kernel_checker.common import VulnerabilityState, Justification, VulnerabilityAnalysis


class TestVulnerabilityAnalyzer(unittest.TestCase):
    """Test cases for VulnerabilityAnalyzer class."""

    def setUp(self):
        """Set up test fixtures."""
        self.analyzer = VulnerabilityAnalyzer()
        
        # Sample kernel config for testing
        self.sample_config = [
            'CONFIG_NET=y',
            'CONFIG_ETHERNET=y', 
            'CONFIG_R8169=m',
            'CONFIG_USB=y',
            'CONFIG_USB_STORAGE=n',
            'CONFIG_CIFS=y',
            'CONFIG_NFS_FS=y',
            'CONFIG_DRM=y',
            'CONFIG_DRM_I915=m'
        ]
        
        # Sample CVE for testing
        self.sample_cve = {
            'id': 'CVE-2023-1234',
            'description': 'Vulnerability in network driver causing buffer overflow'
        }

    def test_analyzer_initialization(self):
        """Test VulnerabilityAnalyzer initialization."""
        # Test with default parameters
        analyzer1 = VulnerabilityAnalyzer()
        self.assertIsNotNone(analyzer1)
        
        # Test with custom parameters
        analyzer2 = VulnerabilityAnalyzer(verbose=True, check_patches=True)
        self.assertTrue(analyzer2.verbose)
        self.assertTrue(analyzer2.check_patches)

    def test_driver_patterns_initialization(self):
        """Test that driver patterns are properly initialized."""
        patterns = self.analyzer._driver_patterns
        
        self.assertIsInstance(patterns, dict)
        self.assertIn('realtek', patterns)
        self.assertIn('usb', patterns)
        self.assertIn('drm', patterns)
        
        # Check that patterns contain expected config options
        realtek_configs = patterns.get('realtek', set())
        self.assertIn('CONFIG_R8169', realtek_configs)
        self.assertIn('CONFIG_NET', realtek_configs)

    def test_architecture_patterns_initialization(self):
        """Test that architecture patterns are properly initialized."""
        arch_patterns = self.analyzer._arch_patterns
        
        self.assertIsInstance(arch_patterns, dict)
        # Should contain architecture-specific patterns
        self.assertTrue(len(arch_patterns) >= 0)  # May be empty depending on implementation

    def test_driver_pattern_matching_realtek(self):
        """Test driver pattern matching for Realtek drivers."""
        cve_description = "Buffer overflow in Realtek RTL8169 network driver"
        
        # Check if the analyzer can identify relevant patterns
        patterns = self.analyzer._driver_patterns
        realtek_pattern = patterns.get('realtek', set())
        
        self.assertIn('CONFIG_R8169', realtek_pattern)
        self.assertIn('CONFIG_NET', realtek_pattern)

    def test_driver_pattern_matching_usb(self):
        """Test driver pattern matching for USB drivers."""
        cve_description = "Vulnerability in USB storage driver implementation"
        
        patterns = self.analyzer._driver_patterns
        usb_pattern = patterns.get('usb', set())
        usb_storage_pattern = patterns.get('usb-storage', set())
        
        self.assertIn('CONFIG_USB', usb_pattern)
        if usb_storage_pattern:
            self.assertIn('CONFIG_USB_STORAGE', usb_storage_pattern)

    def test_driver_pattern_matching_graphics(self):
        """Test driver pattern matching for graphics drivers."""
        cve_description = "Memory corruption in Intel i915 graphics driver"
        
        patterns = self.analyzer._driver_patterns
        drm_pattern = patterns.get('drm', set())
        
        self.assertIn('CONFIG_DRM', drm_pattern)

    def test_analyze_cve_with_mocked_dependencies(self):
        """Test CVE analysis with properly mocked dependencies."""
        # Create mock dependencies
        mock_cve_manager = Mock()
        mock_patch_manager = Mock()
        mock_config_analyzer = Mock()
        
        # Mock CVE manager to return CVE info
        mock_cve_info = Mock()
        mock_cve_info.cve_id = "CVE-2023-1234"
        mock_cve_info.description = "Test vulnerability"
        mock_cve_manager.get_cve_info.return_value = mock_cve_info
        
        # Mock patch manager
        mock_patch_info = Mock()
        mock_patch_info.has_patch = False
        mock_patch_manager.get_patch_info.return_value = mock_patch_info
        
        # Create analyzer with patch checking disabled to simplify test
        analyzer = VulnerabilityAnalyzer(check_patches=False, verbose=False)
        
        result = analyzer.analyze_cve(
            self.sample_cve,
            self.sample_config,
            "/fake/kernel/source",
            mock_cve_manager,
            mock_patch_manager,
            mock_config_analyzer
        )
        
        # Should return some result (or None if CVE is filtered out)
        # The exact result depends on the analysis logic
        self.assertIsInstance(result, (VulnerabilityAnalysis, type(None)))

    def test_analyze_cve_missing_cve_id(self):
        """Test CVE analysis with missing CVE ID."""
        mock_cve_manager = Mock()
        mock_patch_manager = Mock()
        mock_config_analyzer = Mock()
        
        cve_without_id = {'description': 'Test vulnerability without ID'}
        
        result = self.analyzer.analyze_cve(
            cve_without_id,
            self.sample_config,
            "/fake/kernel/source",
            mock_cve_manager,
            mock_patch_manager,
            mock_config_analyzer
        )
        
        # Should return None for CVE without ID
        self.assertIsNone(result)

    def test_analyze_cve_already_processed(self):
        """Test that already processed CVEs are skipped."""
        mock_cve_manager = Mock()
        mock_patch_manager = Mock()
        mock_config_analyzer = Mock()
        
        # Add CVE to processed set
        self.analyzer._processed_cves.add('CVE-2023-1234')
        
        result = self.analyzer.analyze_cve(
            self.sample_cve,
            self.sample_config,
            "/fake/kernel/source",
            mock_cve_manager,
            mock_patch_manager,
            mock_config_analyzer
        )
        
        # Should return None for already processed CVE
        self.assertIsNone(result)

    def test_processed_cves_tracking(self):
        """Test that processed CVEs are properly tracked."""
        self.assertIsInstance(self.analyzer._processed_cves, set)
        
        # Initially empty
        self.assertEqual(len(self.analyzer._processed_cves), 0)
        
        # Add a CVE ID
        self.analyzer._processed_cves.add('CVE-2023-TEST')
        self.assertIn('CVE-2023-TEST', self.analyzer._processed_cves)

    def test_timed_method_decorator(self):
        """Test that the analyze_cve method is properly decorated with timing."""
        # Check that the method exists and is callable
        self.assertTrue(hasattr(self.analyzer, 'analyze_cve'))
        self.assertTrue(callable(self.analyzer.analyze_cve))
        
        # The method should have performance tracking capabilities from the base class
        self.assertTrue(hasattr(self.analyzer, 'perf_tracker'))  # Changed from 'timings'

    def test_vulnerability_state_enum_values(self):
        """Test that vulnerability state enums have correct values."""
        self.assertEqual(VulnerabilityState.NOT_AFFECTED.value, 'not_affected')
        self.assertEqual(VulnerabilityState.EXPLOITABLE.value, 'exploitable')
        self.assertEqual(VulnerabilityState.RESOLVED.value, 'resolved')
        self.assertEqual(VulnerabilityState.IN_TRIAGE.value, 'in_triage')

    def test_justification_enum_values(self):
        """Test that justification enums have correct values."""
        self.assertEqual(Justification.CODE_NOT_PRESENT.value, 'code_not_present')
        self.assertEqual(Justification.CODE_NOT_REACHABLE.value, 'code_not_reachable')
        self.assertEqual(Justification.REQUIRES_CONFIGURATION.value, 'requires_configuration')

    def test_vulnerability_analysis_creation(self):
        """Test creating VulnerabilityAnalysis objects."""
        analysis = VulnerabilityAnalysis(
            state=VulnerabilityState.NOT_AFFECTED,
            justification=Justification.CODE_NOT_PRESENT,
            detail="Test analysis detail"
        )
        
        self.assertEqual(analysis.state, VulnerabilityState.NOT_AFFECTED)
        self.assertEqual(analysis.justification, Justification.CODE_NOT_PRESENT)
        self.assertEqual(analysis.detail, "Test analysis detail")

    def test_vulnerability_analysis_to_dict(self):
        """Test converting VulnerabilityAnalysis to dictionary."""
        analysis = VulnerabilityAnalysis(
            state=VulnerabilityState.EXPLOITABLE,
            justification=Justification.REQUIRES_CONFIGURATION,
            detail="Test detail"
        )
        
        analysis_dict = analysis.to_dict()
        
        self.assertIsInstance(analysis_dict, dict)
        self.assertEqual(analysis_dict['state'], 'exploitable')
        self.assertEqual(analysis_dict['justification'], 'requires_configuration')
        self.assertEqual(analysis_dict['detail'], 'Test detail')

    def test_base_class_inheritance(self):
        """Test that VulnerabilityAnalyzer properly inherits from base class."""
        # Should have verbose property from base class
        self.assertTrue(hasattr(self.analyzer, 'verbose'))
        
        # Should have performance tracker capabilities from base class
        self.assertTrue(hasattr(self.analyzer, 'perf_tracker'))  # Changed from 'timings'
        
        # Should have check_patches property
        self.assertTrue(hasattr(self.analyzer, 'check_patches'))

    @patch('time.time')
    def test_performance_tracking(self, mock_time):
        """Test that performance tracking works correctly."""
        # Mock time to return predictable values
        mock_time.side_effect = [1000.0, 1001.0]  # 1 second duration
        
        # Create mock dependencies
        mock_cve_manager = Mock()
        mock_patch_manager = Mock()
        mock_config_analyzer = Mock()
        
        # Disable patch checking and verbose output for cleaner test
        analyzer = VulnerabilityAnalyzer(check_patches=False, verbose=False)
        
        # Call the timed method
        result = analyzer.analyze_cve(
            self.sample_cve,
            self.sample_config,
            "/fake/kernel/source",
            mock_cve_manager,
            mock_patch_manager,
            mock_config_analyzer
        )
        
        # Check that the analyzer has performance tracking capabilities
        self.assertTrue(hasattr(analyzer, 'perf_tracker'))  # Changed from 'timings'

    def test_config_list_handling(self):
        """Test that the analyzer properly handles kernel config as a list."""
        config_list = [
            'CONFIG_NET=y',
            'CONFIG_USB=m',
            'CONFIG_DISABLED_OPTION=n'
        ]
        
        # Should not raise any errors when passed a list
        mock_cve_manager = Mock()
        mock_patch_manager = Mock()
        mock_config_analyzer = Mock()
        
        try:
            result = self.analyzer.analyze_cve(
                self.sample_cve,
                config_list,
                "/fake/kernel/source",
                mock_cve_manager,
                mock_patch_manager,
                mock_config_analyzer
            )
            # Should complete without error
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"analyze_cve raised an exception with list config: {e}")


if __name__ == '__main__':
    unittest.main()
